\hypertarget{classhelib_1_1_key_switch}{}\doxysection{helib\+::Key\+Switch Class Reference}
\label{classhelib_1_1_key_switch}\index{helib::KeySwitch@{helib::KeySwitch}}


Key-\/switching matrices.  




{\ttfamily \#include $<$key\+Switching.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classhelib_1_1_key_switch_a74d6cc93536febfff257b19fc63dc060}{Key\+Switch}} (long s\+Pow=0, long x\+Pow=0, long from\+ID=0, long to\+ID=0, long p=0)
\item 
\mbox{\hyperlink{classhelib_1_1_key_switch_a3cd8c681d701db5837260703b7b73b00}{Key\+Switch}} (const \mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} \&\+\_\+from\+Key, long from\+ID=0, long to\+ID=0, long p=0)
\item 
bool \mbox{\hyperlink{classhelib_1_1_key_switch_a70670acc9c59290c0e668455108aecec}{operator==}} (const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \&other) const
\item 
bool \mbox{\hyperlink{classhelib_1_1_key_switch_aa654d241726845e7a4b3c89ecf701596}{operator!=}} (const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \&other) const
\item 
unsigned long \mbox{\hyperlink{classhelib_1_1_key_switch_af5e067d1594615c8c3c44acb941e484f}{Num\+Cols}} () const
\item 
bool \mbox{\hyperlink{classhelib_1_1_key_switch_a0d5b6037b48b01c67bf29b0ae19f16e0}{is\+Dummy}} () const
\item 
void \mbox{\hyperlink{classhelib_1_1_key_switch_a84794d2ce7f58d204b2d561b443dc9ba}{verify}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\begin{DoxyCompactList}\small\item\em A debugging method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhelib_1_1_key_switch_a9d0189576a8418468aa50e6f7e5e2ca8}{read\+Matrix}} (std\+::istream \&str, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\begin{DoxyCompactList}\small\item\em Read a key-\/switching matrix from input. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhelib_1_1_key_switch_a6dd127dd7552981ab1a6b74d2f0a141b}{read}} (std\+::istream \&str, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\begin{DoxyCompactList}\small\item\em Raw IO. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhelib_1_1_key_switch_a7d5aacb77d9bf361522e29811e8994ca}{write}} (std\+::ostream \&str) const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \& \mbox{\hyperlink{classhelib_1_1_key_switch_afc9320fe88ca2cda85f04c362de85442}{dummy}} ()
\begin{DoxyCompactList}\small\item\em returns a dummy static matrix with to\+Key\+Id == -\/1 \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} \mbox{\hyperlink{classhelib_1_1_key_switch_a5b8267d055a0224c42ef247ddc7057f9}{from\+Key}}
\item 
long \mbox{\hyperlink{classhelib_1_1_key_switch_ab051ee75017f2de075ed0aaf94f3210c}{to\+Key\+ID}}
\item 
long \mbox{\hyperlink{classhelib_1_1_key_switch_a8651e62e5105034f136a63c7d9d823f6}{ptxt\+Space}}
\item 
std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \mbox{\hyperlink{classhelib_1_1_key_switch_a1467771b15e14a274ce6dcb20399af13}{b}}
\item 
N\+T\+L\+::\+ZZ \mbox{\hyperlink{classhelib_1_1_key_switch_af4d2dcf11d6e9edfa769cdaa764f5a5f}{prg\+Seed}}
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{classhelib_1_1_key_switch_a635d31b573c39ab850ea8a5a9155d6ce}{noise\+Bound}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Key-\/switching matrices. 

There are basically two approaches for how to do key-\/switching\+: either decompose the mod-\/q ciphertext into bits (or digits) to make it low-\/norm, or perform the key-\/switching operation mod Q$>$$>$q. The tradeoff is that when decomposing the (coefficients of the) ciphertext into t digits, we need to increase the size of the key-\/switching matrix by a factor of t (and the running time similarly grows). On the other hand if we do not decompose at all then we need to work modulo Q$>$q$^\wedge$2, which means that the bitsize of our largest modulus q0 more than doubles (and hence also the parameter m more than doubles). In general if we decompose into digits of size B then we need to work with Q$>$q$\ast$B.)

The part of the spectrum where we expect to find the sweet spot is when we decompose the ciphertext into digits of size B=q0$^\wedge$\{1/t\} for some small constant t (maybe t=2,3 or so). This means that our largest modulus has to be Q$>$q0$^\wedge$\{1+1/t\}, which increases also the parameter m by a factor (1+1/t). It also means that for key-\/switching in the top levels we would break the ciphertext to t digits, hence the key-\/switching matrix will have t columns.

A key-\/switch matrix W\mbox{[}s\textquotesingle{}-\/$>$s\mbox{]} converts a ciphertext-\/part with respect to secret-\/key polynomial s\textquotesingle{} into a canonical ciphertext (i.\+e. a two-\/part ciphertext with respect to (1,s)). The matrix W is a 2-\/by-\/t matrix of \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} objects. The bottom row are just (pseudo)random elements. Then for column j, if the bottom element is aj then the top element is set as bj = P$\ast$\+Bj$\ast$s\textquotesingle{} + p$\ast$ej -\/ s $\ast$ aj mod P$\ast$q0, where p is the plaintext space (i.\+e. 2 or 2$^\wedge$r, or 1 for \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}) and Bj is the product of the digits-\/sizes corresponding to columns 0...i-\/1. (For example if we have digit sizes 3,5,7 then B0=1, B1=3, B2=15 and B3=105.) Also, q0 is the product of all the \char`\"{}ciphertext primes\char`\"{} and P is roughly the product of all the special primes. (Actually, for \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}, if Q is the product of all the special primes then P=Q$\ast$(Q$^\wedge$\{-\/1\} mod p).)

In this implementation we save some space, by keeping only a P\+RG seed for generating the pseudo-\/random elements, rather than the elements themselves.

To convert a ciphertext part R, we break R into digits R = sum\+\_\+j Bj Rj, then set (q0,q1)$^\wedge$T = sum\+\_\+j Rj $\ast$ column-\/j. Note that we have $<$(1,s),(q0,q1)$>$ = sum\+\_\+j Rj$\ast$(s$\ast$aj -\/ s$\ast$aj + p$\ast$ej +P$\ast$\+Bj$\ast$s\textquotesingle{}) = P $\ast$ sum\+\_\+j Bj$\ast$\+Rj $\ast$ s\textquotesingle{} + p sum\+\_\+j Rj$\ast$ej = P $\ast$ R $\ast$ s\textquotesingle{} + p$\ast$a-\/small-\/element (mod P$\ast$q0) where the last element is small since the ej\textquotesingle{}s are small and $\vert$\+Rj$\vert$$<$B. Note that if the ciphertext is encrypted relative to plaintext space p\textquotesingle{} and then key-\/switched with matrices W relative to plaintext space p, then we get a mew ciphertext with noise p\textquotesingle{}$\ast$small+p$\ast$small, so it is valid relative to plaintext space G\+CD(p\textquotesingle{},p).

The matrix W is defined modulo Q$>$t$\ast$\+B$\ast$sigma$\ast$q0 (with sigma a bound on the size of the ej\textquotesingle{}s), and Q is the product of all the small primes in our moduli chain. However, if p is much smaller than B then is is enough to use W mod Qi with Qi a smaller modulus, Q$>$p$\ast$sigma$\ast$q0. Also note that if p$<$Br then we will be using only first r columns of the matrix W. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classhelib_1_1_key_switch_a74d6cc93536febfff257b19fc63dc060}\label{classhelib_1_1_key_switch_a74d6cc93536febfff257b19fc63dc060}} 
\index{helib::KeySwitch@{helib::KeySwitch}!KeySwitch@{KeySwitch}}
\index{KeySwitch@{KeySwitch}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{KeySwitch()}{KeySwitch()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily helib\+::\+Key\+Switch\+::\+Key\+Switch (\begin{DoxyParamCaption}\item[{long}]{s\+Pow = {\ttfamily 0},  }\item[{long}]{x\+Pow = {\ttfamily 0},  }\item[{long}]{from\+ID = {\ttfamily 0},  }\item[{long}]{to\+ID = {\ttfamily 0},  }\item[{long}]{p = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

\mbox{\Hypertarget{classhelib_1_1_key_switch_a3cd8c681d701db5837260703b7b73b00}\label{classhelib_1_1_key_switch_a3cd8c681d701db5837260703b7b73b00}} 
\index{helib::KeySwitch@{helib::KeySwitch}!KeySwitch@{KeySwitch}}
\index{KeySwitch@{KeySwitch}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{KeySwitch()}{KeySwitch()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily helib\+::\+Key\+Switch\+::\+Key\+Switch (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} \&}]{\+\_\+from\+Key,  }\item[{long}]{from\+ID = {\ttfamily 0},  }\item[{long}]{to\+ID = {\ttfamily 0},  }\item[{long}]{p = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classhelib_1_1_key_switch_afc9320fe88ca2cda85f04c362de85442}\label{classhelib_1_1_key_switch_afc9320fe88ca2cda85f04c362de85442}} 
\index{helib::KeySwitch@{helib::KeySwitch}!dummy@{dummy}}
\index{dummy@{dummy}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{dummy()}{dummy()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \& helib\+::\+Key\+Switch\+::dummy (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



returns a dummy static matrix with to\+Key\+Id == -\/1 

\mbox{\Hypertarget{classhelib_1_1_key_switch_a0d5b6037b48b01c67bf29b0ae19f16e0}\label{classhelib_1_1_key_switch_a0d5b6037b48b01c67bf29b0ae19f16e0}} 
\index{helib::KeySwitch@{helib::KeySwitch}!isDummy@{isDummy}}
\index{isDummy@{isDummy}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{isDummy()}{isDummy()}}
{\footnotesize\ttfamily bool helib\+::\+Key\+Switch\+::is\+Dummy (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

\mbox{\Hypertarget{classhelib_1_1_key_switch_af5e067d1594615c8c3c44acb941e484f}\label{classhelib_1_1_key_switch_af5e067d1594615c8c3c44acb941e484f}} 
\index{helib::KeySwitch@{helib::KeySwitch}!NumCols@{NumCols}}
\index{NumCols@{NumCols}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{NumCols()}{NumCols()}}
{\footnotesize\ttfamily unsigned long helib\+::\+Key\+Switch\+::\+Num\+Cols (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

\mbox{\Hypertarget{classhelib_1_1_key_switch_aa654d241726845e7a4b3c89ecf701596}\label{classhelib_1_1_key_switch_aa654d241726845e7a4b3c89ecf701596}} 
\index{helib::KeySwitch@{helib::KeySwitch}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily bool helib\+::\+Key\+Switch\+::operator!= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \&}]{other }\end{DoxyParamCaption}) const}

\mbox{\Hypertarget{classhelib_1_1_key_switch_a70670acc9c59290c0e668455108aecec}\label{classhelib_1_1_key_switch_a70670acc9c59290c0e668455108aecec}} 
\index{helib::KeySwitch@{helib::KeySwitch}!operator==@{operator==}}
\index{operator==@{operator==}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily bool helib\+::\+Key\+Switch\+::operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \&}]{other }\end{DoxyParamCaption}) const}

\mbox{\Hypertarget{classhelib_1_1_key_switch_a6dd127dd7552981ab1a6b74d2f0a141b}\label{classhelib_1_1_key_switch_a6dd127dd7552981ab1a6b74d2f0a141b}} 
\index{helib::KeySwitch@{helib::KeySwitch}!read@{read}}
\index{read@{read}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{read()}{read()}}
{\footnotesize\ttfamily void helib\+::\+Key\+Switch\+::read (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}



Raw IO. 

\mbox{\Hypertarget{classhelib_1_1_key_switch_a9d0189576a8418468aa50e6f7e5e2ca8}\label{classhelib_1_1_key_switch_a9d0189576a8418468aa50e6f7e5e2ca8}} 
\index{helib::KeySwitch@{helib::KeySwitch}!readMatrix@{readMatrix}}
\index{readMatrix@{readMatrix}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{readMatrix()}{readMatrix()}}
{\footnotesize\ttfamily void helib\+::\+Key\+Switch\+::read\+Matrix (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}



Read a key-\/switching matrix from input. 

\mbox{\Hypertarget{classhelib_1_1_key_switch_a84794d2ce7f58d204b2d561b443dc9ba}\label{classhelib_1_1_key_switch_a84794d2ce7f58d204b2d561b443dc9ba}} 
\index{helib::KeySwitch@{helib::KeySwitch}!verify@{verify}}
\index{verify@{verify}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{verify()}{verify()}}
{\footnotesize\ttfamily void helib\+::\+Key\+Switch\+::verify (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}



A debugging method. 

\mbox{\Hypertarget{classhelib_1_1_key_switch_a7d5aacb77d9bf361522e29811e8994ca}\label{classhelib_1_1_key_switch_a7d5aacb77d9bf361522e29811e8994ca}} 
\index{helib::KeySwitch@{helib::KeySwitch}!write@{write}}
\index{write@{write}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{write()}{write()}}
{\footnotesize\ttfamily void helib\+::\+Key\+Switch\+::write (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str }\end{DoxyParamCaption}) const}



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classhelib_1_1_key_switch_a1467771b15e14a274ce6dcb20399af13}\label{classhelib_1_1_key_switch_a1467771b15e14a274ce6dcb20399af13}} 
\index{helib::KeySwitch@{helib::KeySwitch}!b@{b}}
\index{b@{b}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{b}{b}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}$>$ helib\+::\+Key\+Switch\+::b}

\mbox{\Hypertarget{classhelib_1_1_key_switch_a5b8267d055a0224c42ef247ddc7057f9}\label{classhelib_1_1_key_switch_a5b8267d055a0224c42ef247ddc7057f9}} 
\index{helib::KeySwitch@{helib::KeySwitch}!fromKey@{fromKey}}
\index{fromKey@{fromKey}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{fromKey}{fromKey}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} helib\+::\+Key\+Switch\+::from\+Key}

\mbox{\Hypertarget{classhelib_1_1_key_switch_a635d31b573c39ab850ea8a5a9155d6ce}\label{classhelib_1_1_key_switch_a635d31b573c39ab850ea8a5a9155d6ce}} 
\index{helib::KeySwitch@{helib::KeySwitch}!noiseBound@{noiseBound}}
\index{noiseBound@{noiseBound}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{noiseBound}{noiseBound}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::\+Key\+Switch\+::noise\+Bound}

\mbox{\Hypertarget{classhelib_1_1_key_switch_af4d2dcf11d6e9edfa769cdaa764f5a5f}\label{classhelib_1_1_key_switch_af4d2dcf11d6e9edfa769cdaa764f5a5f}} 
\index{helib::KeySwitch@{helib::KeySwitch}!prgSeed@{prgSeed}}
\index{prgSeed@{prgSeed}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{prgSeed}{prgSeed}}
{\footnotesize\ttfamily N\+T\+L\+::\+ZZ helib\+::\+Key\+Switch\+::prg\+Seed}

\mbox{\Hypertarget{classhelib_1_1_key_switch_a8651e62e5105034f136a63c7d9d823f6}\label{classhelib_1_1_key_switch_a8651e62e5105034f136a63c7d9d823f6}} 
\index{helib::KeySwitch@{helib::KeySwitch}!ptxtSpace@{ptxtSpace}}
\index{ptxtSpace@{ptxtSpace}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{ptxtSpace}{ptxtSpace}}
{\footnotesize\ttfamily long helib\+::\+Key\+Switch\+::ptxt\+Space}

\mbox{\Hypertarget{classhelib_1_1_key_switch_ab051ee75017f2de075ed0aaf94f3210c}\label{classhelib_1_1_key_switch_ab051ee75017f2de075ed0aaf94f3210c}} 
\index{helib::KeySwitch@{helib::KeySwitch}!toKeyID@{toKeyID}}
\index{toKeyID@{toKeyID}!helib::KeySwitch@{helib::KeySwitch}}
\doxysubsubsection{\texorpdfstring{toKeyID}{toKeyID}}
{\footnotesize\ttfamily long helib\+::\+Key\+Switch\+::to\+Key\+ID}

