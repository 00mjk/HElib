\hypertarget{namespacehelib}{}\doxysection{helib Namespace Reference}
\label{namespacehelib}\index{helib@{helib}}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespacehelib_1_1_f_h_eglobals}{F\+H\+Eglobals}}
\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classhelib_1_1add__pa__impl}{add\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_add_d_a_g}{Add\+D\+AG}}
\begin{DoxyCompactList}\small\item\em A class representing the logic of the order of bit products when adding two integers. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_and}{And}}
\begin{DoxyCompactList}\small\item\em An object representing the logical A\+ND expression which inherits from {\ttfamily \mbox{\hyperlink{structhelib_1_1_expr}{Expr}}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1apply_perm__pa__impl}{apply\+Perm\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_arg_map}{Arg\+Map}}
\begin{DoxyCompactList}\small\item\em Basic class for arg parsing. Example use\+: \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_basic_automorph_precon}{Basic\+Automorph\+Precon}}
\begin{DoxyCompactList}\small\item\em Pre-\/computation to speed many automorphism on the same ciphertext. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}
\begin{DoxyCompactList}\small\item\em Type for \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} scheme, to be used as template parameter. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_bipartitle_graph}{Bipartitle\+Graph}}
\begin{DoxyCompactList}\small\item\em A bipartite flow graph. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d}{Block\+Mat\+Mul1D}}
\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d__derived}{Block\+Mat\+Mul1\+D\+\_\+derived}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_block_mat_mul1_d__derived__impl}{Block\+Mat\+Mul1\+D\+\_\+derived\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d__partial}{Block\+Mat\+Mul1\+D\+\_\+partial}}
\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d_exec}{Block\+Mat\+Mul1\+D\+Exec}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_block_mat_mul1_d_exec__construct}{Block\+Mat\+Mul1\+D\+Exec\+\_\+construct}}
\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul_full}{Block\+Mat\+Mul\+Full}}
\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul_full__derived}{Block\+Mat\+Mul\+Full\+\_\+derived}}
\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul_full_exec}{Block\+Mat\+Mul\+Full\+Exec}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_block_mat_mul_full_exec__construct}{Block\+Mat\+Mul\+Full\+Exec\+\_\+construct}}
\item 
class \mbox{\hyperlink{classhelib_1_1_block_mat_mul_full_helper}{Block\+Mat\+Mul\+Full\+Helper}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}
\begin{DoxyCompactList}\small\item\em Type for \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} scheme, to be used as template parameter. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_cmodulus}{Cmodulus}}
\begin{DoxyCompactList}\small\item\em Provides F\+FT and i\+F\+FT routines modulo a single-\/precision prime. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_col_number}{Col\+Number}}
\begin{DoxyCompactList}\small\item\em An object representing a column of a database as an expression which inherits from {\ttfamily \mbox{\hyperlink{structhelib_1_1_expr}{Expr}}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}}
\begin{DoxyCompactList}\small\item\em Permuting a single dimension (column) of a hypercube. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_const_cube_slice}{Const\+Cube\+Slice}}
\begin{DoxyCompactList}\small\item\em A constant lower-\/dimension slice of a hypercube. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_const_multiplier___double_c_r_t}{Const\+Multiplier\+\_\+\+Double\+C\+RT}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_const_multiplier___double_c_r_t___c_k_k_s}{Const\+Multiplier\+\_\+\+Double\+C\+R\+T\+\_\+\+C\+K\+KS}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_const_multiplier__zz_x}{Const\+Multiplier\+\_\+zzX}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_const_multiplier__zz_x___c_k_k_s}{Const\+Multiplier\+\_\+zz\+X\+\_\+\+C\+K\+KS}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_const_multiplier_cache}{Const\+Multiplier\+Cache}}
\item 
class \mbox{\hyperlink{classhelib_1_1_context}{Context}}
\begin{DoxyCompactList}\small\item\em Maintaining the parameters. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}
\begin{DoxyCompactList}\small\item\em A \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} object holds a single ciphertext. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_ctxt_part}{Ctxt\+Part}}
\begin{DoxyCompactList}\small\item\em One entry in a ciphertext std\+::vector. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_cube_signature}{Cube\+Signature}}
\begin{DoxyCompactList}\small\item\em Holds a vector of dimensions for a hypercube and some additional data. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}
\begin{DoxyCompactList}\small\item\em A lower-\/dimension slice of a hypercube. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_d_a_gnode}{D\+A\+Gnode}}
\begin{DoxyCompactList}\small\item\em A node in an addition-\/\+D\+AG structure. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_database}{Database}}
\begin{DoxyCompactList}\small\item\em An object representing a database which is a {\ttfamily H\+Elib\+::\+Matrix$<$T\+XT$>$}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1decode__pa__impl}{decode\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1deep__clone}{deep\+\_\+clone}}
\begin{DoxyCompactList}\small\item\em Deep copy\+: initialize with clone. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}
\begin{DoxyCompactList}\small\item\em Implementing polynomials (elements in the ring R\+\_\+Q) in double-\/\+C\+RT form. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_double_c_r_t_helper}{Double\+C\+R\+T\+Helper}}
\begin{DoxyCompactList}\small\item\em A helper class to enforce consistency within an \mbox{\hyperlink{classhelib_1_1_double_c_r_t_helper}{Double\+C\+R\+T\+Helper}} object. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_dynamic_ctxt_powers}{Dynamic\+Ctxt\+Powers}}
\begin{DoxyCompactList}\small\item\em Store powers of X, compute them dynamically as needed. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1encode__pa__impl}{encode\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}}
\begin{DoxyCompactList}\small\item\em A simple wrapper for a smart pointer to an \mbox{\hyperlink{classhelib_1_1_encrypted_array_base}{Encrypted\+Array\+Base}}. This is the interface that higher-\/level code should use. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_encrypted_array_base}{Encrypted\+Array\+Base}}
\begin{DoxyCompactList}\small\item\em virtual class for data-\/movement operations on arrays of slots \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_encrypted_array_cx}{Encrypted\+Array\+Cx}}
\begin{DoxyCompactList}\small\item\em A different derived class to be used for the approximate-\/numbers scheme. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_encrypted_array_derived}{Encrypted\+Array\+Derived}}
\begin{DoxyCompactList}\small\item\em Derived concrete implementation of \mbox{\hyperlink{classhelib_1_1_encrypted_array_base}{Encrypted\+Array\+Base}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1equals__pa__impl}{equals\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_eval_map}{Eval\+Map}}
\begin{DoxyCompactList}\small\item\em Class that provides the functionality for the linear transforms used in boostrapping. The constructor is invoked with three arguments\+: \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_exception}{Exception}}
\begin{DoxyCompactList}\small\item\em Base class that other H\+Elib exception classes inherit from. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_explicit_replicator}{Explicit\+Replicator}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{classhelib_1_1_replicate_handler}{Replicate\+Handler}} that explicitly returns all the replicated ciphertexts in one big vector. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_expr}{Expr}}
\begin{DoxyCompactList}\small\item\em Base structure for logical expressions. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1fhe__stats__record}{fhe\+\_\+stats\+\_\+record}}
\item 
class \mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}}
\begin{DoxyCompactList}\small\item\em A simple class to accumulate time. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_flow_edge}{Flow\+Edge}}
\begin{DoxyCompactList}\small\item\em An edge in a flow graph. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1frobenius_automorph__pa__impl}{frobenius\+Automorph\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_full_binary_tree}{Full\+Binary\+Tree}}
\begin{DoxyCompactList}\small\item\em A simple implementation of full binary trees (each non-\/leaf has 2 children) \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_gen_descriptor}{Gen\+Descriptor}}
\begin{DoxyCompactList}\small\item\em A minimal description of a generator for the purpose of building tree. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1general__range}{general\+\_\+range}}
\item 
class \mbox{\hyperlink{classhelib_1_1_general_automorph_precon}{General\+Automorph\+Precon}}
\item 
class \mbox{\hyperlink{classhelib_1_1_general_automorph_precon___b_s_g_s}{General\+Automorph\+Precon\+\_\+\+B\+S\+GS}}
\item 
class \mbox{\hyperlink{classhelib_1_1_general_automorph_precon___f_u_l_l}{General\+Automorph\+Precon\+\_\+\+F\+U\+LL}}
\item 
class \mbox{\hyperlink{classhelib_1_1_general_automorph_precon___u_n_k_n_o_w_n}{General\+Automorph\+Precon\+\_\+\+U\+N\+K\+N\+O\+WN}}
\item 
class \mbox{\hyperlink{classhelib_1_1_general_benes_network}{General\+Benes\+Network}}
\begin{DoxyCompactList}\small\item\em Implementation of generalized Benes Permutation Network. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_generator_trees}{Generator\+Trees}}
\begin{DoxyCompactList}\small\item\em A std\+::vector of generator trees, one per generator in Zm$\ast$/(p) \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1half___f_f_t}{half\+\_\+\+F\+FT}}
\item 
class \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}
\begin{DoxyCompactList}\small\item\em A multi-\/dimensional cube. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}
\begin{DoxyCompactList}\small\item\em Index\+Map$<$\+T$>$ implements a generic map indexed by a dynamic index set. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_index_map_init}{Index\+Map\+Init}}
\begin{DoxyCompactList}\small\item\em Initializing elements in an \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}}
\begin{DoxyCompactList}\small\item\em A dynamic set of non-\/negative integers. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_invalid_argument}{Invalid\+Argument}}
\begin{DoxyCompactList}\small\item\em Inherits from \mbox{\hyperlink{classhelib_1_1_exception}{Exception}} and std\+::invalid\+\_\+argument. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_i_o_error}{I\+O\+Error}}
\begin{DoxyCompactList}\small\item\em Inherits from \mbox{\hyperlink{classhelib_1_1_exception}{Exception}} and std\+::runtime\+\_\+error. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}}
\begin{DoxyCompactList}\small\item\em Key-\/switching matrices. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_labeled_edge}{Labeled\+Edge}}
\begin{DoxyCompactList}\small\item\em A generic directed edge in a graph with some labels. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_labeled_vertex}{Labeled\+Vertex}}
\begin{DoxyCompactList}\small\item\em A generic node in a graph with some labels. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_logger}{Logger}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classhelib_1_1_logger}{Logger}} class that handles warning printouts. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_logic_error}{Logic\+Error}}
\begin{DoxyCompactList}\small\item\em Inherits from \mbox{\hyperlink{classhelib_1_1_exception}{Exception}} and std\+::logic\+\_\+error. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_mapping_data}{Mapping\+Data}}
\begin{DoxyCompactList}\small\item\em Auxiliary structure to support encoding/decoding slots. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul1_d}{Mat\+Mul1D}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul1_d___c_k_k_s}{Mat\+Mul1\+D\+\_\+\+C\+K\+KS}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul1_d__derived}{Mat\+Mul1\+D\+\_\+derived}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_mat_mul1_d__derived__impl}{Mat\+Mul1\+D\+\_\+derived\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul1_d__partial}{Mat\+Mul1\+D\+\_\+partial}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul1_d_exec}{Mat\+Mul1\+D\+Exec}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_mat_mul1_d_exec__construct}{Mat\+Mul1\+D\+Exec\+\_\+construct}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul_exec_base}{Mat\+Mul\+Exec\+Base}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul_full}{Mat\+Mul\+Full}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul_full__derived}{Mat\+Mul\+Full\+\_\+derived}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul_full_exec}{Mat\+Mul\+Full\+Exec}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_mat_mul_full_exec__construct}{Mat\+Mul\+Full\+Exec\+\_\+construct}}
\item 
class \mbox{\hyperlink{classhelib_1_1_mat_mul_full_helper}{Mat\+Mul\+Full\+Helper}}
\item 
class \mbox{\hyperlink{classhelib_1_1_matrix_view}{Matrix\+View}}
\item 
class \mbox{\hyperlink{classhelib_1_1_moduli_sizes}{Moduli\+Sizes}}
\begin{DoxyCompactList}\small\item\em A helper class to map required modulo-\/sizes to prime\+Sets. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1mul___block_mat_mul1_d__impl}{mul\+\_\+\+Block\+Mat\+Mul1\+D\+\_\+impl}}
\item 
struct \mbox{\hyperlink{structhelib_1_1mul___block_mat_mul_full__impl}{mul\+\_\+\+Block\+Mat\+Mul\+Full\+\_\+impl}}
\item 
struct \mbox{\hyperlink{structhelib_1_1mul___mat_mul1_d__impl}{mul\+\_\+\+Mat\+Mul1\+D\+\_\+impl}}
\item 
struct \mbox{\hyperlink{structhelib_1_1mul___mat_mul_full__impl}{mul\+\_\+\+Mat\+Mul\+Full\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1mul__pa__impl}{mul\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1negate__pa__impl}{negate\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_or}{Or}}
\begin{DoxyCompactList}\small\item\em An object representing the logical OR expression which inherits from {\ttfamily \mbox{\hyperlink{structhelib_1_1_expr}{Expr}}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_out_of_range_error}{Out\+Of\+Range\+Error}}
\begin{DoxyCompactList}\small\item\em Inherits from \mbox{\hyperlink{classhelib_1_1_exception}{Exception}} and std\+::out\+\_\+of\+\_\+range. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}}
\begin{DoxyCompactList}\small\item\em The structure of (Z/mZ)$\ast$ /(p) \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_p_algebra_mod}{P\+Algebra\+Mod}}
\begin{DoxyCompactList}\small\item\em The structure of Z\mbox{[}X\mbox{]}/(Phi\+\_\+m(\+X), p) \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_p_algebra_mod_base}{P\+Algebra\+Mod\+Base}}
\begin{DoxyCompactList}\small\item\em Virtual base class for \mbox{\hyperlink{classhelib_1_1_p_algebra_mod}{P\+Algebra\+Mod}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_p_algebra_mod_cx}{P\+Algebra\+Mod\+Cx}}
\item 
class \mbox{\hyperlink{classhelib_1_1_p_algebra_mod_derived}{P\+Algebra\+Mod\+Derived}}
\begin{DoxyCompactList}\small\item\em A concrete instantiation of the virtual class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_perm_net_layer}{Perm\+Net\+Layer}}
\begin{DoxyCompactList}\small\item\em The information needed to apply one layer of a permutation network. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_perm_network}{Perm\+Network}}
\begin{DoxyCompactList}\small\item\em A full permutation network. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_p_g_f_f_t}{P\+G\+F\+FT}}
\item 
class \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}}
\item 
class \mbox{\hyperlink{classhelib_1_1_plaintext_array_base}{Plaintext\+Array\+Base}}
\item 
class \mbox{\hyperlink{classhelib_1_1_plaintext_array_derived}{Plaintext\+Array\+Derived}}
\item 
class \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}
\begin{DoxyCompactList}\small\item\em An object that contains an {\ttfamily N\+T\+L\+::\+Z\+ZX} polynomial along with a coefficient modulus {\ttfamily p2r} and a polynomial modulus {\ttfamily G}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_poly_mod_ring}{Poly\+Mod\+Ring}}
\begin{DoxyCompactList}\small\item\em Lightweight type for describing the structure of a single slot of the plaintext space. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_powerful_conversion}{Powerful\+Conversion}}
\begin{DoxyCompactList}\small\item\em Conversion between powerful representation in R\+\_\+m/(q) and zz\+\_\+pX. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_powerful_d_c_r_t}{Powerful\+D\+C\+RT}}
\begin{DoxyCompactList}\small\item\em Conversion between powerful representation, \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}, and Z\+ZX. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_powerful_translation_indexes}{Powerful\+Translation\+Indexes}}
\begin{DoxyCompactList}\small\item\em Holds index tables for translation between powerful and zz\+\_\+pX. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_prime_generator}{Prime\+Generator}}
\item 
class \mbox{\hyperlink{classhelib_1_1print__pa__impl}{print\+\_\+pa\+\_\+impl}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}
\begin{DoxyCompactList}\small\item\em An abstract class for an array of Ptr\+Vectors. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_matrix___pt_ptr_vector}{Ptr\+Matrix\+\_\+\+Pt\+Ptr\+Vector}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}} using vector$<$ Ptr\+Vector$<$\+T$>$$\ast$ $>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_matrix__pt_vec}{Ptr\+Matrix\+\_\+pt\+Vec}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}} using Vec$<$ Vec$<$\+T$>$$\ast$ $>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_matrix__ptvector}{Ptr\+Matrix\+\_\+ptvector}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}} using vector$<$ vector$<$\+T$>$$\ast$ $>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_matrix___vec}{Ptr\+Matrix\+\_\+\+Vec}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}} using Vec$<$ Vec$<$\+T$>$ $>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_matrix__vector}{Ptr\+Matrix\+\_\+vector}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}} using vector$<$ vector$<$\+T$>$ $>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}
\begin{DoxyCompactList}\small\item\em Abstract class for an array of objects. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_vector___singleton}{Ptr\+Vector\+\_\+\+Singleton}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}} from a single T object. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_vector__slice}{Ptr\+Vector\+\_\+slice}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}} as a slice of another \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_vector___vec_pt}{Ptr\+Vector\+\_\+\+Vec\+Pt}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}} using Vec$<$\+T$\ast$$>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_vector___vec_t}{Ptr\+Vector\+\_\+\+VecT}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}} using Vec$<$\+T$>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_vector__vector_pt}{Ptr\+Vector\+\_\+vector\+Pt}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}} using vector$<$\+T$\ast$$>$ \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_ptr_vector__vector_t}{Ptr\+Vector\+\_\+vectorT}}
\begin{DoxyCompactList}\small\item\em An implementation of \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}} using vector$<$\+T$>$ \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}
\begin{DoxyCompactList}\small\item\em An object that mimics the functionality of the {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}} object, and acts as a convenient entry point for inputting/encoding data which is to be encrypted. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}}
\begin{DoxyCompactList}\small\item\em The public key. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhelib_1_1_pub_key_hack}{Pub\+Key\+Hack}}
\item 
struct \mbox{\hyperlink{structhelib_1_1quarter___f_f_t}{quarter\+\_\+\+F\+FT}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_query__t}{Query\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Structure containing all information required for an HE query. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_query_builder}{Query\+Builder}}
\begin{DoxyCompactList}\small\item\em An object used to construct a {\ttfamily \mbox{\hyperlink{structhelib_1_1_query__t}{Query\+\_\+t}}} object from a logical expression. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1random__pa__impl}{random\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_random_block_matrix}{Random\+Block\+Matrix}}
\item 
class \mbox{\hyperlink{classhelib_1_1_random_full_block_matrix}{Random\+Full\+Block\+Matrix}}
\item 
class \mbox{\hyperlink{classhelib_1_1_random_full_matrix}{Random\+Full\+Matrix}}
\item 
class \mbox{\hyperlink{classhelib_1_1_random_matrix}{Random\+Matrix}}
\item 
class \mbox{\hyperlink{classhelib_1_1_random_multi_block_matrix}{Random\+Multi\+Block\+Matrix}}
\item 
class \mbox{\hyperlink{classhelib_1_1_random_multi_matrix}{Random\+Multi\+Matrix}}
\item 
class \mbox{\hyperlink{classhelib_1_1_random_state}{Random\+State}}
\begin{DoxyCompactList}\small\item\em Facility for \char`\"{}restoring\char`\"{} the N\+TL P\+RG state. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_recrypt_data}{Recrypt\+Data}}
\begin{DoxyCompactList}\small\item\em A structure to hold recryption-\/related data inside the \mbox{\hyperlink{classhelib_1_1_context}{Context}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1replicate__pa__impl}{replicate\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_replicate_handler}{Replicate\+Handler}}
\begin{DoxyCompactList}\small\item\em An abstract class to handle call-\/backs to get the output of replicate. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1rotate__pa__impl}{rotate\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_runtime_error}{Runtime\+Error}}
\begin{DoxyCompactList}\small\item\em Inherits from \mbox{\hyperlink{classhelib_1_1_exception}{Exception}} and std\+::runtime\+\_\+error. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_scratch_cell}{Scratch\+Cell}}
\begin{DoxyCompactList}\small\item\em A class to help manage the allocation of temporary \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}}
\begin{DoxyCompactList}\small\item\em The secret key. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1shallow__clone}{shallow\+\_\+clone}}
\begin{DoxyCompactList}\small\item\em Shallow copy\+: initialize with copy constructor. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1shift__pa__impl}{shift\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}}
\begin{DoxyCompactList}\small\item\em A handle, describing the secret-\/key element that \char`\"{}matches\char`\"{} a part, of the form s$^\wedge$r(X$^\wedge$t). \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1sub__pa__impl}{sub\+\_\+pa\+\_\+impl}}
\item 
class \mbox{\hyperlink{classhelib_1_1_sub_dimension}{Sub\+Dimension}}
\begin{DoxyCompactList}\small\item\em A node in a tree relative to some generator. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_sum_register}{Sum\+Register}}
\begin{DoxyCompactList}\small\item\em Class to do a binary tree summation as results appear to keep memory usage to a minimum. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}
\item 
struct \mbox{\hyperlink{structhelib_1_1_tensor_slice}{Tensor\+Slice}}
\item 
class \mbox{\hyperlink{classhelib_1_1_thin_eval_map}{Thin\+Eval\+Map}}
\begin{DoxyCompactList}\small\item\em Class that provides the functionality for the linear transforms used in \char`\"{}thin\char`\"{} boostrapping, where slots are assumed to contain constants. The interface is exactly the same as for \mbox{\hyperlink{classhelib_1_1_eval_map}{Eval\+Map}}, except that the constructor does not have a normal\+\_\+basis parameter. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_thin_recrypt_data}{Thin\+Recrypt\+Data}}
\begin{DoxyCompactList}\small\item\em Same as above, but for \char`\"{}thin\char`\"{} bootstrapping, where the slots are assumed to contain constants. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_tree_node}{Tree\+Node}}
\begin{DoxyCompactList}\small\item\em A node in a full binary tree. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1zz__p_x_modulus1}{zz\+\_\+p\+X\+Modulus1}}
\begin{DoxyCompactList}\small\item\em Auxiliary classes to facilitate faster reduction mod Phi\+\_\+m(\+X) when the input has degree less than m. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhelib_1_1_z_z__p_x_modulus1}{Z\+Z\+\_\+p\+X\+Modulus1}}
\begin{DoxyCompactList}\small\item\em placeholder for p\+X\+Modulus ...no optimizations \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector___vec_t}{Ptr\+Vector\+\_\+\+VecT}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_a68bdc610c69d2325ae28b53783225701}{Ct\+Ptrs\+\_\+\+Vec\+Ct}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector__vector_t}{Ptr\+Vector\+\_\+vectorT}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_a70957f911bb89f6b84e7838ac4363d07}{Ct\+Ptrs\+\_\+vector\+Ct}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector___vec_pt}{Ptr\+Vector\+\_\+\+Vec\+Pt}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_adf611a971d91604083e4a4f4d2745a46}{Ct\+Ptrs\+\_\+\+Vec\+Pt}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector__vector_pt}{Ptr\+Vector\+\_\+vector\+Pt}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_ac9e2fec60563f1741cf5b38e9c975781}{Ct\+Ptrs\+\_\+vector\+Pt}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector__slice}{Ptr\+Vector\+\_\+slice}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_afddae64ffeb6698a0b2a5214ab66273b}{Ct\+Ptrs\+\_\+slice}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{Ct\+Ptr\+Mat}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix___vec}{Ptr\+Matrix\+\_\+\+Vec}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_a536b3dcc07d9bee58c6f52f62118cd53}{Ct\+Ptr\+Mat\+\_\+\+Vec\+Ct}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix__vector}{Ptr\+Matrix\+\_\+vector}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_a2f951b4c929a807f0a369b1aed560c6a}{Ct\+Ptr\+Mat\+\_\+vector\+Ct}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix__pt_vec}{Ptr\+Matrix\+\_\+pt\+Vec}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_a3985a932f1b51600445c078fc5531d19}{Ct\+Ptr\+Mat\+\_\+pt\+Vec\+Ct}}
\item 
typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix__ptvector}{Ptr\+Matrix\+\_\+ptvector}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_a2417782a109df301d765fbcdfe6ac1b7}{Ct\+Ptr\+Mat\+\_\+ptvector\+Ct}}
\item 
typedef std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \mbox{\hyperlink{namespacehelib_a428c028bc71d7be0bdaa0118f286ee2e}{D\+C\+R\+Tptr}}
\item 
typedef std\+::shared\+\_\+ptr$<$ N\+T\+L\+::\+Z\+ZX $>$ \mbox{\hyperlink{namespacehelib_a3652f33aab9e225a4c136eb14a50bc53}{Z\+Z\+Xptr}}
\item 
typedef std\+::complex$<$ double $>$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}}
\item 
typedef std\+::unordered\+\_\+map$<$ long, \mbox{\hyperlink{classhelib_1_1_flow_edge}{Flow\+Edge}} $>$ \mbox{\hyperlink{namespacehelib_a22330000dbd6d83a79f312ccb04405fb}{F\+Neighbor\+List}}
\item 
typedef std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a22330000dbd6d83a79f312ccb04405fb}{F\+Neighbor\+List}} $>$ \mbox{\hyperlink{namespacehelib_af547f7016fc73b7174a2018ea28ef298}{Flow\+Graph}}
\item 
typedef std\+::unordered\+\_\+multimap$<$ long, \mbox{\hyperlink{classhelib_1_1_labeled_edge}{Labeled\+Edge}} $>$ \mbox{\hyperlink{namespacehelib_ab3940838420e66ad737389ec211730b3}{L\+Neighbor\+List}}
\item 
{\footnotesize template$<$typename T $>$ }\\using \mbox{\hyperlink{namespacehelib_a67a60bb8531261415fb3615bde85ae65}{Vector}} = \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T, 1 $>$
\item 
{\footnotesize template$<$typename T $>$ }\\using \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}} = \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T, 2 $>$
\item 
typedef long \mbox{\hyperlink{namespacehelib_ad6eb9f0889a704dbc4684ce445c48456}{L\+O\+NG}}
\item 
using \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} = std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structhelib_1_1_expr}{Expr}} $>$
\begin{DoxyCompactList}\small\item\em An alias for a shared pointer to an {\ttfamily \mbox{\hyperlink{structhelib_1_1_expr}{Expr}}} object. \end{DoxyCompactList}\item 
typedef N\+T\+L\+::\+Vec$<$ long $>$ \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}}
\begin{DoxyCompactList}\small\item\em A simple permutation is just a vector with p\mbox{[}i\mbox{]}=\textbackslash{}pi\+\_\+i. \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{classhelib_1_1_full_binary_tree}{Full\+Binary\+Tree}}$<$ \mbox{\hyperlink{classhelib_1_1_sub_dimension}{Sub\+Dimension}} $>$ \mbox{\hyperlink{namespacehelib_a22b83b7df1af539c07c804d7888448ce}{One\+Generator\+Tree}}
\item 
typedef N\+T\+L\+::\+Vec$<$ long $>$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}}
\item 
typedef std\+::pair$<$ long, long $>$ \mbox{\hyperlink{namespacehelib_a007ac83d6ec59826a48a73602b739510}{Node\+Idx}}
\item 
{\footnotesize template$<$class T $>$ }\\using \mbox{\hyperlink{namespacehelib_abd32b2ba6d41fbd5943e40c4371e86a5}{aligned\+\_\+vector}} = \mbox{\hyperlink{classhelib_1_1_p_g_f_f_t_a618bb04e868985f8159d8063829f1f88}{P\+G\+F\+F\+T\+::aligned\+\_\+vector}}$<$ T $>$
\item 
typedef complex$<$ double $>$ \mbox{\hyperlink{namespacehelib_a3c94755e338132a41051da4c73f35ae4}{cmplx\+\_\+t}}
\item 
typedef long double \mbox{\hyperlink{namespacehelib_a9b643292f10bf869b8650f9392ff2d90}{ldbl}}
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7e}{P\+A\+\_\+tag}} \{ \mbox{\hyperlink{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7eab33244c736f38a4c21e6d86c6a683d58}{P\+A\+\_\+\+G\+F2\+\_\+tag}}, 
\mbox{\hyperlink{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7ea63d35380340004730e7cb505a4da38e2}{P\+A\+\_\+zz\+\_\+p\+\_\+tag}}, 
\mbox{\hyperlink{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7ea7d944116ae9eb1abb2d5fa92bb6d21ee}{P\+A\+\_\+cx\+\_\+tag}}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ }\\void \mbox{\hyperlink{namespacehelib_aca37b5e05bffd4550c995e83594d7325}{assert\+True}} (const T \&value, const std\+::string \&message)
\item 
{\footnotesize template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ }\\void \mbox{\hyperlink{namespacehelib_ad5fc5ad34739ea66baa96f988dd07beb}{assert\+False}} (T value, const std\+::string \&message)
\item 
{\footnotesize template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ }\\void \mbox{\hyperlink{namespacehelib_aec77ae5fa0fd11a0a42e07fefe49b99d}{assert\+Eq}} (const T \&a, const T \&b, const std\+::string \&message)
\item 
{\footnotesize template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ }\\void \mbox{\hyperlink{namespacehelib_acd5b530c0837ef9111dc4a361364d669}{assert\+Neq}} (const T \&a, const T \&b, const std\+::string \&message)
\item 
{\footnotesize template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ }\\void \mbox{\hyperlink{namespacehelib_aa7b1da8169ee8b9a0ab221e4c67961c5}{assert\+Not\+Null}} (const T \&p, const std\+::string \&message)
\item 
{\footnotesize template$<$typename Exception\+Ty  = \+::helib\+::\+Out\+Of\+Range\+Error, typename T  = void$>$ }\\void \mbox{\hyperlink{namespacehelib_a8e36344202aac3b245f5ba71f69a3e8b}{assert\+In\+Range}} (const T \&elem, const T \&min, const T \&max, const std\+::string \&message, bool right\+\_\+inclusive=false)
\item 
std\+::vector$<$ long $>$ \mbox{\hyperlink{namespacehelib_ab0f609e8138ce597457cbf6168d27363}{long\+To\+Bit\+Vector}} (long num, long bit\+Size)
\begin{DoxyCompactList}\small\item\em Returns a number as a vector of bits with L\+SB on the left. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a6cc8eab5085d47ef2587ff4253ec5d77}{binary\+Cond}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&cond, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&true\+Value, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&false\+Value)
\begin{DoxyCompactList}\small\item\em Implementation of {\ttfamily output = cond $\ast$ true\+Value + (1 -\/ cond) $\ast$ false\+Value}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aa08be8ce0b0f4ca1f870c56508889598}{binary\+Mask}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&binary\+Nums, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&mask)
\begin{DoxyCompactList}\small\item\em Zeroes the slots of {\ttfamily binary\+Nums} where the corresponding slot of {\ttfamily mask} is 0. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ab31dff00b9bd2df3454c7dc7a7edf16b}{concat\+Binary\+Nums}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&a, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&b)
\begin{DoxyCompactList}\small\item\em Concatenates two binary numbers into a single {\ttfamily Ct\+Ptrs} object. E.\+g. If {\ttfamily a=10111}, {\ttfamily b=00101} then {\ttfamily output = 1011100101}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a5442620f8d9b1e48c79e6d0c30eb9cec}{split\+Binary\+Nums}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&left\+Split, \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&right\+Split, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&input)
\begin{DoxyCompactList}\small\item\em Splits a single binary number into two binary numbers {\ttfamily left\+Split} and {\ttfamily right\+Split}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ac577a548455a706fa164247e3801e05a}{left\+Bitwise\+Shift}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&input, const long shamt)
\begin{DoxyCompactList}\small\item\em Left shift {\ttfamily input} by {\ttfamily shamt}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a7a59ff05d1c4f1800bb2010e451576ab}{bitwise\+Rotate}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&input, long rotamt)
\begin{DoxyCompactList}\small\item\em Rotate {\ttfamily input} by {\ttfamily rotamt}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_abaa682a93edca39cb5ce5524219c486c}{bitwise\+X\+OR}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&lhs, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&rhs)
\begin{DoxyCompactList}\small\item\em Compute a bitwise X\+OR between {\ttfamily lhs} and {\ttfamily rhs}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a2928d18450500f401e36d50a8288bf0e}{bitwise\+Or}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&lhs, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&rhs)
\begin{DoxyCompactList}\small\item\em Compute a bitwise OR between {\ttfamily lhs} and {\ttfamily rhs}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a6e4ba60fb6ef861f9601a3c22c589315}{bitwise\+And}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&lhs, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&rhs)
\begin{DoxyCompactList}\small\item\em Compute a bitwise A\+ND between {\ttfamily lhs} and {\ttfamily rhs}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a95a2868fe4324ee643869930d159f8ff}{bitwise\+And}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&input, const std\+::vector$<$ long $>$ mask)
\begin{DoxyCompactList}\small\item\em Compute a bitwise A\+ND between {\ttfamily input} and a {\ttfamily std\+::vector$<$long$>$}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a3bc4da63675257eacdf323d32ca23a83}{bitwise\+Not}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&output, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&input)
\begin{DoxyCompactList}\small\item\em Compute a bitwise N\+OT of {\ttfamily input}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a277237f0883421a2abee740db9f1b6ef}{add\+Two\+Numbers}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&sum, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&lhs, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&rhs, long size\+Limit=0, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\begin{DoxyCompactList}\small\item\em Adds two numbers in binary representation where each ciphertext of the input vector contains a bit. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aaff515cbc7e22db14c0b22c910f4cee2}{negate\+Binary}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&negation, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&input)
\begin{DoxyCompactList}\small\item\em Negates a number in binary 2\textquotesingle{}s complement representation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a3828f8e07ee92999ebe6163fb96c5fd5}{subtract\+Binary}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&difference, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&lhs, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&rhs, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\begin{DoxyCompactList}\small\item\em Subtracts {\ttfamily rhs} from {\ttfamily lhs} where {\ttfamily lhs}, {\ttfamily rhs} are in 2\textquotesingle{}s complement. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a635ecc26ac755424a9f834d4eca7d68e}{fifteen\+Or\+Less4\+Four}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&out, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&in, long size\+Limit=4)
\begin{DoxyCompactList}\small\item\em Add together up to fifteen \{0,1\} integers, producing a 4-\/bit counter. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a34e793367187e97095f9f2590eb4dc5e}{add\+Many\+Numbers}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&sum, \mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{Ct\+Ptr\+Mat}} \&numbers, long size\+Limit=0, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\begin{DoxyCompactList}\small\item\em Sum an arbitrary amount of numbers in binary representation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aa9936528f7b1f6865e4a496047caba21}{mult\+Two\+Numbers}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&product, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&lhs, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&rhs, bool rhs\+Twos\+Complement=false, long size\+Limit=0, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\begin{DoxyCompactList}\small\item\em Multiply two numbers in binary representation where each ciphertext of the input vector contains a bit. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a1285dad7ef04a62fde04003b87ee1110}{decrypt\+Binary\+Nums}} (std\+::vector$<$ long $>$ \&p\+Nums, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&e\+Nums, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, bool twos\+Complement=false, bool all\+Slots=true)
\begin{DoxyCompactList}\small\item\em Decrypt the binary numbers that are encrypted in e\+Nums. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aea4d00f74735017eb674bc25cca0d47d}{packed\+Recrypt}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&a, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&b, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding)
\begin{DoxyCompactList}\small\item\em Function for packed recryption to recrypt multiple numbers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a2eda8a61661cec76566fb5c6f475eb24}{compare\+Two\+Numbers}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&max, \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&min, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&mu, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ni, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&a, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&b, bool twos\+Complement=false, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\begin{DoxyCompactList}\small\item\em Compares two integers in binary {\ttfamily a}, {\ttfamily b}. Returns {\ttfamily max(a, b)}, {\ttfamily min(a, b)} and indicator bits {\ttfamily mu}=({\ttfamily a}$>${\ttfamily b}) and {\ttfamily ni}=({\ttfamily a}$<${\ttfamily b}) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ad7d423993b1ba7f3a05bb0184d6e5dd8}{compare\+Two\+Numbers}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&mu, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ni, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&a, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&b, bool twos\+Complement=false, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\begin{DoxyCompactList}\small\item\em Compares two integers in binary {\ttfamily a}, {\ttfamily b}. Returns only indicator bits {\ttfamily mu}=({\ttfamily a}$>${\ttfamily b}) and {\ttfamily ni}=({\ttfamily a}$<${\ttfamily b}). \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespacehelib_a3e0de63e6a004056417fc6532985ce6f}{read\+Eye\+Catcher}} (std\+::istream \&str, const char $\ast$expect)
\item 
void \mbox{\hyperlink{namespacehelib_a5d1ce128c2df30ef155f565c6435bccb}{write\+Eye\+Catcher}} (std\+::ostream \&str, const char $\ast$eye)
\item 
void \mbox{\hyperlink{namespacehelib_a3e05ac58f674ea9b53de6804949dea21}{write\+\_\+ntl\+\_\+vec\+\_\+long}} (std\+::ostream \&str, const N\+T\+L\+::vec\+\_\+long \&vl, long int\+Size=B\+I\+N\+I\+O\+\_\+64\+B\+IT)
\item 
void \mbox{\hyperlink{namespacehelib_af5ff4e18ef29f688fc071601becaafef}{read\+\_\+ntl\+\_\+vec\+\_\+long}} (std\+::istream \&str, N\+T\+L\+::vec\+\_\+long \&vl)
\item 
long \mbox{\hyperlink{namespacehelib_ab66308212a98df1821b9bf48c5713bd2}{read\+\_\+raw\+\_\+int}} (std\+::istream \&str)
\item 
int \mbox{\hyperlink{namespacehelib_a529e6135abd723e5eeb63a156224e39a}{read\+\_\+raw\+\_\+int32}} (std\+::istream \&str)
\item 
void \mbox{\hyperlink{namespacehelib_aab7bbf963ee93061e4bb1204438721b1}{write\+\_\+raw\+\_\+int}} (std\+::ostream \&str, long num)
\item 
void \mbox{\hyperlink{namespacehelib_a86af3712f18a5b1fca62330b37dbb9de}{write\+\_\+raw\+\_\+int32}} (std\+::ostream \&str, int num)
\item 
void \mbox{\hyperlink{namespacehelib_aafadc64ab3b1c319e37160cd619f3bf5}{write\+\_\+raw\+\_\+double}} (std\+::ostream \&str, const double d)
\item 
double \mbox{\hyperlink{namespacehelib_aa1c396577dc7ac07293effb9e8e20364}{read\+\_\+raw\+\_\+double}} (std\+::istream \&str)
\item 
void \mbox{\hyperlink{namespacehelib_aedb770c4cb5c37da9184d5820a000758}{write\+\_\+raw\+\_\+xdouble}} (std\+::ostream \&str, const N\+T\+L\+::xdouble xd)
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_aad981561d84bb94d22a6c5c3e1619806}{read\+\_\+raw\+\_\+xdouble}} (std\+::istream \&str)
\item 
void \mbox{\hyperlink{namespacehelib_a7f1521af0f4ab251d30fc4f96531dc1d}{write\+\_\+raw\+\_\+\+ZZ}} (std\+::ostream \&str, const N\+T\+L\+::\+ZZ \&zz)
\item 
void \mbox{\hyperlink{namespacehelib_adfd83ed995cf19419ab46fa84b2711a7}{read\+\_\+raw\+\_\+\+ZZ}} (std\+::istream \&str, N\+T\+L\+::\+ZZ \&zz)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_aaeff8e262314e10ad618189976b9ef93}{write\+\_\+raw\+\_\+vector}} (std\+::ostream \&str, const std\+::vector$<$ T $>$ \&v)
\item 
template$<$$>$ void \mbox{\hyperlink{namespacehelib_a718430742226b3f7c2b81073ea10cc64}{write\+\_\+raw\+\_\+vector$<$ long $>$}} (std\+::ostream \&str, const std\+::vector$<$ long $>$ \&v)
\item 
template$<$$>$ void \mbox{\hyperlink{namespacehelib_a374f958d521a444ec5686722c2dfad8b}{write\+\_\+raw\+\_\+vector$<$ double $>$}} (std\+::ostream \&str, const std\+::vector$<$ double $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a9e907022dc0cd7bdf40f457b786ab924}{read\+\_\+raw\+\_\+vector}} (std\+::istream \&str, std\+::vector$<$ T $>$ \&v, T \&init)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_aaa0e61f1c81f568bd942e3f50b4c5301}{read\+\_\+raw\+\_\+vector}} (std\+::istream \&str, std\+::vector$<$ T $>$ \&v)
\item 
template$<$$>$ void \mbox{\hyperlink{namespacehelib_a6f201a18aa3be048c7935a97c1bd4e82}{read\+\_\+raw\+\_\+vector$<$ long $>$}} (std\+::istream \&str, std\+::vector$<$ long $>$ \&v)
\item 
template$<$$>$ void \mbox{\hyperlink{namespacehelib_a591c5643829af4b3738d1e6cc807518e}{read\+\_\+raw\+\_\+vector$<$ double $>$}} (std\+::istream \&str, std\+::vector$<$ double $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a03a42dc495a369c587d7bfe577a1fc29}{read\+\_\+raw\+\_\+vector}} (std\+::istream \&str, std\+::vector$<$ T $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
void \mbox{\hyperlink{namespacehelib_ac544d20010a35c78a75ce913a2b15979}{Bluestein\+Init}} (long n, const N\+T\+L\+::zz\+\_\+p \&root, N\+T\+L\+::zz\+\_\+pX \&powers, N\+T\+L\+::\+Vec$<$ N\+T\+L\+::mulmod\+\_\+precon\+\_\+t $>$ \&powers\+\_\+aux, N\+T\+L\+::fft\+Rep \&Rb)
\begin{DoxyCompactList}\small\item\em initialize bluestein \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ab66ba03453e871a61eda59e0f8e574af}{Bluestein\+F\+FT}} (N\+T\+L\+::zz\+\_\+pX \&x, long n, const N\+T\+L\+::zz\+\_\+p \&root, const N\+T\+L\+::zz\+\_\+pX \&powers, const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::mulmod\+\_\+precon\+\_\+t $>$ \&powers\+\_\+aux, const N\+T\+L\+::fft\+Rep \&Rb)
\begin{DoxyCompactList}\small\item\em apply bluestein \end{DoxyCompactList}\item 
{\footnotesize template$<$typename X , typename Cloner $>$ }\\void \mbox{\hyperlink{namespacehelib_a16a28125fbbf867ea3394513923a6abb}{swap}} (cloned\+\_\+ptr$<$ X, Cloner $>$ \&x, cloned\+\_\+ptr$<$ X, Cloner $>$ \&y)
\item 
{\footnotesize template$<$typename X , typename Cloner $>$ }\\void \mbox{\hyperlink{namespacehelib_ad420c276576021ed7278823e82771b6b}{swap}} (copied\+\_\+ptr$<$ X, Cloner $>$ \&x, copied\+\_\+ptr$<$ X, Cloner $>$ \&y)
\item 
long \mbox{\hyperlink{namespacehelib_abbf9f5de032fca82af2ce94a97041bc6}{FindM}} (long k, long n\+Bits, long c, long p, long d, long s, long chosen\+\_\+m, bool verbose=false)
\begin{DoxyCompactList}\small\item\em Returns smallest parameter m satisfying various constraints\+: \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a8425881cdaaef9fade4dd57cc3cf5e8b}{write\+Context\+Base}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\begin{DoxyCompactList}\small\item\em write \mbox{[}m p r gens ords\mbox{]} data \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ab7b88eb3fd0aa4821cb6700fa65ecee2}{read\+Context\+Base}} (std\+::istream \&s, unsigned long \&m, unsigned long \&p, unsigned long \&r, std\+::vector$<$ long $>$ \&gens, std\+::vector$<$ long $>$ \&ords)
\begin{DoxyCompactList}\small\item\em read \mbox{[}m p r gens ords\mbox{]} data, needed to construct context \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_context}{Context}} $>$ \mbox{\hyperlink{namespacehelib_adcfd34a416649164e3b01c4af1c8654e}{build\+Context\+From\+Ascii}} (std\+::istream \&str)
\item 
void \mbox{\hyperlink{namespacehelib_a3167b996c8b02f9f390d1d9957693b9f}{write\+Context\+Base\+Binary}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\begin{DoxyCompactList}\small\item\em write \mbox{[}m p r gens ords\mbox{]} data \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a1f9bc09cb4de5422bb79e9c4d67db80a}{write\+Context\+Binary}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
void \mbox{\hyperlink{namespacehelib_acb88b203e4e9aeaf5fe329e7cc276aad}{read\+Context\+Base\+Binary}} (std\+::istream \&s, unsigned long \&m, unsigned long \&p, unsigned long \&r, std\+::vector$<$ long $>$ \&gens, std\+::vector$<$ long $>$ \&ords)
\begin{DoxyCompactList}\small\item\em read \mbox{[}m p r gens ords\mbox{]} data, needed to construct context \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_context}{Context}} $>$ \mbox{\hyperlink{namespacehelib_a4036006b2d0e378ce2aa90a5332a8d73}{build\+Context\+From\+Binary}} (std\+::istream \&str)
\item 
void \mbox{\hyperlink{namespacehelib_a4a07fadbe58c0bf5c4be26d9bb245755}{read\+Context\+Binary}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
void \mbox{\hyperlink{namespacehelib_af68cc874f7e017cd4c35d1ea52739c0f}{build\+Mod\+Chain}} (\mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, long n\+Bits, long n\+Dgts=3, bool will\+Be\+Bootstrappable=false, long sk\+Hwt=0, long resolution=3, long bits\+In\+Special\+Primes=0)
\item 
void \mbox{\hyperlink{namespacehelib_abcdd1f22927d282e9bbce15a18f5f3ad}{end\+Build\+Mod\+Chain}} (\mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
void \mbox{\hyperlink{namespacehelib_a6abd6bae5306a86a4f95fb62fad44c14}{packed\+Recrypt}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&c\+Ptrs, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&unpack\+Consts, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_a2903cc43702e2dccc9006f6af1da249f}{packed\+Recrypt}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&array, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&unpack\+Consts, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, long below\+Lvl)
\item 
void \mbox{\hyperlink{namespacehelib_a7653c8cc828041d87ed9805c35bf0b6f}{packed\+Recrypt}} (const \mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{Ct\+Ptr\+Mat}} \&m, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&unpack\+Consts, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, long below\+Lvl=L\+O\+N\+G\+\_\+\+M\+AX)
\item 
long \mbox{\hyperlink{namespacehelib_a3f5129e7d3dfa1e3c31cf5df21ae581d}{find\+Min\+Bit\+Capacity}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&v)
\item 
long \mbox{\hyperlink{namespacehelib_a57538912bfe96e264dab8aac85f0be75}{find\+Min\+Bit\+Capacity}} (const \mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{Ct\+Ptr\+Mat}} \&m)
\item 
long \mbox{\hyperlink{namespacehelib_a544c38d5177ea1f1d47d3e204ac1eb77}{find\+Min\+Bit\+Capacity}} (std\+::initializer\+\_\+list$<$ const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} $\ast$ $>$ list)
\item 
void \mbox{\hyperlink{namespacehelib_a391719dad458fcb9560406cb565f8cbe}{inner\+Product}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&result, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&v1, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&v2)
\item 
\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \mbox{\hyperlink{namespacehelib_aa1e7877c8a04ea75594a2295518c70d8}{inner\+Product}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&v1, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&v2)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_addc58993c7093dd07d98335bab200e82}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} \&handle)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_a84b37f68c4bdc42558ad0360b00984fb}{operator$>$$>$}} (std\+::istream \&s, \mbox{\hyperlink{classhelib_1_1_ctxt_part}{Ctxt\+Part}} \&p)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a2d941f20d5c3e55e3b36b36dd5164d6b}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_ctxt_part}{Ctxt\+Part}} \&p)
\item 
void \mbox{\hyperlink{namespacehelib_a8d9530775923f034eadc4f3e80f355ff}{total\+Product}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&out, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v)
\item 
void \mbox{\hyperlink{namespacehelib_a693b16168065219388722259c6a02c5d}{incremental\+Product}} (std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v)
\item 
void \mbox{\hyperlink{namespacehelib_a8f851f7c167ee39bfc4ceb06d754dcf0}{inner\+Product}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&result, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v1, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v2)
\item 
\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \mbox{\hyperlink{namespacehelib_aa738424e1ab49c4f39cbcb3e3e920591}{inner\+Product}} (const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v1, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v2)
\item 
void \mbox{\hyperlink{namespacehelib_abb001c145ac75147f598002b33806849}{inner\+Product}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&result, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v1, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \&v2)
\begin{DoxyCompactList}\small\item\em Compute the inner product of a vectors of ciphertexts and a constant vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \mbox{\hyperlink{namespacehelib_ad0d0484b1e2d0105b7a2b70a3c6dc182}{inner\+Product}} (const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v1, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \&v2)
\item 
void \mbox{\hyperlink{namespacehelib_ab7a60dc124ede5f7baecc0d6c7ab6df6}{inner\+Product}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&result, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v1, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&v2)
\item 
\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \mbox{\hyperlink{namespacehelib_a6d67040ef7ba12958be263a7a93dac9e}{inner\+Product}} (const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v1, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&v2)
\item 
void \mbox{\hyperlink{namespacehelib_a887b96d1f7918079c15b6fa1d8cbfae4}{Check\+Ctxt}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&c, const char $\ast$label)
\begin{DoxyCompactList}\small\item\em print to cerr some info about ciphertext \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a90e48196b014916b26112c02883f64e3}{extract\+Digits}} (std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&digits, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&c, long r=0)
\begin{DoxyCompactList}\small\item\em Extract the mod-\/p digits of a mod-\/p$^\wedge$r ciphertext. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ab463f07c91389f56b58bb09da140230d}{extract\+Digits}} (std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&digits, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&c, long r, bool short\+Cut)
\item 
void \mbox{\hyperlink{namespacehelib_a3f9b160771517accfb43d16c5590942c}{extend\+Extract\+Digits}} (std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&digits, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&c, long r, long e)
\item 
void \mbox{\hyperlink{namespacehelib_aad44440822118a09af899ff2798464d3}{setup\+Debug\+Globals}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} $\ast$debug\+\_\+key, const std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} $>$ \&debug\+\_\+ea, N\+T\+L\+::\+Z\+ZX debug\+\_\+ptxt=N\+T\+L\+::\+Z\+ZX\{\})
\begin{DoxyCompactList}\small\item\em Setup function for setting up the global debug variables. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aaa77bdb78bd529a55c239df60039e335}{cleanup\+Debug\+Globals}} ()
\begin{DoxyCompactList}\small\item\em Cleanup function for clearing the global debug variables. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a436a592900880109024757d11bb3949d}{decrypt\+And\+Print}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, long flags=0)
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_a309c3ca72a6d812a3ea23d62e48e42bf}{embedding\+Largest\+Coeff}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\item 
double \mbox{\hyperlink{namespacehelib_aeb2f4d4c24b1b5926fc02206f9b5db6a}{real\+To\+Estimated\+Noise}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\item 
void \mbox{\hyperlink{namespacehelib_ac845c61472e33fa76df608e536b25b5a}{check\+Noise}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk, const std\+::string \&msg, double thresh=10.\+0)
\item 
bool \mbox{\hyperlink{namespacehelib_a19a60ea778c6bbcc5d2732ca137c7e15}{decrypt\+And\+Compare}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa)
\item 
void \mbox{\hyperlink{namespacehelib_a50b26a9740fbaba1c3b7b5c7e89ee55c}{raw\+Decrypt}} (N\+T\+L\+::\+Z\+ZX \&plaintxt, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&zz\+Parts, const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&s\+Key, long q=0)
\item 
{\footnotesize template$<$typename V\+EC $>$ }\\std\+::ostream \& \mbox{\hyperlink{namespacehelib_af7844ba559695a1952e4d6309d21b354}{print\+Vec}} (std\+::ostream \&s, const V\+EC \&v, long n\+Coeffs=40)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a742bf72a76d5b9389251abfee9223303}{print\+Z\+ZX}} (std\+::ostream \&s, const N\+T\+L\+::\+Z\+ZX \&poly, long n\+Coeffs=40)
\item 
void \mbox{\hyperlink{namespacehelib_af5a79c25bb9e1285c93b486ce07c4d52}{conv}} (\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&d, const N\+T\+L\+::\+Z\+ZX \&p)
\item 
void \mbox{\hyperlink{namespacehelib_a5f5fe8f0918a6b964a75728b61d15c2c}{conv}} (N\+T\+L\+::\+Z\+ZX \&p, const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&d)
\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_ac584b135744603cdff25e2db01b9463a}{to\+\_\+\+Z\+ZX}} (const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&d)
\item 
{\footnotesize template$<$typename RX , typename R\+X\+Modulus $>$ }\\void \mbox{\hyperlink{namespacehelib_aefd5d1a56f7036cae390706fe49e8fcb}{plaintext\+Automorph}} (RX \&bb, const RX \&a, long k, long m, const R\+X\+Modulus \&PhimX)
\item 
{\footnotesize template$<$typename RX , typename type $>$ }\\void \mbox{\hyperlink{namespacehelib_a9f36286a4ff72a05ddf16c2e5bfaeba5}{plaintext\+Automorph}} (RX \&b, const RX \&a, long i, long j, const \mbox{\hyperlink{classhelib_1_1_encrypted_array_derived}{Encrypted\+Array\+Derived}}$<$ type $>$ \&ea)
\item 
\mbox{\hyperlink{classhelib_1_1_encrypted_array_base}{Encrypted\+Array\+Base}} $\ast$ \mbox{\hyperlink{namespacehelib_acf194ed39fc9a3694d1a11a0cd4c75d4}{build\+Encrypted\+Array}} (const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, const \mbox{\hyperlink{classhelib_1_1_p_algebra_mod}{P\+Algebra\+Mod}} \&al\+Mod, const N\+T\+L\+::\+Z\+ZX \&G=N\+T\+L\+::\+Z\+Z\+X\+::zero())
\begin{DoxyCompactList}\small\item\em A \char`\"{}factory\char`\"{} for building Encrypted\+Arrays. \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_ae5cdfe4d2a5d750a2f2ae0f2d0addabc}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa)
\item 
void \mbox{\hyperlink{namespacehelib_a34783d4707b52b8cb0341187d50f8265}{rotate}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, long k)
\item 
void \mbox{\hyperlink{namespacehelib_ae2250fb1a88c915ce004837c63aa5ad7}{shift}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, long k)
\item 
void \mbox{\hyperlink{namespacehelib_acf08ccbcd03824fa3825640c1b171481}{encode}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const std\+::vector$<$ long $>$ \&array)
\item 
void \mbox{\hyperlink{namespacehelib_ac40cf1967be4e2bf1b9a63564abe3485}{encode}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&array)
\item 
void \mbox{\hyperlink{namespacehelib_a517b7c650eafd6c9ac20ef4605a4d4a1}{encode}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, long val)
\item 
void \mbox{\hyperlink{namespacehelib_aab8cf8fcdf629a076db0d0206670a7c3}{encode}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const N\+T\+L\+::\+Z\+ZX \&val)
\item 
void \mbox{\hyperlink{namespacehelib_a38c7c1b517a8ec41eacfc5c2dba6e293}{random}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa)
\item 
void \mbox{\hyperlink{namespacehelib_a7d7757fc124c051547f6d8d62f57e6ee}{decode}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, std\+::vector$<$ long $>$ \&array, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa)
\item 
void \mbox{\hyperlink{namespacehelib_a37ce1cf83ebb14807ec5fd0ecebd03be}{decode}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&array, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa)
\item 
bool \mbox{\hyperlink{namespacehelib_aa271293d5f46187af89cc81ecb0235e9}{equals}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&other)
\item 
bool \mbox{\hyperlink{namespacehelib_ae140aabda8f5c9ace67b657134451df8}{equals}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const std\+::vector$<$ long $>$ \&other)
\item 
bool \mbox{\hyperlink{namespacehelib_aab2e1e9931564eca3665358957b06cd3}{equals}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&other)
\item 
void \mbox{\hyperlink{namespacehelib_a42185bbb249368e34f515e09e90bc7b0}{add}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&other)
\item 
void \mbox{\hyperlink{namespacehelib_a305064dc4866c160a571bd653556c113}{sub}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&other)
\item 
void \mbox{\hyperlink{namespacehelib_a0cfe07d1b0c2f0e6385f2b6525e0a69b}{mul}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&other)
\item 
void \mbox{\hyperlink{namespacehelib_a2f6016d5e65b16abb1feba5a82067b14}{negate}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa)
\item 
void \mbox{\hyperlink{namespacehelib_ab08d6e1c47a1f0b8ed57aff211929548}{frobenius\+Automorph}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, long j)
\item 
void \mbox{\hyperlink{namespacehelib_a291c0b1560a80e0cda02f89617fd16d5}{frobenius\+Automorph}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const N\+T\+L\+::\+Vec$<$ long $>$ \&vec)
\item 
void \mbox{\hyperlink{namespacehelib_adf575ea763b7454a6e8df566a9e64b3c}{apply\+Perm}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const N\+T\+L\+::\+Vec$<$ long $>$ \&pi)
\item 
void \mbox{\hyperlink{namespacehelib_a83b1a8080de040baddd971b44488ca51}{power}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, long e)
\item 
void \mbox{\hyperlink{namespacehelib_a55aba5934157b9d7517101534a0053a2}{running\+Sums}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt)
\begin{DoxyCompactList}\small\item\em A ctxt that encrypts $(x_1, ..., x_n)$ is replaced by an encryption of $(y_1, ..., y_n)$, where $y_i = sum_{j\le i} x_j$. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a14bd686a2e209597f3acecd89f1a3520}{print\+\_\+stats}} (std\+::ostream \&s)
\item 
const std\+::vector$<$ double $>$ $\ast$ \mbox{\hyperlink{namespacehelib_af35e417bff539eb8c29da182c8365e41}{fetch\+\_\+saved\+\_\+values}} (const char $\ast$)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a55a30d40b8861180c13416755e880749}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_cube_signature}{Cube\+Signature}} \&sig)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_ab89bc5e58dddac6b2dc64435b98417e1}{get\+Hyper\+Column}} (N\+T\+L\+::\+Vec$<$ T $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_const_cube_slice}{Const\+Cube\+Slice}}$<$ T $>$ \&s, long pos)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_aa12cedff32fc67534e469690637bee2d}{set\+Hyper\+Column}} (const N\+T\+L\+::\+Vec$<$ T $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ T $>$ \&s, long pos)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_abfbaf86183c619b1eef87517dcaeacd3}{set\+Hyper\+Column}} (const N\+T\+L\+::\+Vec$<$ T $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ T $>$ \&s, long pos, const T \&val)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a5d24bda05c48a744ffffd08de68736ed}{print3D}} (const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ T $>$ \&c)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespacehelib_ad5f68b7e6b0ff2bbf68b999655480fac}{operator==}} (const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&map1, const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&map2)
\begin{DoxyCompactList}\small\item\em Comparing maps, by comparing all the elements. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespacehelib_adcd34bfd104a104754a69b08d12882a4}{operator!=}} (const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&map1, const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&map2)
\item 
\mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \mbox{\hyperlink{namespacehelib_a8172413911da7a2c6f38d9eb34899140}{operator$\vert$}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&t)
\begin{DoxyCompactList}\small\item\em union \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \mbox{\hyperlink{namespacehelib_acf1a512fb48fe7d9cfc27c26a727ed6f}{operator\&}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&t)
\begin{DoxyCompactList}\small\item\em intersection \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \mbox{\hyperlink{namespacehelib_af6f7e4e0b2339b3ac2e3b7a761357d0c}{operator$^\wedge$}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&t)
\begin{DoxyCompactList}\small\item\em exclusive-\/or \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \mbox{\hyperlink{namespacehelib_a32e627abcebb74bf780514be8d6c744c}{operator/}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&t)
\begin{DoxyCompactList}\small\item\em set minus \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a5c345e01afae95eff45dd95f58fab624}{operator$<$$<$}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&set)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_a83df2fff1dfafef1f94191d2eb7d17e4}{operator$>$$>$}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&set)
\item 
long \mbox{\hyperlink{namespacehelib_ab2d7f36557c69a4840112f35af186a29}{card}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s)
\begin{DoxyCompactList}\small\item\em Functional cardinality. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_ad94835a294c90ee0ea0336561c8f38ad}{empty}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s)
\item 
bool \mbox{\hyperlink{namespacehelib_aa13e586e5a2a1ea2fd8fe9e3c45b4c98}{operator$<$=}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s1, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s2)
\begin{DoxyCompactList}\small\item\em Is s1 subset or equal to s2. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_abd46fc7a6f4b03ce4a28aea9e7c0a451}{operator$<$}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s1, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s2)
\begin{DoxyCompactList}\small\item\em Is s1 strict subset of s2. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_a4807b29449792c9a8456921063d03c91}{operator$>$=}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s1, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s2)
\begin{DoxyCompactList}\small\item\em Is s2 subset or equal to s2. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_ab7d409fa53b729e5d370d032f643f321}{operator$>$}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s1, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s2)
\begin{DoxyCompactList}\small\item\em Is s2 strict subset of s1. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_a9a593337ace30bc0dd968cae8ed4564b}{disjoint}} (const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s1, const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&s2)
\begin{DoxyCompactList}\small\item\em Functional disjoint. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ad1b9141d04abb14f7f9fe94ee4d5c9ed}{build\+Unpack\+Slot\+Encoding}} (std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&unpack\+Slot\+Encoding, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_a610ab903802e50b91b45788be635dfc1}{unpack}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&unpacked, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&packed, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&unpack\+Slot\+Encoding)
\item 
long \mbox{\hyperlink{namespacehelib_a02352b1415d1c647d5b8468cd479647b}{unpack}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&unpacked, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&packed, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&unpack\+Slot\+Encoding)
\item 
void \mbox{\hyperlink{namespacehelib_a52373565df70e730f9b11263a5c4434f}{repack}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&packed, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&unpacked, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
long \mbox{\hyperlink{namespacehelib_aa43f61b11865cfa98e7999d1027cdd37}{repack}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&packed, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&unpacked, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_aa135454e9085fe5e1f4b9f9dbc8eb55c}{unpack\+Slots}} (std\+::vector$<$ std\+::size\+\_\+t $>$ \&value, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_a611d3a80278b6196f62385f0d4d0efe9}{unpack\+Slots}} (std\+::vector$<$ std\+::size\+\_\+t $>$ \&value, N\+T\+L\+::\+Z\+ZX \&pa, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_a72ce2f6953045411b111ff7ee6f9c2d1}{pack\+Constant}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&result, unsigned long data, long nbits, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_ae46ff7d24d107f5d26d907d52aea5264}{pack\+Constants}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&result, const std\+::vector$<$ std\+::size\+\_\+t $>$ \&data, long nbits, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_a3fe91feb5d65b0afc826f181557a56e4}{write\+Pub\+Key\+Binary}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&pk)
\item 
void \mbox{\hyperlink{namespacehelib_adc9656603a03fba1b8720db0d2e5cee9}{read\+Pub\+Key\+Binary}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&pk)
\item 
void \mbox{\hyperlink{namespacehelib_a360f4b2c5989ceac05b2f37fe89239f2}{write\+Sec\+Key\+Binary}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\item 
void \mbox{\hyperlink{namespacehelib_a69b0297bb0e296d5dc39bb328d735007}{read\+Sec\+Key\+Binary}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\item 
double \mbox{\hyperlink{namespacehelib_a1f74d875dc046b81eef94c8f091e5c09}{R\+L\+WE}} (\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&c0, \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&c1, const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&s, long p, N\+T\+L\+::\+ZZ $\ast$prg\+Seed=nullptr)
\item 
double \mbox{\hyperlink{namespacehelib_a4349e62cf946950025929996328abf7c}{R\+L\+W\+E1}} (\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&c0, const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&c1, const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&s, long p)
\begin{DoxyCompactList}\small\item\em Same as R\+L\+WE, but assumes that c1 is already chosen by the caller. \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_ae5b3ba4659fee95212891f530d1a88c1}{operator$<$$<$}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \&matrix)
\item 
void \mbox{\hyperlink{namespacehelib_a6eafbe78be51b304a8b359f7f6142ef5}{Warning}} (const char $\ast$msg)
\begin{DoxyCompactList}\small\item\em Function for logging a warning message. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a9582d8b75aec10d74a0a89b48678be1b}{Warning}} (const std\+::string \&msg)
\begin{DoxyCompactList}\small\item\em Function for logging a warning message. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a5e9f98f558e2fcf0a90b77e74f54958f}{maximum\+\_\+flow}} (\mbox{\hyperlink{namespacehelib_af547f7016fc73b7174a2018ea28ef298}{Flow\+Graph}} \&fg, long src, long sink)
\item 
void \mbox{\hyperlink{namespacehelib_afc63b124cf6bc1dc82f4b599d373066c}{trace\+Map}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt)
\item 
void \mbox{\hyperlink{namespacehelib_a3c4bb86fb8d5306854596862d66e440e}{mul}} (\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_mat_mul1_d}{Mat\+Mul1D}} \&mat)
\item 
void \mbox{\hyperlink{namespacehelib_aa8141de7917e8d05d1a056a45a500615}{mul}} (\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d}{Block\+Mat\+Mul1D}} \&mat)
\item 
void \mbox{\hyperlink{namespacehelib_a22728992014e959480483be6cad9c86f}{mul}} (\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_mat_mul_full}{Mat\+Mul\+Full}} \&mat)
\item 
void \mbox{\hyperlink{namespacehelib_ac82ecaab9292facff3375eaf73ba6196}{mul}} (\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, const \mbox{\hyperlink{classhelib_1_1_block_mat_mul_full}{Block\+Mat\+Mul\+Full}} \&mat)
\item 
{\footnotesize template$<$typename T , typename T2 , typename std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ T, std\+::size\+\_\+t $>$\+::value $>$ $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T, 2 $>$ \mbox{\hyperlink{namespacehelib_a741ff01e6d83fef924789f35d31af24b}{operator$\ast$}} (const \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T, 2 $>$ \&M1, const \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T2, 2 $>$ \&M2)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a4ffb94ff808c50cb557b7ab67d925453}{print\+Matrix}} (const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T $>$ \&M, std\+::ostream \&out=std\+::cout)
\item 
long \mbox{\hyperlink{namespacehelib_afb375497516b4f80ee52cca6bbdf07fa}{sum\+Of\+Coeffs}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&f)
\item 
N\+T\+L\+::\+ZZ \mbox{\hyperlink{namespacehelib_adcbfc533a08e770ed13e226150f57298}{sum\+Of\+Coeffs}} (const N\+T\+L\+::\+Z\+ZX \&f)
\item 
N\+T\+L\+::\+ZZ \mbox{\hyperlink{namespacehelib_a31dcd6fc8861bd6ead98d082fba87214}{sum\+Of\+Coeffs}} (const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&f)
\item 
{\footnotesize template$<$typename T $>$ }\\double \mbox{\hyperlink{namespacehelib_adb4453a3ae42dffc130876e783bea3fe}{largest\+Coeff}} (const N\+T\+L\+::\+Vec$<$ T $>$ \&f)
\begin{DoxyCompactList}\small\item\em The L-\/infinity norm of an element (in coefficient representation) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\double \mbox{\hyperlink{namespacehelib_a77f80e02dad1c557005618be367c28f8}{largest\+Coeff}} (const std\+::vector$<$ T $>$ \&f)
\item 
N\+T\+L\+::\+ZZ \mbox{\hyperlink{namespacehelib_a1a20a91635cf835f5d24ba9fc0431002}{largest\+Coeff}} (const N\+T\+L\+::\+Z\+ZX \&f)
\item 
N\+T\+L\+::\+ZZ \mbox{\hyperlink{namespacehelib_a46eaa10d04eed2ee69d9e2c0a52528a7}{largest\+Coeff}} (const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&f)
\item 
N\+T\+L\+::\+ZZ \mbox{\hyperlink{namespacehelib_abe1a3a33c80ba67655fd3cf8e6e66831}{largest\+Coeff}} (const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&f)
\item 
double \mbox{\hyperlink{namespacehelib_a05eeef94d05d407f020712567c5eef27}{coeffs\+L2\+Norm\+Squared}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&f)
\begin{DoxyCompactList}\small\item\em The L2-\/norm of an element (in coefficient representation) \end{DoxyCompactList}\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_a09fe1adbf8a3a923231957865d6f7ade}{coeffs\+L2\+Norm\+Squared}} (const N\+T\+L\+::\+Z\+ZX \&f)
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_ac39c73d6b51367807eca721bb748aadc}{coeffs\+L2\+Norm\+Squared}} (const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&f)
\item 
double \mbox{\hyperlink{namespacehelib_a52c99506d6fcb0a0f0611a555e77fab3}{coeffs\+L2\+Norm}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&f)
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_a3ae9e83dde78e745c57a36e18fc4372b}{coeffs\+L2\+Norm}} (const N\+T\+L\+::\+Z\+ZX \&f)
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_a3f7865779ff5d7047037583852782963}{coeffs\+L2\+Norm}} (const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&f)
\item 
double \mbox{\hyperlink{namespacehelib_a1163a93bce42908b4edfa4e2a2989c49}{embedding\+Largest\+Coeff}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&f, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
double \mbox{\hyperlink{namespacehelib_a3a9543f301395b419a4026ea72424c01}{embedding\+Largest\+Coeff}} (const std\+::vector$<$ double $>$ \&f, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
void \mbox{\hyperlink{namespacehelib_a338704cc219609b1663cc3b5bf1cb631}{embedding\+Largest\+Coeff\+\_\+x2}} (double \&norm1, double \&norm2, const std\+::vector$<$ double $>$ \&f1, const std\+::vector$<$ double $>$ \&f2, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_aff1d310e2dc35b38b4f87aeaa0e8c73c}{embedding\+Largest\+Coeff}} (const N\+T\+L\+::\+Z\+ZX \&f, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
void \mbox{\hyperlink{namespacehelib_affe1779765ee918f4c7e869ed86baf6a}{C\+K\+K\+S\+\_\+canonical\+Embedding}} (std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&v, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&f, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
void \mbox{\hyperlink{namespacehelib_a5ec3f9852eabd8796caf38d347501acd}{C\+K\+K\+S\+\_\+canonical\+Embedding}} (std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&v, const N\+T\+L\+::\+Z\+ZX \&f, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
void \mbox{\hyperlink{namespacehelib_a7cd57ab6741a87f8b261d0a1417b8c5b}{C\+K\+K\+S\+\_\+canonical\+Embedding}} (std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&v, const std\+::vector$<$ double $>$ \&f, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
void \mbox{\hyperlink{namespacehelib_a5ec40f00efeb846267027bd14353fe4a}{C\+K\+K\+S\+\_\+embed\+In\+Slots}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&f, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg, double scaling)
\item 
bool \mbox{\hyperlink{namespacehelib_af8f51eef1d124d7e046b6a276d857fdb}{set\+Dry\+Run}} (bool to\+What=true)
\item 
bool \mbox{\hyperlink{namespacehelib_aa79a0a06add60a27a1a2198fcf948e01}{is\+Dry\+Run}} ()
\item 
void \mbox{\hyperlink{namespacehelib_a1ce92a7a0f311e90d9022ea931a671ec}{set\+Automorph\+Vals}} (std\+::set$<$ long $>$ $\ast$a\+Vals)
\item 
bool \mbox{\hyperlink{namespacehelib_ac639ce6687180f2ac5e50e8706d79488}{is\+Set\+Automorph\+Vals}} ()
\item 
void \mbox{\hyperlink{namespacehelib_a7b0cf6b325974c5fb87c29686d82e414}{record\+Automorph\+Val}} (long k)
\item 
void \mbox{\hyperlink{namespacehelib_a8fab1809e50aa6fc8c0f80e66943f490}{set\+Automorph\+Vals2}} (std\+::set$<$ long $>$ $\ast$a\+Vals)
\item 
bool \mbox{\hyperlink{namespacehelib_aff7fd713547b09f8f18fbf95ccf83f95}{is\+Set\+Automorph\+Vals2}} ()
\item 
void \mbox{\hyperlink{namespacehelib_a479ecb7208f177739fa83913e8515192}{record\+Automorph\+Val2}} (long k)
\item 
long \mbox{\hyperlink{namespacehelib_af6cd0b7c9b7fa0afbb885295f10d9354}{bit\+Set\+To\+Long}} (long bits, long bit\+Size)
\begin{DoxyCompactList}\small\item\em Considers {\ttfamily bits} as a vector of bits and returns the value it represents when interpreted as a n-\/bit 2\textquotesingle{}s complement number, where n is given by {\ttfamily bit\+Size}. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a3f2638750d81a618d59217f3e9b3218a}{mc\+Mod}} (long a, long b)
\begin{DoxyCompactList}\small\item\em Routines for computing mathematically correct mod and div. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a51f60e27cb24d575d4b10a522dbb4279}{mc\+Div}} (long a, long b)
\item 
long \mbox{\hyperlink{namespacehelib_af183ee91810e5601837e62dfb85df0cd}{bal\+Rem}} (long a, long q)
\item 
double \mbox{\hyperlink{namespacehelib_ad92538fab792f75e009a2330c365637d}{fsquare}} (double x)
\begin{DoxyCompactList}\small\item\em Return the square of a number as a double. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a96fc760be384a17313e24f5383ceabd1}{mult\+Ord}} (long p, long m)
\begin{DoxyCompactList}\small\item\em Return multiplicative order of p modulo m, or 0 if G\+C\+D(p, m) != 1. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_acdb8f2124f5f56970fe7f88802c976b1}{ppsolve}} (N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&x, const N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&A, const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&b, long p, long r)
\begin{DoxyCompactList}\small\item\em Prime power solver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a0faaee69d7f687471cb483dfa78e6701}{ppsolve}} (N\+T\+L\+::vec\+\_\+\+G\+F2E \&x, const N\+T\+L\+::mat\+\_\+\+G\+F2E \&A, const N\+T\+L\+::vec\+\_\+\+G\+F2E \&b, long p, long r)
\begin{DoxyCompactList}\small\item\em A version for G\+F2\+: must have p == 2 and r == 1. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a784e87216f278000cfa935b61657da58}{pp\+Invert}} (N\+T\+L\+::mat\+\_\+zz\+\_\+p \&X, const N\+T\+L\+::mat\+\_\+zz\+\_\+p \&A, long p, long r)
\begin{DoxyCompactList}\small\item\em Compute the inverse mod p$^\wedge$r of an n x n matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a73a34ea89aec17e40d20d534e210a14f}{pp\+Invert}} (N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&X, const N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&A, long p, long r)
\item 
void \mbox{\hyperlink{namespacehelib_af35b575565f163995c6abd08972bddf2}{pp\+Invert}} (N\+T\+L\+::mat\+\_\+\+G\+F2 \&X, const N\+T\+L\+::mat\+\_\+\+G\+F2 \&A, U\+N\+U\+S\+ED long p, U\+N\+U\+S\+ED long r)
\item 
void \mbox{\hyperlink{namespacehelib_ac46606ccee8c1fe481e3b5a1f90291c5}{pp\+Invert}} (N\+T\+L\+::mat\+\_\+\+G\+F2E \&X, const N\+T\+L\+::mat\+\_\+\+G\+F2E \&A, U\+N\+U\+S\+ED long p, U\+N\+U\+S\+ED long r)
\item 
void \mbox{\hyperlink{namespacehelib_a7db28e5ca105b114e0c89655eee171b9}{build\+Lin\+Poly\+Matrix}} (N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&M, long p)
\item 
void \mbox{\hyperlink{namespacehelib_a82218a5a8f14a790b60cd7f288863b9d}{build\+Lin\+Poly\+Matrix}} (N\+T\+L\+::mat\+\_\+\+G\+F2E \&M, long p)
\item 
void \mbox{\hyperlink{namespacehelib_a5711dacd10c102835bd585bff52e32c5}{build\+Lin\+Poly\+Coeffs}} (N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&C, const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&L, long p, long r)
\begin{DoxyCompactList}\small\item\em Combination of build\+Lin\+Poly\+Matrix and ppsolve. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ae78f42668b74b50bfeec97988619350c}{build\+Lin\+Poly\+Coeffs}} (N\+T\+L\+::vec\+\_\+\+G\+F2E \&C, const N\+T\+L\+::vec\+\_\+\+G\+F2E \&L, long p, long r)
\begin{DoxyCompactList}\small\item\em A version for G\+F2\+: must be called with p == 2 and r == 1. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a0dda3f81ff66fb0e9a92bc39ecad0a92}{apply\+Lin\+Poly}} (N\+T\+L\+::zz\+\_\+pE \&beta, const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&C, const N\+T\+L\+::zz\+\_\+pE \&alpha, long p)
\begin{DoxyCompactList}\small\item\em Apply a linearized polynomial with coefficient vector C. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a379dfd6585b3c7aab695a9ca33a7ad89}{apply\+Lin\+Poly}} (N\+T\+L\+::\+G\+F2E \&beta, const N\+T\+L\+::vec\+\_\+\+G\+F2E \&C, const N\+T\+L\+::\+G\+F2E \&alpha, long p)
\begin{DoxyCompactList}\small\item\em A version for G\+F2\+: must be called with p == 2 and r == 1. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacehelib_ac1630d15e5b8352685afcf561db40323}{log2}} (const N\+T\+L\+::xdouble \&x)
\begin{DoxyCompactList}\small\item\em Base-\/2 logarithm. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a8d163aa9f73ad476ebd97d7778d79258}{factorize}} (std\+::vector$<$ long $>$ \&factors, long N)
\begin{DoxyCompactList}\small\item\em Factoring by trial division, only works for N$<$2$^\wedge$\{60\}, only the primes are recorded, not their multiplicity. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a0a26515bfdcb0f7e654cefa0d955d4be}{factorize}} (std\+::vector$<$ N\+T\+L\+::\+ZZ $>$ \&factors, const N\+T\+L\+::\+ZZ \&N)
\item 
void \mbox{\hyperlink{namespacehelib_a75dc52f12b0306195238f56bcf4a112b}{factorize}} (N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+Pair$<$ long, long $>$$>$ \&factors, long N)
\begin{DoxyCompactList}\small\item\em Factoring by trial division, only works for N$<$2$^\wedge$\{60\} primes and multiplicities are recorded. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a407ad6533d4dd3820cc35b07ad41988b}{pp\+\_\+factorize}} (std\+::vector$<$ long $>$ \&factors, long N)
\begin{DoxyCompactList}\small\item\em Prime-\/power factorization. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_add32ec15c61473a42b7136dee8360b8b}{phiN}} (long \&phiN, std\+::vector$<$ long $>$ \&facts, long N)
\begin{DoxyCompactList}\small\item\em Compute Phi(\+N) and also factorize N. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a62dc0ba06446370515708c0229fa046e}{phiN}} (N\+T\+L\+::\+ZZ \&phiN, std\+::vector$<$ N\+T\+L\+::\+ZZ $>$ \&facts, const N\+T\+L\+::\+ZZ \&N)
\item 
long \mbox{\hyperlink{namespacehelib_a93e575c4502d7606d86b46af66600ce0}{phi\+\_\+N}} (long N)
\begin{DoxyCompactList}\small\item\em Compute Phi(\+N). \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a67f0037687252f6999a8526165cd8e41}{find\+Generators}} (std\+::vector$<$ long $>$ \&gens, std\+::vector$<$ long $>$ \&ords, long m, long p, const std\+::vector$<$ long $>$ \&candidates=std\+::vector$<$ long $>$())
\item 
void \mbox{\hyperlink{namespacehelib_a9e1f9936cf8c582202702cbb65eaf2ce}{Find\+Primitive\+Root}} (N\+T\+L\+::zz\+\_\+p \&r, unsigned long e)
\begin{DoxyCompactList}\small\item\em Find e-\/th root of unity modulo the current modulus. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ae3ed622332f1680e6384644d3c347e19}{Find\+Primitive\+Root}} (N\+T\+L\+::\+Z\+Z\+\_\+p \&r, unsigned long e)
\item 
long \mbox{\hyperlink{namespacehelib_ad4d98c1a6634ea3827fafd456ea56a5e}{mobius}} (long n)
\begin{DoxyCompactList}\small\item\em Compute mobius function (naive method as n is small). \end{DoxyCompactList}\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_a181a74dc451ffc410450d6c238f2a68c}{Cyclotomic}} (long N)
\begin{DoxyCompactList}\small\item\em Compute cyclotomic polynomial. \end{DoxyCompactList}\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_adad7e0c1723b324e29278f21aa889143}{make\+Irred\+Poly}} (long p, long d)
\begin{DoxyCompactList}\small\item\em Return a degree-\/d irreducible polynomial mod p. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a9b5c3e6a25c84bcec39b646e10598378}{primroot}} (long N, long \mbox{\hyperlink{namespacehelib_add32ec15c61473a42b7136dee8360b8b}{phiN}})
\begin{DoxyCompactList}\small\item\em Find a primitive root modulo N. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a8693a4a2d91babebc9b8887bbcd1f0ea}{ord}} (long N, long p)
\begin{DoxyCompactList}\small\item\em Compute the highest power of p that divides N. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_a57dbaa8bc9cf194a1e08fd5af3497a5e}{is2power}} (long m)
\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_ad0bcd83ef1650a094f9ba12551a2e9e4}{Rand\+Poly}} (long n, const N\+T\+L\+::\+ZZ \&p)
\item 
void \mbox{\hyperlink{namespacehelib_a8fc507c5ea1850c348a7c2d743b59a57}{Mul\+Mod}} (N\+T\+L\+::\+Z\+ZX \&out, const N\+T\+L\+::\+Z\+ZX \&f, long a, long q, bool abs)
\item 
void \mbox{\hyperlink{namespacehelib_af73b2f08337ba65b54609e7bfca96cda}{Mul\+Mod}} (N\+T\+L\+::\+Z\+ZX \&out, const N\+T\+L\+::\+Z\+ZX \&f, long a, long q)
\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_a44a8cf8d3d1da74a8060a177e3e49028}{Mul\+Mod}} (const N\+T\+L\+::\+Z\+ZX \&f, long a, long q, bool abs)
\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_a16376b83d0b9ac08d1cc631756741220}{Mul\+Mod}} (const N\+T\+L\+::\+Z\+ZX \&f, long a, long q)
\item 
void \mbox{\hyperlink{namespacehelib_a00e504f2374c5e7357c7608a94527887}{balanced\+\_\+\+Mul\+Mod}} (N\+T\+L\+::\+Z\+ZX \&out, const N\+T\+L\+::\+Z\+ZX \&f, long a, long q)
\item 
{\footnotesize template$<$typename T1 , typename T2 $>$ }\\void \mbox{\hyperlink{namespacehelib_ab2e47ad408b14cf352174243c3c8adf6}{convert}} (T1 \&x1, const T2 \&x2)
\begin{DoxyCompactList}\small\item\em A generic template that resolves to N\+TL\textquotesingle{}s conv routine. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T1 , typename T2 $>$ }\\void \mbox{\hyperlink{namespacehelib_a59e1e9edc58b546c8d12a4cb56812f81}{convert}} (std\+::vector$<$ T1 $>$ \&v1, const std\+::vector$<$ T2 $>$ \&v2)
\begin{DoxyCompactList}\small\item\em generic vector conversion routines \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T1 , typename T2 $>$ }\\void \mbox{\hyperlink{namespacehelib_ab5d8cacfd0370294ae07fb571ee2caee}{convert}} (std\+::vector$<$ T1 $>$ \&v1, const N\+T\+L\+::\+Vec$<$ T2 $>$ \&v2)
\item 
{\footnotesize template$<$typename T1 , typename T2 $>$ }\\void \mbox{\hyperlink{namespacehelib_a33593bb6e050f5639138bf3f76a28d8c}{convert}} (N\+T\+L\+::\+Vec$<$ T1 $>$ \&v1, const std\+::vector$<$ T2 $>$ \&v2)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_aa59b9ea3393970dcb1c4a9ef6ef310ef}{convert}} (std\+::vector$<$ T $>$ \&v1, const std\+::vector$<$ T $>$ \&v2)
\begin{DoxyCompactList}\small\item\em Trivial type conversion, useful for generic code. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T1 , typename T2 $>$ }\\T1 \mbox{\hyperlink{namespacehelib_a194a7e93c41b4da649614c39e9a77c8f}{convert}} (const T2 \&v2)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespacehelib_a3f11bbe3deab00c9a1dc525d23958a6c}{vector\+\_\+replicate}} (const T \&a, long n)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespacehelib_a29ccc2648ee5736fe519c1c884bf1b68}{Vec\+\_\+replicate}} (const T \&a, long n)
\item 
long \mbox{\hyperlink{namespacehelib_a9837bdade0e2dabb7bbf0d03a5e2e93b}{compute\+Prod}} (const N\+T\+L\+::\+Vec$<$ long $>$ \&vec)
\begin{DoxyCompactList}\small\item\em returns \textbackslash{}prod\+\_\+d vec\mbox{[}d\mbox{]} \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_aababf76c7325db9e7409cf950a581993}{compute\+Prod}} (const std\+::vector$<$ long $>$ \&vec)
\item 
void \mbox{\hyperlink{namespacehelib_a50c25069289464e0a2fb8398199fd5ef}{mul}} (std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&x, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&a, long b)
\item 
void \mbox{\hyperlink{namespacehelib_a9965244b44a7884f3e08999f6adec16f}{div}} (std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&x, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&a, long b)
\item 
void \mbox{\hyperlink{namespacehelib_a33424cc1805af9dc818e142033c9d9be}{add}} (std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&x, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&a, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&b)
\item 
long \mbox{\hyperlink{namespacehelib_a1249c9ddf12d285f6c06985342e52562}{is\+\_\+in}} (long x, int $\ast$X, long sz)
\begin{DoxyCompactList}\small\item\em Finds whether x is an element of the set X of size sz, Returns -\/1 it not and the location if true. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_afcde52d4dcf5f9f26931c54efa401258}{C\+R\+Tcoeff}} (long p, long q, bool symmetric=false)
\begin{DoxyCompactList}\small\item\em Returns a C\+RT coefficient\+: x = (0 mod p, 1 mod q). If symmetric is set then x \textbackslash{}in \mbox{[}-\/pq/2, pq/2), else x \textbackslash{}in \mbox{[}0,pq) \end{DoxyCompactList}\item 
{\footnotesize template$<$class zzvec $>$ }\\bool \mbox{\hyperlink{namespacehelib_a5165f6a4ea9a752c8c40d5790acfb4e0}{int\+Vec\+C\+RT}} (N\+T\+L\+::vec\+\_\+\+ZZ \&vp, const N\+T\+L\+::\+ZZ \&p, const zzvec \&vq, long q)
\begin{DoxyCompactList}\small\item\em Incremental integer C\+RT for vectors. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , bool max\+Flag$>$ }\\long \mbox{\hyperlink{namespacehelib_aaa88363f3a91a37ba8e213b0cb764ea5}{argminmax}} (std\+::vector$<$ T $>$ \&v)
\begin{DoxyCompactList}\small\item\em Find the index of the (first) largest/smallest element. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\long \mbox{\hyperlink{namespacehelib_ae84a9818e92cbee595e4895ad9dee849}{argmax}} (std\+::vector$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\long \mbox{\hyperlink{namespacehelib_a4218a947a483c68d1727c537c216c347}{argmin}} (std\+::vector$<$ T $>$ \&v)
\item 
long \mbox{\hyperlink{namespacehelib_acced988b8c7248219e7c13e20d1d0e6c}{argmax}} (std\+::vector$<$ long $>$ \&v, bool($\ast$more\+Than)(long, long))
\begin{DoxyCompactList}\small\item\em A variant with a specialized comparison function ($\ast$more\+Than)(a,b) returns the comparison a$>$b. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_a3b607a9ca070971badf105209dc47583}{close\+To\+One}} (const N\+T\+L\+::xdouble \&x, long p)
\item 
std\+::pair$<$ long, long $>$ \mbox{\hyperlink{namespacehelib_a03f697f7ff3bbb3d9d17f75d35946991}{rational\+Approx}} (double x, long denom\+Bound=0)
\item 
std\+::pair$<$ N\+T\+L\+::\+ZZ, N\+T\+L\+::\+ZZ $>$ \mbox{\hyperlink{namespacehelib_a564d4348157a8775888f09a680313ba6}{rational\+Approx}} (N\+T\+L\+::xdouble x, N\+T\+L\+::xdouble denom\+Bound=N\+T\+L\+::xdouble(0.\+0))
\item 
void \mbox{\hyperlink{namespacehelib_a0df3789de0744e7c90d5a5d6cf54a5ed}{seek\+Past\+Char}} (std\+::istream \&str, int cc)
\begin{DoxyCompactList}\small\item\em Advance the input stream beyond white spaces and a single instance of the char cc. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_a002c386c997a1dfb9113bb7a7070d95e}{iterate\+Interest\+Region}} (std\+::istream \&str, int begin\+\_\+char, int separator, int end\+\_\+char)
\begin{DoxyCompactList}\small\item\em Advance the input stream {\ttfamily str} beyond white spaces and a single {\ttfamily separator} in the region-\/of-\/interest delimited by {\ttfamily begin\+\_\+char} and {\ttfamily end\+\_\+char}. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::stringstream $>$ \mbox{\hyperlink{namespacehelib_ad5b904688ca513ad603df4d470c5ae21}{extract\+Tokenize\+Region}} (std\+::istream \&istr, char begin\+\_\+char, char end\+\_\+char, char separator, bool skip\+\_\+space=true)
\begin{DoxyCompactList}\small\item\em Advance the input stream {\ttfamily istr} beyond white spaces. Then split the region delimited by {\ttfamily begin\+\_\+char} and {\ttfamily end\+\_\+char} at each occurrence of {\ttfamily separator} that is not contained in an inner {\ttfamily begin\+\_\+char} -\/ {\ttfamily end\+\_\+char} section. The function returns a {\ttfamily std\+::vector$<$std\+::stringstream$>$} with the stream of every section of the input region. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a8dfd59b19280a7a98989bbc0dd6a8c2c}{reverse}} (N\+T\+L\+::\+Vec$<$ T $>$ \&v, long lo, long hi)
\begin{DoxyCompactList}\small\item\em Reverse a vector in place. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a1688528ff1a377be38502ae7c048336c}{rotate}} (N\+T\+L\+::\+Vec$<$ T $>$ \&v, long k)
\begin{DoxyCompactList}\small\item\em Rotate a vector in place using swaps. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\long \mbox{\hyperlink{namespacehelib_ae8f65ef133cee27ad846423d012d5487}{lsize}} (const std\+::vector$<$ T $>$ \&v)
\begin{DoxyCompactList}\small\item\em Size of S\+TL vector as a long (rather than unsigned long) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a3ca37f043534295ce82c13c09b48325f}{kill\+Vec}} (std\+::vector$<$ T $>$ \&vec)
\begin{DoxyCompactList}\small\item\em N\+T\+L/std compatibility. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a5d98d78d4a4dddc7c6859af409b17e07}{kill\+Vec}} (N\+T\+L\+::\+Vec$<$ T $>$ \&vec)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_ae2de6d470f49ed882f0bde7b67f5c456}{set\+Length\+Zero}} (std\+::vector$<$ T $>$ \&vec)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a07b53294ce70bc1a04b741ef3ac4512d}{set\+Length\+Zero}} (N\+T\+L\+::\+Vec$<$ T $>$ \&vec)
\item 
{\footnotesize template$<$typename T $>$ }\\long \mbox{\hyperlink{namespacehelib_a50cb104179094690467c87a1c09c8a05}{lsize}} (const N\+T\+L\+::\+Vec$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_ad61eac49543dd3559b386f94ca7112c9}{resize}} (N\+T\+L\+::\+Vec$<$ T $>$ \&v, long sz, const T \&val)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_ae8aea4186c17622aa24763219ba2e39c}{resize}} (std\+::vector$<$ T $>$ \&v, long sz, const T \&val)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a49b481e5ebaa9bc469124e7c2d5eae38}{resize}} (N\+T\+L\+::\+Vec$<$ T $>$ \&v, long sz)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a91e17a6dd739205036bdc410372608cc}{resize}} (std\+::vector$<$ T $>$ \&v, long sz)
\item 
{\footnotesize template$<$typename T1 , typename T2 $>$ }\\bool \mbox{\hyperlink{namespacehelib_a1dac9d465c144cdd7f736730704c38e6}{same\+Object}} (const T1 $\ast$p1, const T2 $\ast$p2)
\begin{DoxyCompactList}\small\item\em Testing if two vectors point to the same object. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ad7d7a435e482d03e39e3b592765adc85}{Mod\+Comp}} (N\+T\+L\+::\+Z\+ZX \&res, const N\+T\+L\+::\+Z\+ZX \&g, const N\+T\+L\+::\+Z\+ZX \&h, const N\+T\+L\+::\+Z\+ZX \&f)
\begin{DoxyCompactList}\small\item\em Modular composition of polynomials\+: res = g(h) mod f. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_a11db92e970f97ed66aebb1702dc5a0df}{poly\+Eval\+Mod}} (const N\+T\+L\+::\+Z\+ZX \&poly, long x, long p)
\begin{DoxyCompactList}\small\item\em Evaluates a modular integer polynomial, returns poly(x) mod p. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a9e7d6d68a0351702ae31c17eb4e72307}{interpolate\+Mod}} (N\+T\+L\+::\+Z\+ZX \&poly, const N\+T\+L\+::vec\+\_\+long \&x, const N\+T\+L\+::vec\+\_\+long \&y, long p, long e=1)
\begin{DoxyCompactList}\small\item\em Interpolate polynomial such that poly(x\mbox{[}i\mbox{]} mod p)=y\mbox{[}i\mbox{]} (mod p$^\wedge$e) It is assumed that the points x\mbox{[}i\mbox{]} are all distinct modulo p. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{namespacehelib_ad8ff9e17791a3dd96ca79b2dd4d0654d}{divc}} (long a, long b)
\begin{DoxyCompactList}\small\item\em returns ceiling(a/b); assumes a $>$=0, b$>$0, a+b $<$= M\+A\+X\+\_\+\+L\+O\+NG \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_af7b15d5fbf553550437df6ca02d5a282}{rem}} (N\+T\+L\+::zz\+\_\+pX \&r, const N\+T\+L\+::zz\+\_\+pX \&a, const \mbox{\hyperlink{classhelib_1_1zz__p_x_modulus1}{zz\+\_\+p\+X\+Modulus1}} \&ff)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::ostream \& \mbox{\hyperlink{namespacehelib_a91bd0e83a2e59c7de3a489b5d3fb3aa8}{operator$<$$<$}} (std\+::ostream \&s, std\+::vector$<$ T $>$ v)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::istream \& \mbox{\hyperlink{namespacehelib_a2b06418a6494e921dec0c5d086cf46ce}{operator$>$$>$}} (std\+::istream \&s, std\+::vector$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::string \mbox{\hyperlink{namespacehelib_aaa86d423a862384884b7bed74e573e8f}{vec\+To\+Str}} (const std\+::vector$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\N\+T\+L\+::\+Vec$<$ T $>$ \mbox{\hyperlink{namespacehelib_a1040284398724d43661ac3eff7a7400e}{ato\+Vec}} (const char $\ast$a)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespacehelib_acdd11aa1bf58d7ac5843fe3ee5fb244c}{atovector}} (const char $\ast$a)
\item 
void \mbox{\hyperlink{namespacehelib_ab19a0354bdc3a0ef4ba47d01c8a4aaaf}{Tofft\+Rep\+\_\+trunc}} (N\+T\+L\+::fft\+Rep \&y, const N\+T\+L\+::zz\+\_\+pX \&x, long k, U\+N\+U\+S\+ED long len, long lo, long hi)
\item 
void \mbox{\hyperlink{namespacehelib_a3259e4f89f7c305b12bd13bab812ef72}{Tofft\+Rep\+\_\+trunc}} (N\+T\+L\+::fft\+Rep \&y, const N\+T\+L\+::zz\+\_\+pX \&x, long k, long len)
\item 
double \mbox{\hyperlink{namespacehelib_a113e6cbc8db288631df5f13330027dc3}{max\+\_\+abs}} (const std\+::vector$<$ std\+::complex$<$ double $>$$>$ \&vec)
\item 
double \mbox{\hyperlink{namespacehelib_a21a15540439b4c2c57e1e5eb129cd54a}{max\+\_\+abs}} (const std\+::vector$<$ double $>$ \&vec)
\item 
{\footnotesize template$<$typename T , typename P , typename... Args$>$ }\\void \mbox{\hyperlink{namespacehelib_a454437c5c0e3415fe2a360fa48a3eb5f}{make\+\_\+lazy}} (const N\+T\+L\+::\+Lazy$<$ T, P $>$ \&obj, Args \&\&... args)
\item 
{\footnotesize template$<$typename T , typename P , typename F , typename... Args$>$ }\\void \mbox{\hyperlink{namespacehelib_a05c7ab380349944791e571afd60e7a06}{make\+\_\+lazy\+\_\+with\+\_\+fun}} (const N\+T\+L\+::\+Lazy$<$ T, P $>$ \&obj, F f, Args \&\&... args)
\item 
\mbox{\hyperlink{classhelib_1_1_p_algebra_mod_base}{P\+Algebra\+Mod\+Base}} $\ast$ \mbox{\hyperlink{namespacehelib_af7ad5bd5c310b0ad7f96d6e2065e5b2b}{build\+P\+Algebra\+Mod}} (const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&z\+M\+Star, long r)
\begin{DoxyCompactList}\small\item\em Builds a table, of type P\+A\+\_\+\+G\+F2 if p == 2 and r == 1, and P\+A\+\_\+zz\+\_\+p otherwise. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_aed4e8a7e6a0c99087b87431d7478e4d6}{compare\+P\+Algebra}} (const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg, unsigned long m, unsigned long p, unsigned long r, const std\+::vector$<$ long $>$ \&gens, const std\+::vector$<$ long $>$ \&ords)
\begin{DoxyCompactList}\small\item\em returns true if the palg parameters match the rest, false otherwise \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacehelib_a742ec1357ca244079dacd7c1cb2fcb90}{calc\+Poly\+Norm\+Bnd}} (long m)
\item 
{\footnotesize template$<$typename T\+XT $>$ }\\\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$ \mbox{\hyperlink{namespacehelib_ac65801611ad6b47e4cb4c37bf86e5be5}{calculate\+Masks}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$ query, const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$$>$ \&database)
\begin{DoxyCompactList}\small\item\em Given a query set and a database, calculates a mask of \{0,1\} where 1 signifies a matching element and 0 otherwise. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+XT $>$ }\\\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \mbox{\hyperlink{namespacehelib_a3afe505ae7315e1226c3fd95f8ea3487}{calculate\+Masks}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$ query, const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&database)
\begin{DoxyCompactList}\small\item\em Given a query set and a database, calculates a mask of \{0,1\} where 1 signifies a matching element and 0 otherwise. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+XT $>$ }\\\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$ \mbox{\hyperlink{namespacehelib_a78b9e18a6520b9b54c6adc3096bdaf87}{calculate\+Scores}} (const std\+::vector$<$ std\+::vector$<$ long $>$$>$ index\+\_\+sets, const std\+::vector$<$ long $>$ \&offsets, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ long $>$$>$ \&weights, const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$ \&mask)
\begin{DoxyCompactList}\small\item\em Given a mask and information about the query to be performed, calculates a score for each matching element signified by the mask. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \mbox{\hyperlink{namespacehelib_a527dbcddde6c00dcf8ba8117b9290043}{partial\+Match\+Encode}} (uint32\+\_\+t input, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\begin{DoxyCompactList}\small\item\em Given a value, encode the value across the coefficients of a polynomial. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_col_number}{Col\+Number}} $>$ \mbox{\hyperlink{namespacehelib_a5b2e968f2faca98f693ac809962242ba}{make\+Query\+Expr}} (int cl)
\begin{DoxyCompactList}\small\item\em Utility function for creating a shared pointer to a specified column in a query. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_and}{And}} $>$ \mbox{\hyperlink{namespacehelib_ad1e3d7533fd36aed14028db8a0aec5c2}{operator\&\&}} (const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&lhs, const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&rhs)
\begin{DoxyCompactList}\small\item\em Overloaded operator for creating a shared pointer to an A\+ND expression. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_or}{Or}} $>$ \mbox{\hyperlink{namespacehelib_a52eacb5c692c3fbf563e88a7ee693fcf}{operator$\vert$$\vert$}} (const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&lhs, const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&rhs)
\begin{DoxyCompactList}\small\item\em Overloaded operator for creating a shared pointer to an OR expression. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a0cf8627539f6c1c46e6ae9287058f7cc}{apply\+Perm\+To\+Vec}} (N\+T\+L\+::\+Vec$<$ T $>$ \&out, const N\+T\+L\+::\+Vec$<$ T $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\begin{DoxyCompactList}\small\item\em Apply a permutation to a std\+::vector, out\mbox{[}i\mbox{]}=in\mbox{[}p1\mbox{[}i\mbox{]}\mbox{]} (N\+OT in-\/place) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_abae99af99454c783bed9cbde7cd72058}{apply\+Perm\+To\+Vec}} (std\+::vector$<$ T $>$ \&out, const std\+::vector$<$ T $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a0ae17bbc28a578112d0fe28b99f5e204}{apply\+Perms\+To\+Vec}} (N\+T\+L\+::\+Vec$<$ T $>$ \&out, const N\+T\+L\+::\+Vec$<$ T $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p2, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\begin{DoxyCompactList}\small\item\em Apply two permutations to a std\+::vector out\mbox{[}i\mbox{]}=in\mbox{[}p2\mbox{[}p1\mbox{[}i\mbox{]}\mbox{]}\mbox{]} (N\+OT in-\/place) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a6c6d61d4ac69597feb9beedc26bf93cc}{apply\+Perms\+To\+Vec}} (std\+::vector$<$ T $>$ \&out, const std\+::vector$<$ T $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p2, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\item 
void \mbox{\hyperlink{namespacehelib_aa74c29f86e466570325f829fe4ea74b0}{random\+Perm}} (\mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&perm, long n)
\begin{DoxyCompactList}\small\item\em A random size-\/n permutation. \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_ac6b38e2bdf2734a792b5f11fe5f293be}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} \&p)
\item 
void \mbox{\hyperlink{namespacehelib_a11554e25622d14682edfa2be22ed6df6}{break\+Perm\+By\+Dim}} (std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} $>$ \&out, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&pi, const \mbox{\hyperlink{classhelib_1_1_cube_signature}{Cube\+Signature}} \&sig)
\begin{DoxyCompactList}\small\item\em Takes a permutation pi over m-\/dimensional cube C=Z\+\_\+\{n1\} x...x Z\+\_\+\{nm\} and expresses pi as a product pi = rho\+\_\+\{2m-\/1\} o ... o rho\+\_\+2 o rho\+\_\+1 where each rho\+\_\+i is a column permutation along one dimension. Specifically for i$<$m, the permutations rho\+\_\+i and rho\+\_\+\{2(m-\/1)-\/i\} permute the i\textquotesingle{}th dimension. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a342c01cce2724537976f9ce808e6b8ec}{poly\+Eval}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ret, N\+T\+L\+::\+Z\+ZX poly, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&x, long k=0)
\begin{DoxyCompactList}\small\item\em Evaluate a cleartext polynomial on an encrypted input. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ad15c89ffe2770b53c9484aa56555bc3f}{poly\+Eval}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ret, const N\+T\+L\+::\+Vec$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&poly, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&x)
\begin{DoxyCompactList}\small\item\em Evaluate an encrypted polynomial on an encrypted input. \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a546b744efbb3ba1575148bcb9e2ba724}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&e)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_aa6bfd95691bb88ca7ee135b5ad074f4d}{operator$>$$>$}} (std\+::istream \&s, \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&e)
\item 
void \mbox{\hyperlink{namespacehelib_a39d92caff425c0086a87a667c88003d4}{write}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&e)
\item 
void \mbox{\hyperlink{namespacehelib_ac5197bb5b6cad37f9d4a4a7c7e7bf8d0}{read}} (std\+::istream \&s, \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&e)
\item 
{\footnotesize template$<$typename T $>$ }\\long \mbox{\hyperlink{namespacehelib_a1d7c647ab302e0d9844b52884e086071}{lsize}} (const \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a65519409bc5c0f7c328147d8664ce5fb}{resize}} (\mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$ T $>$ \&v, long new\+Size)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a5c0a4656214afc3e52fa83408be3ff6a}{set\+Length\+Zero}} (\mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\const T $\ast$ \mbox{\hyperlink{namespacehelib_ab33a07f0cc97da66e279f71195515763}{ptr2non\+Null}} (std\+::initializer\+\_\+list$<$ const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ $\ast$ $>$ list)
\item 
{\footnotesize template$<$typename T $>$ }\\long \mbox{\hyperlink{namespacehelib_a368a1406fcc81e32dce3caebda60477b}{lsize}} (const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a030064c52dceba94106ffbd8afb564ef}{set\+Length\+Zero}} (\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a810f01874466a0f57b41f96b8cb7a96c}{resize}} (\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v, long new\+Size, const T \&val)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a6a1574e2c95b30b1eb204d669f029368}{resize}} (\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v, long new\+Size, const T $\ast$val)
\item 
{\footnotesize template$<$typename V1 , typename V2 $>$ }\\void \mbox{\hyperlink{namespacehelib_a03ca08051d06a786cf812e238a0cad15}{vec\+Copy}} (V1 \&v1, const V2 \&v2, long size\+Limit=0)
\item 
{\footnotesize template$<$typename V , typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_aa4d8218e2c0fee25ebec6d40d2a6036d}{vec\+Copy}} (V \&v1, const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v2, long size\+Limit=0)
\item 
{\footnotesize template$<$typename V , typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a7dd2ecf9ca1ddd7c2e7372fb8999030d}{vec\+Copy}} (\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v1, const V \&v2, long size\+Limit=0)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_a2b1de5f6a3cb9f9da27cd496659cc899}{vec\+Copy}} (\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v1, const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&v2, long size\+Limit=0)
\item 
{\footnotesize template$<$typename From , typename Scheme $>$ }\\std\+::vector$<$ typename Scheme\+::\+Slot\+Type $>$ \mbox{\hyperlink{namespacehelib_ae05ae4d1e5789165fa5fe70824e87077}{convert\+Data\+To\+Slot\+Vector}} (const std\+::vector$<$ From $>$ \&data, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\begin{DoxyCompactList}\small\item\em Converts {\ttfamily std\+::vector$<$From$>$} to {\ttfamily std\+::vector$<$Scheme\+::\+Slot\+Type$>$}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scheme $>$ }\\void \mbox{\hyperlink{namespacehelib_a98d0e8b458fb8f75fa79ff7c7effe58e}{inner\+Product}} (\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&result, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$$>$ \&first\+\_\+vec, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$$>$ \&second\+\_\+vec)
\begin{DoxyCompactList}\small\item\em Free function that computes the inner product of two vectors of {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aa69f30064b062723cecac335a73fdcdd}{deserialize}} (std\+::istream \&is, std\+::complex$<$ double $>$ \&num)
\begin{DoxyCompactList}\small\item\em Deserialize a {\ttfamily std\+::complex$<$double$>$} from the input stream {\ttfamily is} delimited by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{} (instead of the default \textquotesingle{}(\textquotesingle{}, \textquotesingle{})\textquotesingle{}). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_adcb4ae8ef54886b93b4639999a620630}{serialize}} (std\+::ostream \&os, const std\+::complex$<$ double $>$ \&num)
\begin{DoxyCompactList}\small\item\em Serialize a {\ttfamily std\+::complex$<$double$>$} to the output stream {\ttfamily os} delimited by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{} (instead of the default \textquotesingle{}(\textquotesingle{}, \textquotesingle{})\textquotesingle{}). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scheme $>$ }\\void \mbox{\hyperlink{namespacehelib_a9b41101191111377485d5adf5c4693c1}{deserialize}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&ptxt)
\begin{DoxyCompactList}\small\item\em Function to deserialize a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$Scheme$>$}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scheme $>$ }\\void \mbox{\hyperlink{namespacehelib_ab41ed1eb42cb018a129e7cb2fbbb29ff}{serialize}} (std\+::ostream \&os, const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&ptxt)
\begin{DoxyCompactList}\small\item\em Function to serialize a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$Scheme$>$}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scheme $>$ }\\std\+::istream \& \mbox{\hyperlink{namespacehelib_abc2e5c3ec63886e4fbb71a7ed16f4a9b}{operator$>$$>$}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&ptxt)
\begin{DoxyCompactList}\small\item\em Input shift operator. Uses the {\ttfamily deserialize} function internally. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scheme $>$ }\\std\+::ostream \& \mbox{\hyperlink{namespacehelib_af8df733be35482f6834a083a9de5e4a6}{operator$<$$<$}} (std\+::ostream \&is, const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&ptxt)
\begin{DoxyCompactList}\small\item\em Output shift operator. Uses the {\ttfamily serialize} function internally. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhelib_1_1_mat_mul1_d}{Mat\+Mul1D}} $\ast$ \mbox{\hyperlink{namespacehelib_ac6dcd30d8cce97ee562725b5c096b464}{build\+Random\+Matrix}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, long dim)
\item 
\mbox{\hyperlink{classhelib_1_1_mat_mul1_d}{Mat\+Mul1D}} $\ast$ \mbox{\hyperlink{namespacehelib_a3080cc6971659bc69c9c758f42300cb9}{build\+Random\+Multi\+Matrix}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, long dim)
\item 
\mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d}{Block\+Mat\+Mul1D}} $\ast$ \mbox{\hyperlink{namespacehelib_aa512e08a2be7acf51509eb138d53f819}{build\+Random\+Block\+Matrix}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, long dim)
\item 
\mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d}{Block\+Mat\+Mul1D}} $\ast$ \mbox{\hyperlink{namespacehelib_a3f720bf0e8e389648203490dd91630ec}{build\+Random\+Multi\+Block\+Matrix}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, long dim)
\item 
\mbox{\hyperlink{classhelib_1_1_mat_mul_full}{Mat\+Mul\+Full}} $\ast$ \mbox{\hyperlink{namespacehelib_afb1a434a5001c49cfce898915c2faa51}{build\+Random\+Full\+Matrix}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
\mbox{\hyperlink{classhelib_1_1_block_mat_mul_full}{Block\+Mat\+Mul\+Full}} $\ast$ \mbox{\hyperlink{namespacehelib_a40abf9db3a61a5c21c6f836acbeb8c80}{build\+Random\+Full\+Block\+Matrix}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
\mbox{\hyperlink{classhelib_1_1general__range}{general\+\_\+range}}$<$ long $>$ \mbox{\hyperlink{namespacehelib_a5dcff6470686ad80a2319fa1652ac1e3}{range}} (long n)
\item 
\mbox{\hyperlink{classhelib_1_1general__range}{general\+\_\+range}}$<$ long $>$ \mbox{\hyperlink{namespacehelib_ae4c6fd54cca700ce3a8beca19bf0ceaa}{range}} (long m, long n)
\item 
void \mbox{\hyperlink{namespacehelib_a28bebe2d214c86938103f34adecb7ff3}{replicate}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctx, long pos)
\begin{DoxyCompactList}\small\item\em The value in slot \#pos is replicated in all other slots. On an n-\/slot ciphertext, this algorithm performs O(log n) 1D rotations. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_adb07910b30bab32f4ebf91af705e3c6d}{replicate0}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long pos)
\begin{DoxyCompactList}\small\item\em A lower-\/level routine. Same as replicate, but assumes all slots are zero except slot \#pos. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a55f84fcea62365a27445739f444d81db}{replicate\+All}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, \mbox{\hyperlink{classhelib_1_1_replicate_handler}{Replicate\+Handler}} $\ast$handler, long rec\+Bound=64, Rep\+Aux\+Dim $\ast$rep\+Aux\+Ptr=nullptr)
\item 
void \mbox{\hyperlink{namespacehelib_ab0a2f3a3e50d07abc0a16161003fc0b5}{replicate\+All}} (std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long rec\+Bound=64, Rep\+Aux\+Dim $\ast$rep\+Aux\+Ptr=nullptr)
\item 
{\footnotesize template$<$typename Scheme $>$ }\\void \mbox{\hyperlink{namespacehelib_a80787c8857d1d8b8b4fad63f11201626}{replicate\+All}} (std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$$>$ \&v, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&, const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&ptxt)
\begin{DoxyCompactList}\small\item\em Generate a vector of plaintexts with each slot replicated in each plaintext. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_ae12fb4b6143d8e2cb6a5dbf36922fbe7}{replicate\+All\+Orig}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, \mbox{\hyperlink{classhelib_1_1_replicate_handler}{Replicate\+Handler}} $\ast$handler, Rep\+Aux $\ast$rep\+Aux\+Ptr=nullptr)
\item 
void \mbox{\hyperlink{namespacehelib_a2c6d6a64a8c538bb0189ac908896ac6c}{replicate}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa, long i)
\item 
{\footnotesize template$<$typename Scheme $>$ }\\void \mbox{\hyperlink{namespacehelib_ae14f023af8c881464a3dbaf01b18d7da}{replicate}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&ptxt, long i)
\begin{DoxyCompactList}\small\item\em Replicate single slot of a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object across all of its slots. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_abc5ec6f6ac945f2c5bcdf04fb7bcf0a9}{sample\+Small}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, long n, double prob=0.\+5)
\item 
void \mbox{\hyperlink{namespacehelib_a7aab1a9871644fc36223b8009290ef66}{sample\+Small}} (N\+T\+L\+::\+Z\+ZX \&poly, long n, double prob=0.\+5)
\item 
void \mbox{\hyperlink{namespacehelib_a3cebf12977a97396ba96bdc5fe8162e7}{sample\+H\+Wt}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, long n, long Hwt=100)
\begin{DoxyCompactList}\small\item\em Sample a degree-\/(n-\/1) poly as above, with only Hwt nonzero coefficients. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aa510a5dd7033e859ab4e6759a1b1b207}{sample\+H\+Wt}} (N\+T\+L\+::\+Z\+ZX \&poly, long n, long Hwt=100)
\item 
void \mbox{\hyperlink{namespacehelib_a9ca8304d01fccbbac9264eee5d5a24cb}{sample\+Gaussian}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, long n, double stdev)
\begin{DoxyCompactList}\small\item\em Sample polynomials with Gaussian coefficients. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a6d1e9c8e38d8a8f73b315b2cf874cebe}{sample\+Gaussian}} (N\+T\+L\+::\+Z\+ZX \&poly, long n, double stdev)
\item 
void \mbox{\hyperlink{namespacehelib_a7b922617fd57c98218c1eada9ffb9cb5}{sample\+Uniform}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, long n, long B=100)
\begin{DoxyCompactList}\small\item\em Sample a degree-\/(n-\/1) Z\+ZX, with coefficients uniform in \mbox{[}-\/B,B\mbox{]}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a2882109801afa606ee6ec39f6fd48348}{sample\+Uniform}} (N\+T\+L\+::\+Z\+ZX \&poly, long n, const N\+T\+L\+::\+ZZ \&B=N\+T\+L\+::\+ZZ(100L))
\item 
void \mbox{\hyperlink{namespacehelib_adccfccbd4c008360cc40afa2fa8bc3ad}{sample\+Gaussian}} (std\+::vector$<$ double $>$ \&dvec, long n, double stdev)
\begin{DoxyCompactList}\small\item\em Choose a vector of continuous Gaussians. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacehelib_af97518f36b0358f1f178ce85e51c5d82}{sample\+H\+Wt}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, long Hwt=100)
\item 
double \mbox{\hyperlink{namespacehelib_ae703021ed961c9a45e32d09c4b965781}{sample\+H\+Wt\+Bounded}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, long Hwt=100)
\item 
double \mbox{\hyperlink{namespacehelib_a8e75ae20952ceae0b4e92034d7128457}{sample\+H\+Wt\+Bounded\+Effective\+Bound}} (const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, long Hwt=100)
\item 
double \mbox{\hyperlink{namespacehelib_aa20a241c380919c47e8375ac01d61187}{sample\+Small}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
double \mbox{\hyperlink{namespacehelib_a50866077cb1daad6200cd8b374613539}{sample\+Small\+Bounded}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
double \mbox{\hyperlink{namespacehelib_a1d8ea79ceef3847786a1f9422fc011e7}{sample\+Gaussian}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, double stdev)
\item 
double \mbox{\hyperlink{namespacehelib_abc2cb417d4cb136fe2f25fea08aaff16}{sample\+Gaussian\+Bounded}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, double stdev)
\item 
double \mbox{\hyperlink{namespacehelib_aa21875fc9b1d3c8dad59e1c3f66f0718}{sample\+Uniform}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, long B=100)
\item 
N\+T\+L\+::xdouble \mbox{\hyperlink{namespacehelib_a5c90da3ab82439eb3574afc268f88050}{sample\+Uniform}} (N\+T\+L\+::\+Z\+ZX \&poly, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context, const N\+T\+L\+::\+ZZ \&B=N\+T\+L\+::\+ZZ(100L))
\item 
void \mbox{\hyperlink{namespacehelib_a7afc81441c478d7cd4749a69cbccc984}{reduce\+Mod\+PhimX}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&poly, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
const N\+T\+L\+::zz\+\_\+p\+X\+Modulus \& \mbox{\hyperlink{namespacehelib_ab0fdf54d28eb816a5a395b7e1e1efe51}{get\+Phim\+X\+Mod}} (const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
{\footnotesize template$<$typename T\+XT $>$ }\\void \mbox{\hyperlink{namespacehelib_aa51c5cbd9691dfde759a98c2d7b48542}{bin\+Sum\+Reduction}} (std\+::vector$<$ T\+XT $>$ \&ctxt\+Array)
\begin{DoxyCompactList}\small\item\em Performs a binary summation of a vector of elements. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+XT $>$ }\\T\+XT \mbox{\hyperlink{namespacehelib_a11746f6a5bcf33d5667cfaae083f3e35}{calculate\+Set\+Intersection}} (const T\+XT \&query, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&server\+\_\+set)
\begin{DoxyCompactList}\small\item\em Given two sets, calculates and returns the set intersection. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aa13b0418c17fe6b26a2006507d2b57ac}{compute\+All\+Products}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&products, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&array, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\item 
void \mbox{\hyperlink{namespacehelib_a57a5ec00207d3ca4206aaa810e04dc5f}{table\+Lookup}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&out, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&table, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&idx, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\item 
void \mbox{\hyperlink{namespacehelib_a5c931bc04df2c12ffb4e48ae6eb7b404}{table\+Write\+In}} (const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&table, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&idx, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding=nullptr)
\item 
void \mbox{\hyperlink{namespacehelib_add048fff3de003ad2b670a9ae3ed6f2b}{build\+Lookup\+Table}} (std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&T, std\+::function$<$ double(double)$>$ f, long nbits\+\_\+in, long scale\+\_\+in, long sign\+\_\+in, long nbits\+\_\+out, long scale\+\_\+out, long sign\+\_\+out, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\begin{DoxyCompactList}\small\item\em Built a table-\/lookup for a function in fixed-\/point representation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a7957fca02eb250ab71f07ae1e03f4f5c}{register\+Timer}} (\mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$timer)
\item 
unsigned long \mbox{\hyperlink{namespacehelib_a73d5dae8af9bd253bc591ea37db51a58}{Get\+Timer\+Clock}} ()
\item 
void \mbox{\hyperlink{namespacehelib_a84fe94a9675113ebaf52d87806572cf8}{set\+Timers\+On}} ()
\item 
void \mbox{\hyperlink{namespacehelib_a4672b8f7cb141fc61055c0ccf5f09e56}{set\+Timers\+Off}} ()
\item 
bool \mbox{\hyperlink{namespacehelib_ad94c1a39dcabf4a83066a2908a02e274}{are\+Timers\+On}} ()
\item 
const \mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$ \mbox{\hyperlink{namespacehelib_ad19aadcc92555c2f4dbb3b3b34ae6633}{get\+Timer\+By\+Name}} (const char $\ast$name)
\item 
void \mbox{\hyperlink{namespacehelib_a3203575203906fc8b66bef7fe7a577cd}{reset\+All\+Timers}} ()
\item 
void \mbox{\hyperlink{namespacehelib_a2a544a973c30afed0df368cda6e0ad9e}{print\+All\+Timers}} (std\+::ostream \&str=std\+::cerr)
\begin{DoxyCompactList}\small\item\em Print the value of all timers to stream. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_a0def7d8004a69413ec72c12f1b2bdfe2}{print\+Named\+Timer}} (std\+::ostream \&str, const char $\ast$name)
\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{namespacehelib_a85715fb3484281444706eba875bfbe72}{zero\+Value}} (const T \&x)
\begin{DoxyCompactList}\small\item\em Given an object {\ttfamily x} return a zero object of the same type. \end{DoxyCompactList}\item 
template$<$$>$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \mbox{\hyperlink{namespacehelib_a25a05627840d03ffb2f39269ad6323c7}{zero\+Value$<$ Ctxt $>$}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&x)
\begin{DoxyCompactList}\small\item\em Given a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}} return a zero object of the same type. \end{DoxyCompactList}\item 
template$<$$>$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \mbox{\hyperlink{namespacehelib_af1fa7c571ab911c358c2a01fcbcf3f11}{zero\+Value$<$ Ptxt$<$ B\+G\+V $>$ $>$}} (const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&x)
\begin{DoxyCompactList}\small\item\em Given a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}$>$} return a zero object of the same type. \end{DoxyCompactList}\item 
template$<$$>$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \mbox{\hyperlink{namespacehelib_aa549403e89c301d7e2e4fa39a07dda0b}{zero\+Value$<$ Ptxt$<$ C\+K\+K\+S $>$ $>$}} (const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&x)
\begin{DoxyCompactList}\small\item\em Given a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}$>$} return a zero object of the same type. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacehelib_adaf92545afe42e1f4810b40c9e455af2}{Is\+Zero}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a)
\item 
void \mbox{\hyperlink{namespacehelib_ada22455ae91e6bacc49e719536a8c5da}{clear}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a)
\item 
void \mbox{\hyperlink{namespacehelib_a4d6406c9fda9c55cde649bc033ad7317}{convert}} (N\+T\+L\+::zz\+\_\+pX \&x, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a)
\item 
void \mbox{\hyperlink{namespacehelib_aa160e775ba4dcac09cec20c2febb5de2}{add}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&res, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&b)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \mbox{\hyperlink{namespacehelib_a0efa98b2b2f5303eee2c106240c17b11}{operator+}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&b)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \& \mbox{\hyperlink{namespacehelib_ac1a8de3a0f340ce6a600fa1da2233191}{operator+=}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&b)
\item 
void \mbox{\hyperlink{namespacehelib_acbe210bf717f8ba00aca5995fb479593}{div}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&res, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, long b)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \mbox{\hyperlink{namespacehelib_a70e5cb71e5ab89ad99c81b175ed126cd}{operator/}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, long b)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \& \mbox{\hyperlink{namespacehelib_a7dbb01a7d1b26b95c0abff58d28bdb0e}{operator/=}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, long b)
\item 
void \mbox{\hyperlink{namespacehelib_ac8f88c1ce38bfe194b79c6fff9842e3a}{mul}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&res, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, long b)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \mbox{\hyperlink{namespacehelib_a426440bf36745c2e46ae9826ca70724c}{operator$\ast$}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, long b)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \& \mbox{\hyperlink{namespacehelib_a2526335487a72bde255cc7a916f9736f}{operator$\ast$=}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, long b)
\item 
void \mbox{\hyperlink{namespacehelib_ac285b2405b33a6bf1d27953c5bb89e61}{normalize}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&f)
\item 
void \mbox{\hyperlink{namespacehelib_af65e2fcd58de0be9a17f875701fec9e3}{Mul\+Mod}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&res, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&b, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \mbox{\hyperlink{namespacehelib_ab7f0968146827a1378c640d201604a02}{Mul\+Mod}} (const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&b, const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \mbox{\hyperlink{namespacehelib_a7b1aa9d391c181e780742a2117e9af78}{balanced\+\_\+zzX}} (const N\+T\+L\+::zz\+\_\+pX \&f)
\item 
\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \mbox{\hyperlink{namespacehelib_a508dcf9321109128c609e466a3e33181}{balanced\+\_\+zzX}} (const N\+T\+L\+::\+G\+F2X \&f)
\item 
long \mbox{\hyperlink{namespacehelib_aa19a69725c1500ca956f0a89dd7226e8}{default\+Pmiddle}} (long delta)
\item 
long \mbox{\hyperlink{namespacehelib_a7ae485ed628fe5d0b73b7fc80efcfb36}{default\+Qmiddle}} (long delta)
\item 
void \mbox{\hyperlink{namespacehelib_a3ec4c5776cc1a48bb6d6a3ae4e64a4b7}{running\+Sums}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&v)
\item 
void \mbox{\hyperlink{namespacehelib_aa6a682bb0c0c84f0d6eaddde8fd2f8b9}{compare\+Two\+Numbers\+Implementation}} (\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&max, \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&min, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&mu, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ni, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&aa, const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&bb, bool twos\+Complement, std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$unpack\+Slot\+Encoding, bool cmp\+\_\+only)
\item 
void \mbox{\hyperlink{namespacehelib_a76f968f2ead15d0f33947d7f1bc165f5}{Bluestein\+F\+FT}} (N\+T\+L\+::zz\+\_\+pX \&x, long n, U\+N\+U\+S\+ED const N\+T\+L\+::zz\+\_\+p \&root, const N\+T\+L\+::zz\+\_\+pX \&powers, const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::mulmod\+\_\+precon\+\_\+t $>$ \&powers\+\_\+aux, const N\+T\+L\+::fft\+Rep \&Rb)
\item 
N\+T\+L\+::zz\+\_\+p\+Context \mbox{\hyperlink{namespacehelib_af02b70fdba8bb78c1f19964759f497b5}{Build\+Context}} (long p, long maxroot)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a6c8dd31cc08df15a8e5925a06eae00de}{operator$<$$<$}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_a2051c31f2618de7d4cd905020cba5ad4}{operator$>$$>$}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_a5711697a702a0f5c4351b3be5644591f}{getG}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_aac13602434c22102de26465c49856eeb}{add\+Some\+Primes}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&c)
\item 
void \mbox{\hyperlink{namespacehelib_abf8bfb70b1212c781ee1c510a2f456cf}{compute\+Interval\+For\+Mul}} (double \&lo, double \&hi, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt1, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt2)
\item 
void \mbox{\hyperlink{namespacehelib_a9e5b39e20fa9f25946cbd4f0064c32a1}{compute\+Interval\+For\+Sqr}} (double \&lo, double \&hi, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_ae22055624d2a4b9a21d1ff101f7eac03}{operator$>$$>$}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} \&handle)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_ac6e1a9de8dac4a717ec046b76d4d9381}{operator$<$$<$}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_ade316a04cccc9355774eff8e6c013278}{operator$>$$>$}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt)
\item 
double \mbox{\hyperlink{namespacehelib_a07a78ea9ad3d9a0793325a14262965f5}{log2\+\_\+real\+To\+Estimated\+Noise}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_ae695d0fc0099e58790b874885c563efd}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Add\+Fun $>$}} (const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&other, Add\+Fun fun, bool match\+Index\+Sets)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_ae3db7c0c4fd741adba512c54bc7c3ee4}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Sub\+Fun $>$}} (const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&other, Sub\+Fun fun, bool match\+Index\+Sets)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_ae75ba76e26d04df9d1a9fca73d3a718b}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Mul\+Fun $>$}} (const N\+T\+L\+::\+ZZ \&num, Mul\+Fun fun)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_ab878e7e7e17b6d6caf65e7f289965e28}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Add\+Fun $>$}} (const N\+T\+L\+::\+ZZ \&num, Add\+Fun fun)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_a3891679919f78713c9067c3ae9f9ad0c}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Sub\+Fun $>$}} (const N\+T\+L\+::\+ZZ \&num, Sub\+Fun fun)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_a6a6290cf4257cb23cf95aa5c354c46e6}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Mul\+Fun $>$}} (const N\+T\+L\+::\+Z\+ZX \&poly, Mul\+Fun fun)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_ad523a1ce005b9562e1574d19f8ce7936}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Add\+Fun $>$}} (const N\+T\+L\+::\+Z\+ZX \&poly, Add\+Fun fun)
\item 
template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \& \mbox{\hyperlink{namespacehelib_adcba19e19a8aae778a080d8a4833f2d1}{Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Sub\+Fun $>$}} (const N\+T\+L\+::\+Z\+ZX \&poly, Sub\+Fun fun)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_ad05fd6e657aa88416b97a48fb5112d8a}{operator$<$$<$}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&d)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_ab5ebb5536c5ee682d8490d2eac03f6ef}{operator$>$$>$}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&d)
\item 
void \mbox{\hyperlink{namespacehelib_af72790276847439369c96063c3cdc803}{total\+Sums}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt)
\item 
void \mbox{\hyperlink{namespacehelib_a583abeb8ab8021559fb519621b42c3d7}{apply\+Lin\+Poly1}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&C)
\item 
void \mbox{\hyperlink{namespacehelib_aa8e520a1528ee0d150a9818c7ddc4850}{apply\+Lin\+Poly\+Many}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const std\+::vector$<$ std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$$>$ \&Cvec)
\item 
{\footnotesize template$<$typename P $>$ }\\void \mbox{\hyperlink{namespacehelib_a21457a6ed2a6de2701b394bfcc90be1e}{apply\+Lin\+Poly\+LL}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const std\+::vector$<$ P $>$ \&encodedC, long d)
\item 
template void \mbox{\hyperlink{namespacehelib_a0bc9fd386812fdc5f5067522dc4ceced}{apply\+Lin\+Poly\+LL}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&encodedC, long d)
\item 
template void \mbox{\hyperlink{namespacehelib_a896039fe9d2b2bda45cf62d278e52a5f}{apply\+Lin\+Poly\+LL}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&encodedC, long d)
\item 
template void \mbox{\hyperlink{namespacehelib_a9f6f5e7fb2a932db709cbb632e644a81}{apply\+Lin\+Poly\+LL}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \&encodedC, long d)
\item 
void \mbox{\hyperlink{namespacehelib_a8bdc2438d837bb24ddb0dc0ba0a859cc}{print}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&pa)
\item 
void \mbox{\hyperlink{namespacehelib_a4d0fb010c5631535fe448caabc974860}{map\+To01}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt)
\item 
{\footnotesize template$<$typename Scheme $>$ }\\void \mbox{\hyperlink{namespacehelib_a80f9aef0e58c5e559789b25355c64717}{map\+To01}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&ptxt)
\item 
template void \mbox{\hyperlink{namespacehelib_a6ec750de20965b96fdc12370f8222f15}{map\+To01}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&ptxt)
\item 
template void \mbox{\hyperlink{namespacehelib_ab7e150be3c72dc211544b82bd1250376}{map\+To01}} (const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&ptxt)
\item 
void \mbox{\hyperlink{namespacehelib_a028abbe1151a190d5f4ff23bd3a29c3a}{fast\+Power}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long d)
\item 
void \mbox{\hyperlink{namespacehelib_ab42c58780be6927575c8548d842f47b9}{incremental\+Zero\+Test}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $\ast$res\mbox{[}$\,$\mbox{]}, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long n)
\item 
void \mbox{\hyperlink{namespacehelib_a9d5bff694c1cfdb4a55a02f01aa27ce7}{Relaxed\+Inv}} (N\+T\+L\+::\+Mat$<$ N\+T\+L\+::zz\+\_\+p $>$ \&x, const N\+T\+L\+::\+Mat$<$ N\+T\+L\+::zz\+\_\+p $>$ \&a)
\item 
void \mbox{\hyperlink{namespacehelib_a99839e8493aba44c6de4085217a4edc6}{Relaxed\+Inv}} (N\+T\+L\+::\+Mat$<$ N\+T\+L\+::\+G\+F2 $>$ \&x, const N\+T\+L\+::\+Mat$<$ N\+T\+L\+::\+G\+F2 $>$ \&a)
\item 
void \mbox{\hyperlink{namespacehelib_a445beffa0d612929f2237315b80d494b}{Trace\+Map}} (N\+T\+L\+::\+G\+F2X \&w, const N\+T\+L\+::\+G\+F2X \&a, long d, const N\+T\+L\+::\+G\+F2\+X\+Modulus \&F, const N\+T\+L\+::\+G\+F2X \&b)
\item 
template void \mbox{\hyperlink{namespacehelib_ad24ba24d435ed51afa0737dddfc01bb2}{get\+Hyper\+Column}} (N\+T\+L\+::\+Vec$<$ long $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_const_cube_slice}{Const\+Cube\+Slice}}$<$ long $>$ \&s, long pos)
\item 
template void \mbox{\hyperlink{namespacehelib_adcd8aedd768d6294cf41cd0c32b48b7d}{set\+Hyper\+Column}} (const N\+T\+L\+::\+Vec$<$ long $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ long $>$ \&s, long pos)
\item 
template void \mbox{\hyperlink{namespacehelib_a5926b1368764799c58fbbedb10704593}{set\+Hyper\+Column}} (const N\+T\+L\+::\+Vec$<$ long $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ long $>$ \&s, long pos, const long \&val)
\item 
template void \mbox{\hyperlink{namespacehelib_a90f4cdaad8d1b3eba56f013ad96e0d49}{print3D}} (const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ long $>$ \&c)
\item 
template void \mbox{\hyperlink{namespacehelib_adb40b60558125630cb15e09a63906c2e}{get\+Hyper\+Column}} (N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_const_cube_slice}{Const\+Cube\+Slice}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&s, long pos)
\item 
template void \mbox{\hyperlink{namespacehelib_ada3f2a2d4e46f0069338139732ca4113}{set\+Hyper\+Column}} (const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&s, long pos)
\item 
template void \mbox{\hyperlink{namespacehelib_ab90fa0fa3007a94813b26131c7ae3a1d}{set\+Hyper\+Column}} (const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&v, const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&s, long pos, const N\+T\+L\+::zz\+\_\+p \&val)
\item 
template void \mbox{\hyperlink{namespacehelib_a518fab30f484391dbbc23fa0ddfdc2bf}{print3D}} (const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&c)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a794976b9b52689a77c7895c58ffd65da}{operator$<$$<$}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&pk)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_a97c53db90234d3f191cf4887f2bb8c2c}{operator$>$$>$}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&pk)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a1777b65a3298c49a20e8554bc70a2cd1}{operator$<$$<$}} (std\+::ostream \&str, const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_a658c0331d08e78e757984e06107f75f0}{operator$>$$>$}} (std\+::istream \&str, \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&sk)
\item 
void \mbox{\hyperlink{namespacehelib_a8da295dc142953405e0a3e30509df973}{print\+Flow}} (\mbox{\hyperlink{namespacehelib_af547f7016fc73b7174a2018ea28ef298}{Flow\+Graph}} \&fg)
\item 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_general_automorph_precon}{General\+Automorph\+Precon}} $>$ \mbox{\hyperlink{namespacehelib_a7acbf567c5271c1d20df20c6f4fa1714}{build\+General\+Automorph\+Precon}} (const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long dim, const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&ea)
\item 
{\footnotesize template$<$typename RX $>$ }\\std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}} $>$ \mbox{\hyperlink{namespacehelib_ae5435c81f125b4a3b2fddf126601aed2}{build\+\_\+\+Const\+Multiplier}} (const RX \&poly)
\item 
{\footnotesize template$<$typename RX , typename type $>$ }\\std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}} $>$ \mbox{\hyperlink{namespacehelib_a34b18eda7cc825761797b906e47f9074}{build\+\_\+\+Const\+Multiplier}} (const RX \&poly, long dim, long amt, const \mbox{\hyperlink{classhelib_1_1_encrypted_array_derived}{Encrypted\+Array\+Derived}}$<$ type $>$ \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_a408eff115fb052630554303601257388}{Mul\+Add}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&x, const std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}} $>$ \&a, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&b)
\item 
void \mbox{\hyperlink{namespacehelib_a90b78436c866a0477b9b2957a50bb119}{Dest\+Mul\+Add}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&x, const std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}} $>$ \&a, \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&b)
\item 
void \mbox{\hyperlink{namespacehelib_ac405b201e920430c5995a7408e08e99d}{plaintext\+Automorph\+\_\+\+C\+K\+KS}} (\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&b, const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&a, long j, const \mbox{\hyperlink{classhelib_1_1_encrypted_array_cx}{Encrypted\+Array\+Cx}} \&ea)
\item 
void \mbox{\hyperlink{namespacehelib_ac78c4e23cc87c6109c26c3cf86fd1dd0}{Gen\+Baby\+Steps}} (std\+::vector$<$ std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$$>$ \&v, const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long dim, bool clean)
\item 
{\footnotesize template$<$typename zp , typename zz $>$ }\\void \mbox{\hyperlink{namespacehelib_adcf094f13d09fba535a0ac173449843f}{Find\+Prim\+RootT}} (zp \&root, unsigned long e)
\item 
template bool \mbox{\hyperlink{namespacehelib_a0dae2334b1ae6358865ee8fd0c6a8fc6}{int\+Vec\+C\+RT}} (N\+T\+L\+::vec\+\_\+\+ZZ \&, const N\+T\+L\+::\+ZZ \&, const N\+T\+L\+::vec\+\_\+\+ZZ \&, long)
\item 
template bool \mbox{\hyperlink{namespacehelib_ae3781935233076f4d0110d4c7a358ccf}{int\+Vec\+C\+RT}} (N\+T\+L\+::vec\+\_\+\+ZZ \&, const N\+T\+L\+::\+ZZ \&, const N\+T\+L\+::vec\+\_\+long \&, long)
\item 
template bool \mbox{\hyperlink{namespacehelib_a2c41ad906b8626fb07781c8927102b4f}{int\+Vec\+C\+RT}} (N\+T\+L\+::vec\+\_\+\+ZZ \&, const N\+T\+L\+::\+ZZ \&, const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&, long)
\item 
void \mbox{\hyperlink{namespacehelib_a048eb699c3e26a99ac2198bcc984ac75}{remove\+Dups}} (std\+::list$<$ long $>$ \&x, bool $\ast$aux)
\item 
void \mbox{\hyperlink{namespacehelib_a6bcb58c007d8e3cb2a1b4c7d0c162895}{add\+Offset}} (std\+::list$<$ long $>$ \&x, long offset, long n, bool $\ast$aux, U\+N\+U\+S\+ED bool good=false)
\item 
long \mbox{\hyperlink{namespacehelib_a8e4662264ee1fcd34eb7ff13d6bbf008}{reduced\+Count}} (const std\+::list$<$ long $>$ \&x, long n, bool $\ast$aux)
\item 
void \mbox{\hyperlink{namespacehelib_aa7534536bd1101ec60aa4c8fe1ccdf30}{build\+Benes\+Cost\+Table}} (long n, long k, bool good, N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+Vec$<$ long $>$$>$ \&tab)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a1924de36f81ef4338bb2526dd03bfe97}{operator$<$$<$}} (std\+::ostream \&s, Long\+Node\+Ptr p)
\item 
Benes\+Memo\+Entry \mbox{\hyperlink{namespacehelib_a188c595f95739f28a8eaffd5fcc55ffd}{optimal\+Benes\+Aux}} (long i, long budget, long nlev, const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+Vec$<$ long $>$$>$ \&cost\+Tab, Benes\+Memo\+Table \&memo\+Tab)
\item 
void \mbox{\hyperlink{namespacehelib_ab80751b68918a0cba13cb9bab3da12ed}{optimal\+Benes}} (long n, long budget, bool good, long \&cost, Long\+Node\+Ptr \&solution)
\item 
void \mbox{\hyperlink{namespacehelib_a7b924cfad7a9d34755b6175d88a6a207}{print}} (std\+::ostream \&s, Split\+Node\+Ptr p, bool first)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a8407900faf89358e471aef0bdb902da8}{operator$<$$<$}} (std\+::ostream \&s, Split\+Node\+Ptr p)
\item 
long \mbox{\hyperlink{namespacehelib_ac5bd3c856c7b75630a3fee625848debf}{length}} (Gen\+Node\+Ptr ptr)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_acd38c901ef879aa74f5070cdd2b38790}{operator$<$$<$}} (std\+::ostream \&s, Gen\+Node\+Ptr p)
\item 
Lower\+Memo\+Entry \mbox{\hyperlink{namespacehelib_a05a4b7e9cb04f6760740db3d4dc3186d}{optimal\+Lower}} (long order, bool good, long budget, long mid, Lower\+Memo\+Table \&lower\+Memo\+Table)
\item 
Upper\+Memo\+Entry \mbox{\hyperlink{namespacehelib_a6b9b2fbc501abb90f6400679ee15f9aa}{optimal\+Upper\+Aux}} (const N\+T\+L\+::\+Vec$<$ \mbox{\hyperlink{classhelib_1_1_gen_descriptor}{Gen\+Descriptor}} $>$ \&vec, long i, long budget, long mid, Upper\+Memo\+Table \&upper\+Memo\+Table, Lower\+Memo\+Table \&lower\+Memo\+Table)
\item 
{\footnotesize template$<$typename RX $>$ }\\bool \mbox{\hyperlink{namespacehelib_ab77a93b123ead6eef9e6c899afab897c}{poly\+\_\+comp}} (const RX \&a, const RX \&b)
\item 
bool \mbox{\hyperlink{namespacehelib_a0780cab8a4fd2f230bfcc1822814cf06}{less\+\_\+than}} (N\+T\+L\+::\+G\+F2 a, N\+T\+L\+::\+G\+F2 b)
\item 
bool \mbox{\hyperlink{namespacehelib_a507149d174b7d75b1db57d876791fa93}{less\+\_\+than}} (N\+T\+L\+::zz\+\_\+p a, N\+T\+L\+::zz\+\_\+p b)
\item 
bool \mbox{\hyperlink{namespacehelib_acba849e54a054c14527a708b0738735d}{less\+\_\+than}} (const N\+T\+L\+::\+G\+F2X \&a, const N\+T\+L\+::\+G\+F2X \&b)
\item 
bool \mbox{\hyperlink{namespacehelib_a6da437fc5e5b62183567bd8885b5b086}{less\+\_\+than}} (const N\+T\+L\+::zz\+\_\+pX \&a, const N\+T\+L\+::zz\+\_\+pX \&b)
\item 
bool \mbox{\hyperlink{namespacehelib_a592d23357f47db9beb431daa00b1837b}{less\+\_\+than}} (const N\+T\+L\+::\+G\+F2E \&a, const N\+T\+L\+::\+G\+F2E \&b)
\item 
bool \mbox{\hyperlink{namespacehelib_ade745be425656ca6550b68e91647df4d}{less\+\_\+than}} (const N\+T\+L\+::zz\+\_\+pE \&a, const N\+T\+L\+::zz\+\_\+pE \&b)
\item 
bool \mbox{\hyperlink{namespacehelib_a3a95ea63e91091bd7cae299abf5b60e9}{less\+\_\+than}} (const N\+T\+L\+::\+G\+F2\+EX \&a, const N\+T\+L\+::\+G\+F2\+EX \&b)
\item 
bool \mbox{\hyperlink{namespacehelib_a58072d3099fe887b7de62dba4b16a337}{less\+\_\+than}} (const N\+T\+L\+::zz\+\_\+p\+EX \&a, const N\+T\+L\+::zz\+\_\+p\+EX \&b)
\item 
bool \mbox{\hyperlink{namespacehelib_ad733002556086f79ab0153f09916d2be}{compare\+P\+Algebra}} (const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&palg, unsigned long m, unsigned long p, U\+N\+U\+S\+ED unsigned long r, const std\+::vector$<$ long $>$ \&gens, const std\+::vector$<$ long $>$ \&ords)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacehelib_ac531d997cd86bd46ac62c3f7cd5665de}{P\+Algebra\+Lift}} (const N\+T\+L\+::\+Z\+ZX \&phimx, const T \&lfactors, T \&factors, T \&crtc, long r)
\item 
void \mbox{\hyperlink{namespacehelib_abc33dc76f8abeaf3557b98dd5a400922}{E\+DF}} (N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&v, const N\+T\+L\+::zz\+\_\+pX \&f, long d)
\item 
N\+T\+L\+::zz\+\_\+p\+EX \mbox{\hyperlink{namespacehelib_ad0741932e68cabac1a19a68d0a4810bf}{Frobenius\+Map}} (const N\+T\+L\+::zz\+\_\+p\+E\+X\+Modulus \&F)
\item 
void \mbox{\hyperlink{namespacehelib_a7cac9469e49eec3d2bcd9db31e0122f1}{Inv\+Modpr}} (N\+T\+L\+::zz\+\_\+pX \&S, const N\+T\+L\+::zz\+\_\+pX \&F, const N\+T\+L\+::zz\+\_\+pX \&G, long p, long r)
\item 
template$<$$>$ void \mbox{\hyperlink{namespacehelib_aa4c4516b395810588dc11afabdd11b62}{P\+Algebra\+Lift}} (const N\+T\+L\+::\+Z\+ZX \&phimx, const N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&lfactors, N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&factors, N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&crtc, long r)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a16380874c94bf4781b228d986d9882ca}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_perm_network}{Perm\+Network}} \&net)
\item 
template void \mbox{\hyperlink{namespacehelib_a81a1417dec7a02c2dc600a3802cb3102}{apply\+Perm\+To\+Vec$<$ long $>$}} (N\+T\+L\+::\+Vec$<$ long $>$ \&out, const N\+T\+L\+::\+Vec$<$ long $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\item 
template void \mbox{\hyperlink{namespacehelib_a331891be147b33a730e697f3d9e9bc92}{apply\+Perm\+To\+Vec$<$ long $>$}} (std\+::vector$<$ long $>$ \&out, const std\+::vector$<$ long $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\item 
template void \mbox{\hyperlink{namespacehelib_aff1608eb4840762727e4733e2c63b8bb}{apply\+Perm\+To\+Vec$<$ N\+T\+L\+::\+Z\+Z\+X $>$}} (std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&out, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\item 
template void \mbox{\hyperlink{namespacehelib_abe7675aa123a573bc6d687c1421f2308}{apply\+Perms\+To\+Vec$<$ long $>$}} (N\+T\+L\+::\+Vec$<$ long $>$ \&out, const N\+T\+L\+::\+Vec$<$ long $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p2, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\item 
template void \mbox{\hyperlink{namespacehelib_acc4a600c33f24c48a5074b19d9db9d24}{apply\+Perms\+To\+Vec$<$ long $>$}} (std\+::vector$<$ long $>$ \&out, const std\+::vector$<$ long $>$ \&in, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p2, const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&p1)
\item 
void \mbox{\hyperlink{namespacehelib_a060e401ccfa17753d928fb1812fa020f}{break\+Perm\+To3}} (const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ long $>$ \&pi, long dim, \mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} \&rho1, \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ long $>$ \&rho2, \mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} \&rho3)
\item 
void \mbox{\hyperlink{namespacehelib_af1c49d134949a4cf5cc7ef6c0ffa1206}{Compute\+One\+Gen\+Mapping}} (\mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&gen\+Map, const \mbox{\hyperlink{namespacehelib_a22b83b7df1af539c07c804d7888448ce}{One\+Generator\+Tree}} \&T)
\begin{DoxyCompactList}\small\item\em to a single generator tree \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a8794be0244c26078eabc3c5343c86897}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_sub_dimension}{Sub\+Dimension}} \&sd)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a548b26739f763a0bb78c6ca1eec1a3d4}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_generator_trees}{Generator\+Trees}} \&trees)
\item 
void \mbox{\hyperlink{namespacehelib_a511bb2a1c3583d18b858d5362489139c}{deserialize}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&poly)
\item 
void \mbox{\hyperlink{namespacehelib_a1784c6548249c484976efcf52a0416d7}{serialize}} (std\+::ostream \&os, const \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&poly)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_a3a5af20ad95e41b4f1d072aef127abe8}{operator$>$$>$}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&poly)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a8e75bdb938a5f96094db55ea323250d2}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&poly)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_a56cf6e939823e9a136817850ea93c1cb}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{structhelib_1_1_poly_mod_ring}{Poly\+Mod\+Ring}} \&ring)
\item 
void \mbox{\hyperlink{namespacehelib_a5db58bd9f9ec928c07dc95b2bd2aa26b}{compute\+Div\+Vec}} (N\+T\+L\+::\+Vec$<$ long $>$ \&div\+Vec, long m, const N\+T\+L\+::\+Vec$<$ long $>$ \&pow\+Vec)
\item 
void \mbox{\hyperlink{namespacehelib_aacdc9f121e0356fcc0c2d469126da20c}{compute\+Inv\+Vec}} (N\+T\+L\+::\+Vec$<$ long $>$ \&inv\+Vec, const N\+T\+L\+::\+Vec$<$ long $>$ \&div\+Vec, const N\+T\+L\+::\+Vec$<$ long $>$ \&pow\+Vec)
\item 
bool \mbox{\hyperlink{namespacehelib_abf366cbdad4242e525976c1f8664a3fc}{operator$>$}} (const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&a, const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&b)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacehelib_aba72e7396d96094a33df27ad8d11d5d0}{operator$<$$<$}} (std\+::ostream \&s, const \mbox{\hyperlink{classhelib_1_1_moduli_sizes}{Moduli\+Sizes}} \&szs)
\item 
std\+::istream \& \mbox{\hyperlink{namespacehelib_a2d6655763e3378a03fc07dca9178ec44}{operator$>$$>$}} (std\+::istream \&s, \mbox{\hyperlink{classhelib_1_1_moduli_sizes}{Moduli\+Sizes}} \&szs)
\item 
{\footnotesize template$<$typename Scheme $>$ }\\Scheme\+::\+Slot\+Type \mbox{\hyperlink{namespacehelib_afcac17a647635226217c42d858bc155d}{random\+Slot}} (const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
template$<$$>$ \mbox{\hyperlink{structhelib_1_1_b_g_v_a09c79ac9a958d2d2b93c34d89c3ca65b}{B\+G\+V\+::\+Slot\+Type}} \mbox{\hyperlink{namespacehelib_aebcaec251bd8b00a025d3868342fbe85}{random\+Slot$<$ B\+G\+V $>$}} (const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
template$<$$>$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s_a7c8b6e96117c89f9395b2f1ccdc1e0a0}{C\+K\+K\+S\+::\+Slot\+Type}} \mbox{\hyperlink{namespacehelib_a48baf3cc1410cb87bf86a9065dee38a9}{random\+Slot$<$ C\+K\+K\+S $>$}} (U\+N\+U\+S\+ED const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&context)
\item 
template void \mbox{\hyperlink{namespacehelib_a7935d14fb3f04f52a685e6655d12e613}{deserialize$<$ B\+G\+V $>$}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&ptxt)
\item 
template void \mbox{\hyperlink{namespacehelib_a0f0989e95794866905149bd8defaa3f8}{deserialize$<$ C\+K\+K\+S $>$}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&ptxt)
\item 
template void \mbox{\hyperlink{namespacehelib_ad6f0ba91399ca673009e2d72a2c5db8f}{serialize$<$ B\+G\+V $>$}} (std\+::ostream \&os, const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&ptxt)
\item 
template void \mbox{\hyperlink{namespacehelib_a3acb5806f04e3ec63ebef2f1b64fac03}{serialize$<$ C\+K\+K\+S $>$}} (std\+::ostream \&os, const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&ptxt)
\item 
template std\+::istream \& \mbox{\hyperlink{namespacehelib_a12538d07e5bfd87d5705821d3a6fd72d}{operator$>$$>$$<$\+B\+G\+V $>$}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&ptxt)
\item 
template std\+::istream \& \mbox{\hyperlink{namespacehelib_a26590bae1e4d74412c28dd3abbb24b72}{operator$>$$>$$<$\+C\+K\+K\+S $>$}} (std\+::istream \&is, \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&ptxt)
\item 
template std\+::ostream \& \mbox{\hyperlink{namespacehelib_aeb431149ad4752359e90a9559196b71b}{operator$<$$<$$<$\+B\+G\+V $>$}} (std\+::ostream \&os, const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&ptxt)
\item 
template std\+::ostream \& \mbox{\hyperlink{namespacehelib_af69b9423e994641a90a8401f74631180}{operator$<$$<$$<$\+C\+K\+K\+S $>$}} (std\+::ostream \&os, const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&ptxt)
\item 
void \mbox{\hyperlink{namespacehelib_a4a30217f5c0a87bea091193f7dddddc4}{extract\+Digits\+Packed}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long bot\+High, long r, long e\+Prime, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&unpack\+Slot\+Encoding)
\item 
void \mbox{\hyperlink{namespacehelib_ac2b1296539466b880a55d12ea9ac6864}{extract\+Digits\+Thin}} (\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&ctxt, long bot\+High, long r, long e\+Prime)
\item 
double \mbox{\hyperlink{namespacehelib_a5c4cfecd6dc28011302b7b86d15dbaa9}{bound\+Rounding\+Noise}} (U\+N\+U\+S\+ED long m, long phim, long p2r, double epsilon)
\item 
bool \mbox{\hyperlink{namespacehelib_aa50b24ebf9fb1d59089cf974eee2ac90}{timer\+\_\+compare}} (const \mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$a, const \mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$b)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classhelib_1_1_context}{Context}} $\ast$ \mbox{\hyperlink{namespacehelib_a3ba322251033959f95b296f34745836e}{active\+Context}} = nullptr
\item 
\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} $\ast$ \mbox{\hyperlink{namespacehelib_a0d7d15973181b665a33077ca529f9d47}{dbg\+Key}} = nullptr
\item 
std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} $>$ \mbox{\hyperlink{namespacehelib_a1f2eab09fe947de2ae6eb8328937f0bb}{dbg\+Ea}} = nullptr
\item 
N\+T\+L\+::\+Z\+ZX \mbox{\hyperlink{namespacehelib_a11275c94e69653c6ca1c5b3ea8f85dba}{dbg\+\_\+ptxt}}
\item 
bool \mbox{\hyperlink{namespacehelib_a43b6a65490d657b3d2b631fb1fe423e8}{fhe\+\_\+stats}} = false
\item 
\mbox{\hyperlink{classhelib_1_1_logger}{Logger}} \mbox{\hyperlink{namespacehelib_a43d675d13f2fdad48c20753cbf9a611d}{helog}}
\begin{DoxyCompactList}\small\item\em Internal global logger. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespacehelib_a443844fce5e8d1b68b5bbc11d7827836}{fhe\+\_\+test\+\_\+force\+\_\+bsgs}} = 0
\item 
int \mbox{\hyperlink{namespacehelib_a4064daef7469afa9d911c7ba658e9285}{fhe\+\_\+test\+\_\+force\+\_\+hoist}} = 0
\item 
const long double \mbox{\hyperlink{namespacehelib_aa4e11abf6db9206e9dc7ac9397ce28fb}{PI}}
\item 
const double \mbox{\hyperlink{namespacehelib_ac088f2fa765a2ab95c318d60df164b6d}{erfc\+\_\+inverse}} \mbox{[}$\,$\mbox{]}
\item 
long \mbox{\hyperlink{namespacehelib_a6a63df2a7e377c38ac5d33853caff325}{thin\+Recrypt\+\_\+initial\+\_\+level}}
\item 
long \mbox{\hyperlink{namespacehelib_a369c8e1d9a3a6012dba0e881be855ab6}{fhe\+\_\+force\+\_\+chen\+\_\+han}} = 0
\item 
long \mbox{\hyperlink{namespacehelib_a244137dad8f49e984df751ef5d044f4c}{print\+Flag}}
\item 
N\+T\+L\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+L\+O\+C\+AL bool \mbox{\hyperlink{namespacehelib_a47f0fb8de69aa81c6224003a79011ed3}{replicate\+Verbose\+Flag}} = false
\item 
int \mbox{\hyperlink{namespacehelib_a15af59c8cd87bc4a475ed3e1ce577cc7}{fhe\+\_\+watcher}} = 0
\item 
const unsigned long \mbox{\hyperlink{namespacehelib_a562cdbdb456ba0e706002518589d2b1f}{C\+L\+O\+C\+K\+\_\+\+S\+C\+A\+LE}} = (unsigned long)C\+L\+O\+C\+K\+S\+\_\+\+P\+E\+R\+\_\+\+S\+EC
\end{DoxyCompactItemize}
\doxysubsection*{Strategies for generating key-\/switching matrices}
\label{_amgrp7d2878e27d1f99949dac6474bd0f3c5d}%
These functions are implemented in Key\+Switching.\+cpp \begin{DoxyCompactItemize}
\item 
long \mbox{\hyperlink{namespacehelib_a4fb58a793bef4befd9d75d8852d8fc55}{K\+S\+Giant\+Step\+Size}} (long D)
\begin{DoxyCompactList}\small\item\em Function that returns number of baby steps. Used to keep this and matmul routines \char`\"{}in sync\char`\"{}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a4da7a89f85244e58f456a86832c46a27}{add\+All\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\begin{DoxyCompactList}\small\item\em Maximalistic approach\+: generate matrices s(\+X$^\wedge$e)-\/$>$s(\+X) for all e in Zm$\ast$. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_acd7803e7000d31eda4aa3af44bfe0ef0}{add\+Few\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\begin{DoxyCompactList}\small\item\em Generate matrices so every s(\+X$^\wedge$e) can be re\+Linearized in at most two steps. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a3ace8477657e91faeb4c33824bab098d}{add\+Some1\+D\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long bound=H\+E\+L\+I\+B\+\_\+\+K\+E\+Y\+S\+W\+I\+T\+C\+H\+\_\+\+T\+H\+R\+E\+SH, long key\+ID=0)
\begin{DoxyCompactList}\small\item\em Generate some matrices of the form s(X$^\wedge$\{g$^\wedge$i\})-\/$>$s(\+X), but not all. For a generator g whose order is larger than bound, generate only enough matrices for the giant-\/step/baby-\/step procedures (2$\ast$sqrt(ord(g))of them). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a8f3689b135fde2c843eed5ce0813a975}{add1\+D\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\begin{DoxyCompactList}\small\item\em Generate all matrices s(X$^\wedge$\{g$^\wedge$i\})-\/$>$s(\+X) for generators g of Zm$\ast$ /(p) and i$<$ord(g). If g has different orders in Zm$\ast$ and Zm$\ast$ /(p) then generate also matrices of the form s(X$^\wedge$\{g$^\wedge$\{-\/i\}\})-\/$>$s(\+X) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a63d75eed1d12814e2e858ab82e07d311}{add\+B\+S\+G\+S1\+D\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\item 
void \mbox{\hyperlink{namespacehelib_a40b42a155c81c0507222ebca1f0a39f8}{add\+Some\+Frb\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long bound=H\+E\+L\+I\+B\+\_\+\+K\+E\+Y\+S\+W\+I\+T\+C\+H\+\_\+\+T\+H\+R\+E\+SH, long key\+ID=0)
\begin{DoxyCompactList}\small\item\em Generate all/some Frobenius matrices of the form s(X$^\wedge$\{p$^\wedge$i\})-\/$>$s(\+X) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_a62bfda232309a69cc3824e5323345073}{add\+Frb\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\item 
void \mbox{\hyperlink{namespacehelib_af9483c8e129d827f9b49f140a327dd15}{add\+B\+S\+G\+S\+Frb\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\item 
void \mbox{\hyperlink{namespacehelib_a0c3d6b66cd30aed055d9c5a6333eca7c}{add\+Minimal1\+D\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\begin{DoxyCompactList}\small\item\em These routines just add a single matrix (or two, for bad dimensions) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_aa94886e3afbcd49800243fd7fdaedd39}{add\+Minimal\+Frb\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, long key\+ID=0)
\item 
void \mbox{\hyperlink{namespacehelib_a7d420cdf0dc5b6968a8a89809cd5b5f3}{add\+Matrices4\+Network}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, const \mbox{\hyperlink{classhelib_1_1_perm_network}{Perm\+Network}} \&net, long key\+ID=0)
\item 
void \mbox{\hyperlink{namespacehelib_a96c1092ac50c752cc8577da03cf232d4}{add\+These\+Matrices}} (\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&s\+Key, const std\+::set$<$ long $>$ \&autom\+Vals, long key\+ID=0)
\begin{DoxyCompactList}\small\item\em Generate specific key-\/switching matrices, described by the given set. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{namespacehelib_ae977d2527a20cd02ae18841eea99aa2e}{Poly\+Red}} (N\+T\+L\+::\+Z\+ZX \&out, const N\+T\+L\+::\+Z\+ZX \&in, long q, bool abs=false)
\begin{DoxyCompactList}\small\item\em Reduce all the coefficients of a polynomial modulo q. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehelib_acd2078641e9787af3d6acbee6d557dad}{Poly\+Red}} (N\+T\+L\+::\+Z\+ZX \&out, const N\+T\+L\+::\+Z\+ZX \&in, const N\+T\+L\+::\+ZZ \&q, bool abs=false)
\item 
void \mbox{\hyperlink{namespacehelib_aec8847d93fff429651833026b9553e1b}{Poly\+Red}} (N\+T\+L\+::\+Z\+ZX \&F, long q, bool abs=false)
\item 
void \mbox{\hyperlink{namespacehelib_a7ada257cf26f3f2074300fddf5381f11}{Poly\+Red}} (N\+T\+L\+::\+Z\+ZX \&F, const N\+T\+L\+::\+ZZ \&q, bool abs=false)
\item 
void \mbox{\hyperlink{namespacehelib_a9bc3d452674c06b19349e1bfc47cd6bb}{vec\+Red}} (N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&out, const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&in, long q, bool abs)
\item 
void \mbox{\hyperlink{namespacehelib_ae30e7633ce81720d2e73bb8225f82923}{vec\+Red}} (N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&out, const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&in, const N\+T\+L\+::\+ZZ \&q, bool abs)
\end{DoxyCompactItemize}
\doxysubsection*{Some enhanced conversion routines}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{namespacehelib_a877d5bbaf6ad7ef25042c6711e6a6aa2}{convert}} (long \&x1, const N\+T\+L\+::\+G\+F2X \&x2)
\item 
void \mbox{\hyperlink{namespacehelib_ad7d74d8c1673da0da8d2d53a9f56f30a}{convert}} (long \&x1, const N\+T\+L\+::zz\+\_\+pX \&x2)
\item 
void \mbox{\hyperlink{namespacehelib_afea2ca2bb25fb996d1d3544a353d83eb}{convert}} (N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&X, const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&A)
\item 
void \mbox{\hyperlink{namespacehelib_aa20c6011cba88e302d44bb0db4a6e7f8}{convert}} (N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&X, const std\+::vector$<$ std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$$>$ \&A)
\item 
void \mbox{\hyperlink{namespacehelib_af1ec8745473d116541a8b302dfa70fa9}{convert}} (std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&X, const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&A)
\item 
void \mbox{\hyperlink{namespacehelib_a89daf2e69e1e8c09c09311b1430021f4}{convert}} (std\+::vector$<$ std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$$>$ \&X, const N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&A)
\item 
void \mbox{\hyperlink{namespacehelib_a7508506eab50bf677b80d5dc6669c980}{convert}} (N\+T\+L\+::\+Vec$<$ long $>$ \&out, const N\+T\+L\+::\+Z\+ZX \&in)
\item 
void \mbox{\hyperlink{namespacehelib_a1eb539ffd2cd2268861ad793f88f6393}{convert}} (N\+T\+L\+::\+Vec$<$ long $>$ \&out, const N\+T\+L\+::zz\+\_\+pX \&in, bool symmetric=true)
\item 
void \mbox{\hyperlink{namespacehelib_a195d039398c66533aa7a1ba455ffcd4b}{convert}} (N\+T\+L\+::\+Vec$<$ long $>$ \&out, const N\+T\+L\+::\+G\+F2X \&in)
\item 
void \mbox{\hyperlink{namespacehelib_af3ddd5fc2763e981326700c9dcc2e777}{convert}} (N\+T\+L\+::\+Z\+ZX \&out, const N\+T\+L\+::\+Vec$<$ long $>$ \&in)
\item 
void \mbox{\hyperlink{namespacehelib_a4b9c95cba9d0a0f6f4a8220548276003}{convert}} (N\+T\+L\+::\+G\+F2X \&out, const N\+T\+L\+::\+Vec$<$ long $>$ \&in)
\end{DoxyCompactItemize}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{namespacehelib_a60c561d9f496e4d62c96dfab1e5040a4}{bound\+Fresh\+Noise}} (long m, long phim, double sigma, double epsilon=9e-\/13)
\item 
double \mbox{\hyperlink{namespacehelib_a16658952887fd437cdaccb4ec43b5717}{bound\+Rounding\+Noise}} (long m, long phim, long p2r, double epsilon=9e-\/13)
\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{namespacehelib_abd32b2ba6d41fbd5943e40c4371e86a5}\label{namespacehelib_abd32b2ba6d41fbd5943e40c4371e86a5}} 
\index{helib@{helib}!aligned\_vector@{aligned\_vector}}
\index{aligned\_vector@{aligned\_vector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{aligned\_vector}{aligned\_vector}}
{\footnotesize\ttfamily template$<$class T $>$ \\
using \mbox{\hyperlink{namespacehelib_abd32b2ba6d41fbd5943e40c4371e86a5}{helib\+::aligned\+\_\+vector}} = typedef \mbox{\hyperlink{classhelib_1_1_p_g_f_f_t_a618bb04e868985f8159d8063829f1f88}{P\+G\+F\+F\+T\+::aligned\+\_\+vector}}$<$T$>$}

\mbox{\Hypertarget{namespacehelib_a3c94755e338132a41051da4c73f35ae4}\label{namespacehelib_a3c94755e338132a41051da4c73f35ae4}} 
\index{helib@{helib}!cmplx\_t@{cmplx\_t}}
\index{cmplx\_t@{cmplx\_t}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{cmplx\_t}{cmplx\_t}}
{\footnotesize\ttfamily typedef complex$<$double$>$ \mbox{\hyperlink{namespacehelib_a3c94755e338132a41051da4c73f35ae4}{helib\+::cmplx\+\_\+t}}}

\mbox{\Hypertarget{namespacehelib_ac54132076174cf5388da4f1121f4d417}\label{namespacehelib_ac54132076174cf5388da4f1121f4d417}} 
\index{helib@{helib}!CtPtrMat@{CtPtrMat}}
\index{CtPtrMat@{CtPtrMat}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrMat}{CtPtrMat}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{helib\+::\+Ct\+Ptr\+Mat}}}

\mbox{\Hypertarget{namespacehelib_a3985a932f1b51600445c078fc5531d19}\label{namespacehelib_a3985a932f1b51600445c078fc5531d19}} 
\index{helib@{helib}!CtPtrMat\_ptVecCt@{CtPtrMat\_ptVecCt}}
\index{CtPtrMat\_ptVecCt@{CtPtrMat\_ptVecCt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrMat\_ptVecCt}{CtPtrMat\_ptVecCt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix__pt_vec}{Ptr\+Matrix\+\_\+pt\+Vec}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_a3985a932f1b51600445c078fc5531d19}{helib\+::\+Ct\+Ptr\+Mat\+\_\+pt\+Vec\+Ct}}}

\mbox{\Hypertarget{namespacehelib_a2417782a109df301d765fbcdfe6ac1b7}\label{namespacehelib_a2417782a109df301d765fbcdfe6ac1b7}} 
\index{helib@{helib}!CtPtrMat\_ptvectorCt@{CtPtrMat\_ptvectorCt}}
\index{CtPtrMat\_ptvectorCt@{CtPtrMat\_ptvectorCt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrMat\_ptvectorCt}{CtPtrMat\_ptvectorCt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix__ptvector}{Ptr\+Matrix\+\_\+ptvector}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_a2417782a109df301d765fbcdfe6ac1b7}{helib\+::\+Ct\+Ptr\+Mat\+\_\+ptvector\+Ct}}}

\mbox{\Hypertarget{namespacehelib_a536b3dcc07d9bee58c6f52f62118cd53}\label{namespacehelib_a536b3dcc07d9bee58c6f52f62118cd53}} 
\index{helib@{helib}!CtPtrMat\_VecCt@{CtPtrMat\_VecCt}}
\index{CtPtrMat\_VecCt@{CtPtrMat\_VecCt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrMat\_VecCt}{CtPtrMat\_VecCt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix___vec}{Ptr\+Matrix\+\_\+\+Vec}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_a536b3dcc07d9bee58c6f52f62118cd53}{helib\+::\+Ct\+Ptr\+Mat\+\_\+\+Vec\+Ct}}}

\mbox{\Hypertarget{namespacehelib_a2f951b4c929a807f0a369b1aed560c6a}\label{namespacehelib_a2f951b4c929a807f0a369b1aed560c6a}} 
\index{helib@{helib}!CtPtrMat\_vectorCt@{CtPtrMat\_vectorCt}}
\index{CtPtrMat\_vectorCt@{CtPtrMat\_vectorCt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrMat\_vectorCt}{CtPtrMat\_vectorCt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_matrix__vector}{Ptr\+Matrix\+\_\+vector}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_a2f951b4c929a807f0a369b1aed560c6a}{helib\+::\+Ct\+Ptr\+Mat\+\_\+vector\+Ct}}}

\mbox{\Hypertarget{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}\label{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}} 
\index{helib@{helib}!CtPtrs@{CtPtrs}}
\index{CtPtrs@{CtPtrs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrs}{CtPtrs}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{helib\+::\+Ct\+Ptrs}}}

\mbox{\Hypertarget{namespacehelib_afddae64ffeb6698a0b2a5214ab66273b}\label{namespacehelib_afddae64ffeb6698a0b2a5214ab66273b}} 
\index{helib@{helib}!CtPtrs\_slice@{CtPtrs\_slice}}
\index{CtPtrs\_slice@{CtPtrs\_slice}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrs\_slice}{CtPtrs\_slice}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector__slice}{Ptr\+Vector\+\_\+slice}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_afddae64ffeb6698a0b2a5214ab66273b}{helib\+::\+Ct\+Ptrs\+\_\+slice}}}

\mbox{\Hypertarget{namespacehelib_a68bdc610c69d2325ae28b53783225701}\label{namespacehelib_a68bdc610c69d2325ae28b53783225701}} 
\index{helib@{helib}!CtPtrs\_VecCt@{CtPtrs\_VecCt}}
\index{CtPtrs\_VecCt@{CtPtrs\_VecCt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrs\_VecCt}{CtPtrs\_VecCt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector___vec_t}{Ptr\+Vector\+\_\+\+VecT}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_a68bdc610c69d2325ae28b53783225701}{helib\+::\+Ct\+Ptrs\+\_\+\+Vec\+Ct}}}

\mbox{\Hypertarget{namespacehelib_adf611a971d91604083e4a4f4d2745a46}\label{namespacehelib_adf611a971d91604083e4a4f4d2745a46}} 
\index{helib@{helib}!CtPtrs\_VecPt@{CtPtrs\_VecPt}}
\index{CtPtrs\_VecPt@{CtPtrs\_VecPt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrs\_VecPt}{CtPtrs\_VecPt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector___vec_pt}{Ptr\+Vector\+\_\+\+Vec\+Pt}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_adf611a971d91604083e4a4f4d2745a46}{helib\+::\+Ct\+Ptrs\+\_\+\+Vec\+Pt}}}

\mbox{\Hypertarget{namespacehelib_a70957f911bb89f6b84e7838ac4363d07}\label{namespacehelib_a70957f911bb89f6b84e7838ac4363d07}} 
\index{helib@{helib}!CtPtrs\_vectorCt@{CtPtrs\_vectorCt}}
\index{CtPtrs\_vectorCt@{CtPtrs\_vectorCt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrs\_vectorCt}{CtPtrs\_vectorCt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector__vector_t}{Ptr\+Vector\+\_\+vectorT}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_a70957f911bb89f6b84e7838ac4363d07}{helib\+::\+Ct\+Ptrs\+\_\+vector\+Ct}}}

\mbox{\Hypertarget{namespacehelib_ac9e2fec60563f1741cf5b38e9c975781}\label{namespacehelib_ac9e2fec60563f1741cf5b38e9c975781}} 
\index{helib@{helib}!CtPtrs\_vectorPt@{CtPtrs\_vectorPt}}
\index{CtPtrs\_vectorPt@{CtPtrs\_vectorPt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CtPtrs\_vectorPt}{CtPtrs\_vectorPt}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{structhelib_1_1_ptr_vector__vector_pt}{Ptr\+Vector\+\_\+vector\+Pt}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ \mbox{\hyperlink{namespacehelib_ac9e2fec60563f1741cf5b38e9c975781}{helib\+::\+Ct\+Ptrs\+\_\+vector\+Pt}}}

\mbox{\Hypertarget{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}\label{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}} 
\index{helib@{helib}!cx\_double@{cx\_double}}
\index{cx\_double@{cx\_double}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{cx\_double}{cx\_double}}
{\footnotesize\ttfamily typedef std\+::complex$<$ double $>$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{helib\+::cx\+\_\+double}}}

\mbox{\Hypertarget{namespacehelib_a428c028bc71d7be0bdaa0118f286ee2e}\label{namespacehelib_a428c028bc71d7be0bdaa0118f286ee2e}} 
\index{helib@{helib}!DCRTptr@{DCRTptr}}
\index{DCRTptr@{DCRTptr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DCRTptr}{DCRTptr}}
{\footnotesize\ttfamily typedef std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}$>$ \mbox{\hyperlink{namespacehelib_a428c028bc71d7be0bdaa0118f286ee2e}{helib\+::\+D\+C\+R\+Tptr}}}

\mbox{\Hypertarget{namespacehelib_af547f7016fc73b7174a2018ea28ef298}\label{namespacehelib_af547f7016fc73b7174a2018ea28ef298}} 
\index{helib@{helib}!FlowGraph@{FlowGraph}}
\index{FlowGraph@{FlowGraph}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{FlowGraph}{FlowGraph}}
{\footnotesize\ttfamily typedef std\+::vector$<$\mbox{\hyperlink{namespacehelib_a22330000dbd6d83a79f312ccb04405fb}{F\+Neighbor\+List}}$>$ \mbox{\hyperlink{namespacehelib_af547f7016fc73b7174a2018ea28ef298}{helib\+::\+Flow\+Graph}}}

\mbox{\Hypertarget{namespacehelib_a22330000dbd6d83a79f312ccb04405fb}\label{namespacehelib_a22330000dbd6d83a79f312ccb04405fb}} 
\index{helib@{helib}!FNeighborList@{FNeighborList}}
\index{FNeighborList@{FNeighborList}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{FNeighborList}{FNeighborList}}
{\footnotesize\ttfamily typedef std\+::unordered\+\_\+map$<$long, \mbox{\hyperlink{classhelib_1_1_flow_edge}{Flow\+Edge}}$>$ \mbox{\hyperlink{namespacehelib_a22330000dbd6d83a79f312ccb04405fb}{helib\+::\+F\+Neighbor\+List}}}

\mbox{\Hypertarget{namespacehelib_a9b643292f10bf869b8650f9392ff2d90}\label{namespacehelib_a9b643292f10bf869b8650f9392ff2d90}} 
\index{helib@{helib}!ldbl@{ldbl}}
\index{ldbl@{ldbl}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ldbl}{ldbl}}
{\footnotesize\ttfamily typedef long double \mbox{\hyperlink{namespacehelib_a9b643292f10bf869b8650f9392ff2d90}{helib\+::ldbl}}}

\mbox{\Hypertarget{namespacehelib_ab3940838420e66ad737389ec211730b3}\label{namespacehelib_ab3940838420e66ad737389ec211730b3}} 
\index{helib@{helib}!LNeighborList@{LNeighborList}}
\index{LNeighborList@{LNeighborList}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{LNeighborList}{LNeighborList}}
{\footnotesize\ttfamily typedef std\+::unordered\+\_\+multimap$<$long, \mbox{\hyperlink{classhelib_1_1_labeled_edge}{Labeled\+Edge}}$>$ \mbox{\hyperlink{namespacehelib_ab3940838420e66ad737389ec211730b3}{helib\+::\+L\+Neighbor\+List}}}

\mbox{\Hypertarget{namespacehelib_ad6eb9f0889a704dbc4684ce445c48456}\label{namespacehelib_ad6eb9f0889a704dbc4684ce445c48456}} 
\index{helib@{helib}!LONG@{LONG}}
\index{LONG@{LONG}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{LONG}{LONG}}
{\footnotesize\ttfamily typedef long \mbox{\hyperlink{namespacehelib_ad6eb9f0889a704dbc4684ce445c48456}{helib\+::\+L\+O\+NG}}}

\mbox{\Hypertarget{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}\label{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}} 
\index{helib@{helib}!Matrix@{Matrix}}
\index{Matrix@{Matrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{Matrix}{Matrix}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
using \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{helib\+::\+Matrix}} = typedef \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$T, 2$>$}

\mbox{\Hypertarget{namespacehelib_a007ac83d6ec59826a48a73602b739510}\label{namespacehelib_a007ac83d6ec59826a48a73602b739510}} 
\index{helib@{helib}!NodeIdx@{NodeIdx}}
\index{NodeIdx@{NodeIdx}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{NodeIdx}{NodeIdx}}
{\footnotesize\ttfamily typedef std\+::pair$<$long, long$>$ \mbox{\hyperlink{namespacehelib_a007ac83d6ec59826a48a73602b739510}{helib\+::\+Node\+Idx}}}

\mbox{\Hypertarget{namespacehelib_a22b83b7df1af539c07c804d7888448ce}\label{namespacehelib_a22b83b7df1af539c07c804d7888448ce}} 
\index{helib@{helib}!OneGeneratorTree@{OneGeneratorTree}}
\index{OneGeneratorTree@{OneGeneratorTree}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{OneGeneratorTree}{OneGeneratorTree}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{classhelib_1_1_full_binary_tree}{Full\+Binary\+Tree}}$<$\mbox{\hyperlink{classhelib_1_1_sub_dimension}{Sub\+Dimension}}$>$ \mbox{\hyperlink{namespacehelib_a22b83b7df1af539c07c804d7888448ce}{helib\+::\+One\+Generator\+Tree}}}

\mbox{\Hypertarget{namespacehelib_ae0769a209e14d5e1bfd8579072397867}\label{namespacehelib_ae0769a209e14d5e1bfd8579072397867}} 
\index{helib@{helib}!Permut@{Permut}}
\index{Permut@{Permut}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{Permut}{Permut}}
{\footnotesize\ttfamily typedef N\+T\+L\+::\+Vec$<$long$>$ \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{helib\+::\+Permut}}}



A simple permutation is just a vector with p\mbox{[}i\mbox{]}=\textbackslash{}pi\+\_\+i. 

\mbox{\Hypertarget{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}\label{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}} 
\index{helib@{helib}!QueryExpr@{QueryExpr}}
\index{QueryExpr@{QueryExpr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{QueryExpr}{QueryExpr}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{helib\+::\+Query\+Expr}} = typedef std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{structhelib_1_1_expr}{Expr}}$>$}



An alias for a shared pointer to an {\ttfamily \mbox{\hyperlink{structhelib_1_1_expr}{Expr}}} object. 

\mbox{\Hypertarget{namespacehelib_a67a60bb8531261415fb3615bde85ae65}\label{namespacehelib_a67a60bb8531261415fb3615bde85ae65}} 
\index{helib@{helib}!Vector@{Vector}}
\index{Vector@{Vector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{Vector}{Vector}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
using \mbox{\hyperlink{namespacehelib_a67a60bb8531261415fb3615bde85ae65}{helib\+::\+Vector}} = typedef \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$T, 1$>$}

\mbox{\Hypertarget{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}\label{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}} 
\index{helib@{helib}!zzX@{zzX}}
\index{zzX@{zzX}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{zzX}{zzX}}
{\footnotesize\ttfamily typedef N\+T\+L\+::\+Vec$<$long$>$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{helib\+::zzX}}}

\mbox{\Hypertarget{namespacehelib_a3652f33aab9e225a4c136eb14a50bc53}\label{namespacehelib_a3652f33aab9e225a4c136eb14a50bc53}} 
\index{helib@{helib}!ZZXptr@{ZZXptr}}
\index{ZZXptr@{ZZXptr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ZZXptr}{ZZXptr}}
{\footnotesize\ttfamily typedef std\+::shared\+\_\+ptr$<$N\+T\+L\+::\+Z\+ZX$>$ \mbox{\hyperlink{namespacehelib_a3652f33aab9e225a4c136eb14a50bc53}{helib\+::\+Z\+Z\+Xptr}}}



\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7e}\label{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7e}} 
\index{helib@{helib}!PA\_tag@{PA\_tag}}
\index{PA\_tag@{PA\_tag}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PA\_tag}{PA\_tag}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7e}{helib\+::\+P\+A\+\_\+tag}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{PA\_GF2\_tag@{PA\_GF2\_tag}!helib@{helib}}\index{helib@{helib}!PA\_GF2\_tag@{PA\_GF2\_tag}}}\mbox{\Hypertarget{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7eab33244c736f38a4c21e6d86c6a683d58}\label{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7eab33244c736f38a4c21e6d86c6a683d58}} 
P\+A\+\_\+\+G\+F2\+\_\+tag&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PA\_zz\_p\_tag@{PA\_zz\_p\_tag}!helib@{helib}}\index{helib@{helib}!PA\_zz\_p\_tag@{PA\_zz\_p\_tag}}}\mbox{\Hypertarget{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7ea63d35380340004730e7cb505a4da38e2}\label{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7ea63d35380340004730e7cb505a4da38e2}} 
P\+A\+\_\+zz\+\_\+p\+\_\+tag&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PA\_cx\_tag@{PA\_cx\_tag}!helib@{helib}}\index{helib@{helib}!PA\_cx\_tag@{PA\_cx\_tag}}}\mbox{\Hypertarget{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7ea7d944116ae9eb1abb2d5fa92bb6d21ee}\label{namespacehelib_ab0181d82dc81ed4d1f8c1d950b4efd7ea7d944116ae9eb1abb2d5fa92bb6d21ee}} 
P\+A\+\_\+cx\+\_\+tag&\\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacehelib_a42185bbb249368e34f515e09e90bc7b0}\label{namespacehelib_a42185bbb249368e34f515e09e90bc7b0}} 
\index{helib@{helib}!add@{add}}
\index{add@{add}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::add (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a33424cc1805af9dc818e142033c9d9be}\label{namespacehelib_a33424cc1805af9dc818e142033c9d9be}} 
\index{helib@{helib}!add@{add}}
\index{add@{add}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void helib\+::add (\begin{DoxyParamCaption}\item[{std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{x,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{a,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa160e775ba4dcac09cec20c2febb5de2}\label{namespacehelib_aa160e775ba4dcac09cec20c2febb5de2}} 
\index{helib@{helib}!add@{add}}
\index{add@{add}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{res,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a8f3689b135fde2c843eed5ce0813a975}\label{namespacehelib_a8f3689b135fde2c843eed5ce0813a975}} 
\index{helib@{helib}!add1DMatrices@{add1DMatrices}}
\index{add1DMatrices@{add1DMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{add1DMatrices()}{add1DMatrices()}}
{\footnotesize\ttfamily void helib\+::add1\+D\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}



Generate all matrices s(X$^\wedge$\{g$^\wedge$i\})-\/$>$s(\+X) for generators g of Zm$\ast$ /(p) and i$<$ord(g). If g has different orders in Zm$\ast$ and Zm$\ast$ /(p) then generate also matrices of the form s(X$^\wedge$\{g$^\wedge$\{-\/i\}\})-\/$>$s(\+X) 

\mbox{\Hypertarget{namespacehelib_a4da7a89f85244e58f456a86832c46a27}\label{namespacehelib_a4da7a89f85244e58f456a86832c46a27}} 
\index{helib@{helib}!addAllMatrices@{addAllMatrices}}
\index{addAllMatrices@{addAllMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addAllMatrices()}{addAllMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+All\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}



Maximalistic approach\+: generate matrices s(\+X$^\wedge$e)-\/$>$s(\+X) for all e in Zm$\ast$. 

\mbox{\Hypertarget{namespacehelib_a63d75eed1d12814e2e858ab82e07d311}\label{namespacehelib_a63d75eed1d12814e2e858ab82e07d311}} 
\index{helib@{helib}!addBSGS1DMatrices@{addBSGS1DMatrices}}
\index{addBSGS1DMatrices@{addBSGS1DMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addBSGS1DMatrices()}{addBSGS1DMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+B\+S\+G\+S1\+D\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af9483c8e129d827f9b49f140a327dd15}\label{namespacehelib_af9483c8e129d827f9b49f140a327dd15}} 
\index{helib@{helib}!addBSGSFrbMatrices@{addBSGSFrbMatrices}}
\index{addBSGSFrbMatrices@{addBSGSFrbMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addBSGSFrbMatrices()}{addBSGSFrbMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+B\+S\+G\+S\+Frb\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acd7803e7000d31eda4aa3af44bfe0ef0}\label{namespacehelib_acd7803e7000d31eda4aa3af44bfe0ef0}} 
\index{helib@{helib}!addFewMatrices@{addFewMatrices}}
\index{addFewMatrices@{addFewMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addFewMatrices()}{addFewMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+Few\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}



Generate matrices so every s(\+X$^\wedge$e) can be re\+Linearized in at most two steps. 

\mbox{\Hypertarget{namespacehelib_a62bfda232309a69cc3824e5323345073}\label{namespacehelib_a62bfda232309a69cc3824e5323345073}} 
\index{helib@{helib}!addFrbMatrices@{addFrbMatrices}}
\index{addFrbMatrices@{addFrbMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addFrbMatrices()}{addFrbMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+Frb\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a34e793367187e97095f9f2590eb4dc5e}\label{namespacehelib_a34e793367187e97095f9f2590eb4dc5e}} 
\index{helib@{helib}!addManyNumbers@{addManyNumbers}}
\index{addManyNumbers@{addManyNumbers}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addManyNumbers()}{addManyNumbers()}}
{\footnotesize\ttfamily void helib\+::add\+Many\+Numbers (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{sum,  }\item[{\mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{Ct\+Ptr\+Mat}} \&}]{numbers,  }\item[{long}]{size\+Limit = {\ttfamily 0},  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Sum an arbitrary amount of numbers in binary representation. 


\begin{DoxyParams}{Parameters}
{\em sum} & result of the summation. \\
\hline
{\em numbers} & values of which to sum. \\
\hline
{\em size\+Limit} & number of bits to compute on, taken from the least significant end. \\
\hline
{\em unpack\+Slot\+Encoding} & vector of constants for unpacking, as used in bootstrapping.\\
\hline
\end{DoxyParams}
Calculates the sum of many numbers using the 3-\/for-\/2 method. \mbox{\Hypertarget{namespacehelib_a7d420cdf0dc5b6968a8a89809cd5b5f3}\label{namespacehelib_a7d420cdf0dc5b6968a8a89809cd5b5f3}} 
\index{helib@{helib}!addMatrices4Network@{addMatrices4Network}}
\index{addMatrices4Network@{addMatrices4Network}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addMatrices4Network()}{addMatrices4Network()}}
{\footnotesize\ttfamily void helib\+::add\+Matrices4\+Network (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{const \mbox{\hyperlink{classhelib_1_1_perm_network}{Perm\+Network}} \&}]{net,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0c3d6b66cd30aed055d9c5a6333eca7c}\label{namespacehelib_a0c3d6b66cd30aed055d9c5a6333eca7c}} 
\index{helib@{helib}!addMinimal1DMatrices@{addMinimal1DMatrices}}
\index{addMinimal1DMatrices@{addMinimal1DMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addMinimal1DMatrices()}{addMinimal1DMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+Minimal1\+D\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}



These routines just add a single matrix (or two, for bad dimensions) 

\mbox{\Hypertarget{namespacehelib_aa94886e3afbcd49800243fd7fdaedd39}\label{namespacehelib_aa94886e3afbcd49800243fd7fdaedd39}} 
\index{helib@{helib}!addMinimalFrbMatrices@{addMinimalFrbMatrices}}
\index{addMinimalFrbMatrices@{addMinimalFrbMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addMinimalFrbMatrices()}{addMinimalFrbMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+Minimal\+Frb\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6bcb58c007d8e3cb2a1b4c7d0c162895}\label{namespacehelib_a6bcb58c007d8e3cb2a1b4c7d0c162895}} 
\index{helib@{helib}!addOffset@{addOffset}}
\index{addOffset@{addOffset}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addOffset()}{addOffset()}}
{\footnotesize\ttfamily void helib\+::add\+Offset (\begin{DoxyParamCaption}\item[{std\+::list$<$ long $>$ \&}]{x,  }\item[{long}]{offset,  }\item[{long}]{n,  }\item[{bool $\ast$}]{aux,  }\item[{U\+N\+U\+S\+ED bool}]{good = {\ttfamily false} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3ace8477657e91faeb4c33824bab098d}\label{namespacehelib_a3ace8477657e91faeb4c33824bab098d}} 
\index{helib@{helib}!addSome1DMatrices@{addSome1DMatrices}}
\index{addSome1DMatrices@{addSome1DMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addSome1DMatrices()}{addSome1DMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+Some1\+D\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{bound = {\ttfamily HELIB\+\_\+KEYSWITCH\+\_\+THRESH},  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}



Generate some matrices of the form s(X$^\wedge$\{g$^\wedge$i\})-\/$>$s(\+X), but not all. For a generator g whose order is larger than bound, generate only enough matrices for the giant-\/step/baby-\/step procedures (2$\ast$sqrt(ord(g))of them). 

\mbox{\Hypertarget{namespacehelib_a40b42a155c81c0507222ebca1f0a39f8}\label{namespacehelib_a40b42a155c81c0507222ebca1f0a39f8}} 
\index{helib@{helib}!addSomeFrbMatrices@{addSomeFrbMatrices}}
\index{addSomeFrbMatrices@{addSomeFrbMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addSomeFrbMatrices()}{addSomeFrbMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+Some\+Frb\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{long}]{bound = {\ttfamily HELIB\+\_\+KEYSWITCH\+\_\+THRESH},  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}



Generate all/some Frobenius matrices of the form s(X$^\wedge$\{p$^\wedge$i\})-\/$>$s(\+X) 

\mbox{\Hypertarget{namespacehelib_aac13602434c22102de26465c49856eeb}\label{namespacehelib_aac13602434c22102de26465c49856eeb}} 
\index{helib@{helib}!addSomePrimes@{addSomePrimes}}
\index{addSomePrimes@{addSomePrimes}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addSomePrimes()}{addSomePrimes()}}
{\footnotesize\ttfamily void helib\+::add\+Some\+Primes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{c }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a96c1092ac50c752cc8577da03cf232d4}\label{namespacehelib_a96c1092ac50c752cc8577da03cf232d4}} 
\index{helib@{helib}!addTheseMatrices@{addTheseMatrices}}
\index{addTheseMatrices@{addTheseMatrices}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addTheseMatrices()}{addTheseMatrices()}}
{\footnotesize\ttfamily void helib\+::add\+These\+Matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{const std\+::set$<$ long $>$ \&}]{autom\+Vals,  }\item[{long}]{key\+ID = {\ttfamily 0} }\end{DoxyParamCaption})}



Generate specific key-\/switching matrices, described by the given set. 

\mbox{\Hypertarget{namespacehelib_a277237f0883421a2abee740db9f1b6ef}\label{namespacehelib_a277237f0883421a2abee740db9f1b6ef}} 
\index{helib@{helib}!addTwoNumbers@{addTwoNumbers}}
\index{addTwoNumbers@{addTwoNumbers}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{addTwoNumbers()}{addTwoNumbers()}}
{\footnotesize\ttfamily void helib\+::add\+Two\+Numbers (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{sum,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{rhs,  }\item[{long}]{size\+Limit = {\ttfamily 0},  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Adds two numbers in binary representation where each ciphertext of the input vector contains a bit. 

Add two integers in binary representation.


\begin{DoxyParams}{Parameters}
{\em sum} & result of the addition operation. \\
\hline
{\em lhs} & left hand side of the addition. \\
\hline
{\em rhs} & right hand side of the addition. \\
\hline
{\em size\+Limit} & number of bits to compute on, taken from the least significant end. \\
\hline
{\em unpack\+Slot\+Encoding} & vector of constants for unpacking, as used in bootstrapping. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a379dfd6585b3c7aab695a9ca33a7ad89}\label{namespacehelib_a379dfd6585b3c7aab695a9ca33a7ad89}} 
\index{helib@{helib}!applyLinPoly@{applyLinPoly}}
\index{applyLinPoly@{applyLinPoly}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPoly()}{applyLinPoly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::apply\+Lin\+Poly (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+G\+F2E \&}]{beta,  }\item[{const N\+T\+L\+::vec\+\_\+\+G\+F2E \&}]{C,  }\item[{const N\+T\+L\+::\+G\+F2E \&}]{alpha,  }\item[{long}]{p }\end{DoxyParamCaption})}



A version for G\+F2\+: must be called with p == 2 and r == 1. 

\mbox{\Hypertarget{namespacehelib_a0dda3f81ff66fb0e9a92bc39ecad0a92}\label{namespacehelib_a0dda3f81ff66fb0e9a92bc39ecad0a92}} 
\index{helib@{helib}!applyLinPoly@{applyLinPoly}}
\index{applyLinPoly@{applyLinPoly}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPoly()}{applyLinPoly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::apply\+Lin\+Poly (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+pE \&}]{beta,  }\item[{const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&}]{C,  }\item[{const N\+T\+L\+::zz\+\_\+pE \&}]{alpha,  }\item[{long}]{p }\end{DoxyParamCaption})}



Apply a linearized polynomial with coefficient vector C. 

N\+TL\textquotesingle{}s current smallint modulus, zz\+\_\+p\+::modulus(), is assumed to be p$^\wedge$r, for p prime, r $>$= 1 integer. \mbox{\Hypertarget{namespacehelib_a583abeb8ab8021559fb519621b42c3d7}\label{namespacehelib_a583abeb8ab8021559fb519621b42c3d7}} 
\index{helib@{helib}!applyLinPoly1@{applyLinPoly1}}
\index{applyLinPoly1@{applyLinPoly1}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPoly1()}{applyLinPoly1()}}
{\footnotesize\ttfamily void helib\+::apply\+Lin\+Poly1 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{C }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9f6f5e7fb2a932db709cbb632e644a81}\label{namespacehelib_a9f6f5e7fb2a932db709cbb632e644a81}} 
\index{helib@{helib}!applyLinPolyLL@{applyLinPolyLL}}
\index{applyLinPolyLL@{applyLinPolyLL}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPolyLL()}{applyLinPolyLL()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template void helib\+::apply\+Lin\+Poly\+LL (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \&}]{encodedC,  }\item[{long}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a896039fe9d2b2bda45cf62d278e52a5f}\label{namespacehelib_a896039fe9d2b2bda45cf62d278e52a5f}} 
\index{helib@{helib}!applyLinPolyLL@{applyLinPolyLL}}
\index{applyLinPolyLL@{applyLinPolyLL}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPolyLL()}{applyLinPolyLL()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template void helib\+::apply\+Lin\+Poly\+LL (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{encodedC,  }\item[{long}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a21457a6ed2a6de2701b394bfcc90be1e}\label{namespacehelib_a21457a6ed2a6de2701b394bfcc90be1e}} 
\index{helib@{helib}!applyLinPolyLL@{applyLinPolyLL}}
\index{applyLinPolyLL@{applyLinPolyLL}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPolyLL()}{applyLinPolyLL()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename P $>$ \\
void helib\+::apply\+Lin\+Poly\+LL (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const std\+::vector$<$ P $>$ \&}]{encodedC,  }\item[{long}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0bc9fd386812fdc5f5067522dc4ceced}\label{namespacehelib_a0bc9fd386812fdc5f5067522dc4ceced}} 
\index{helib@{helib}!applyLinPolyLL@{applyLinPolyLL}}
\index{applyLinPolyLL@{applyLinPolyLL}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPolyLL()}{applyLinPolyLL()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template void helib\+::apply\+Lin\+Poly\+LL (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{encodedC,  }\item[{long}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa8e520a1528ee0d150a9818c7ddc4850}\label{namespacehelib_aa8e520a1528ee0d150a9818c7ddc4850}} 
\index{helib@{helib}!applyLinPolyMany@{applyLinPolyMany}}
\index{applyLinPolyMany@{applyLinPolyMany}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyLinPolyMany()}{applyLinPolyMany()}}
{\footnotesize\ttfamily void helib\+::apply\+Lin\+Poly\+Many (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const std\+::vector$<$ std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$$>$ \&}]{Cvec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adf575ea763b7454a6e8df566a9e64b3c}\label{namespacehelib_adf575ea763b7454a6e8df566a9e64b3c}} 
\index{helib@{helib}!applyPerm@{applyPerm}}
\index{applyPerm@{applyPerm}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPerm()}{applyPerm()}}
{\footnotesize\ttfamily void helib\+::apply\+Perm (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{pi }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0ae17bbc28a578112d0fe28b99f5e204}\label{namespacehelib_a0ae17bbc28a578112d0fe28b99f5e204}} 
\index{helib@{helib}!applyPermsToVec@{applyPermsToVec}}
\index{applyPermsToVec@{applyPermsToVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermsToVec()}{applyPermsToVec()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::apply\+Perms\+To\+Vec (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ T $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p2,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}



Apply two permutations to a std\+::vector out\mbox{[}i\mbox{]}=in\mbox{[}p2\mbox{[}p1\mbox{[}i\mbox{]}\mbox{]}\mbox{]} (N\+OT in-\/place) 

\mbox{\Hypertarget{namespacehelib_a6c6d61d4ac69597feb9beedc26bf93cc}\label{namespacehelib_a6c6d61d4ac69597feb9beedc26bf93cc}} 
\index{helib@{helib}!applyPermsToVec@{applyPermsToVec}}
\index{applyPermsToVec@{applyPermsToVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermsToVec()}{applyPermsToVec()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::apply\+Perms\+To\+Vec (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{out,  }\item[{const std\+::vector$<$ T $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p2,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_abe7675aa123a573bc6d687c1421f2308}\label{namespacehelib_abe7675aa123a573bc6d687c1421f2308}} 
\index{helib@{helib}!applyPermsToVec$<$ long $>$@{applyPermsToVec$<$ long $>$}}
\index{applyPermsToVec$<$ long $>$@{applyPermsToVec$<$ long $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermsToVec$<$ long $>$()}{applyPermsToVec< long >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_a0ae17bbc28a578112d0fe28b99f5e204}{helib\+::apply\+Perms\+To\+Vec}}$<$ long $>$ (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p2,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acc4a600c33f24c48a5074b19d9db9d24}\label{namespacehelib_acc4a600c33f24c48a5074b19d9db9d24}} 
\index{helib@{helib}!applyPermsToVec$<$ long $>$@{applyPermsToVec$<$ long $>$}}
\index{applyPermsToVec$<$ long $>$@{applyPermsToVec$<$ long $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermsToVec$<$ long $>$()}{applyPermsToVec< long >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_a0ae17bbc28a578112d0fe28b99f5e204}{helib\+::apply\+Perms\+To\+Vec}}$<$ long $>$ (\begin{DoxyParamCaption}\item[{std\+::vector$<$ long $>$ \&}]{out,  }\item[{const std\+::vector$<$ long $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p2,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0cf8627539f6c1c46e6ae9287058f7cc}\label{namespacehelib_a0cf8627539f6c1c46e6ae9287058f7cc}} 
\index{helib@{helib}!applyPermToVec@{applyPermToVec}}
\index{applyPermToVec@{applyPermToVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermToVec()}{applyPermToVec()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::apply\+Perm\+To\+Vec (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ T $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}



Apply a permutation to a std\+::vector, out\mbox{[}i\mbox{]}=in\mbox{[}p1\mbox{[}i\mbox{]}\mbox{]} (N\+OT in-\/place) 

\mbox{\Hypertarget{namespacehelib_abae99af99454c783bed9cbde7cd72058}\label{namespacehelib_abae99af99454c783bed9cbde7cd72058}} 
\index{helib@{helib}!applyPermToVec@{applyPermToVec}}
\index{applyPermToVec@{applyPermToVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermToVec()}{applyPermToVec()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::apply\+Perm\+To\+Vec (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{out,  }\item[{const std\+::vector$<$ T $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a81a1417dec7a02c2dc600a3802cb3102}\label{namespacehelib_a81a1417dec7a02c2dc600a3802cb3102}} 
\index{helib@{helib}!applyPermToVec$<$ long $>$@{applyPermToVec$<$ long $>$}}
\index{applyPermToVec$<$ long $>$@{applyPermToVec$<$ long $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermToVec$<$ long $>$()}{applyPermToVec< long >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_a0cf8627539f6c1c46e6ae9287058f7cc}{helib\+::apply\+Perm\+To\+Vec}}$<$ long $>$ (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a331891be147b33a730e697f3d9e9bc92}\label{namespacehelib_a331891be147b33a730e697f3d9e9bc92}} 
\index{helib@{helib}!applyPermToVec$<$ long $>$@{applyPermToVec$<$ long $>$}}
\index{applyPermToVec$<$ long $>$@{applyPermToVec$<$ long $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermToVec$<$ long $>$()}{applyPermToVec< long >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_a0cf8627539f6c1c46e6ae9287058f7cc}{helib\+::apply\+Perm\+To\+Vec}}$<$ long $>$ (\begin{DoxyParamCaption}\item[{std\+::vector$<$ long $>$ \&}]{out,  }\item[{const std\+::vector$<$ long $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aff1608eb4840762727e4733e2c63b8bb}\label{namespacehelib_aff1608eb4840762727e4733e2c63b8bb}} 
\index{helib@{helib}!applyPermToVec$<$ NTL::ZZX $>$@{applyPermToVec$<$ NTL::ZZX $>$}}
\index{applyPermToVec$<$ NTL::ZZX $>$@{applyPermToVec$<$ NTL::ZZX $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{applyPermToVec$<$ NTL::ZZX $>$()}{applyPermToVec< NTL::ZZX >()}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_a0cf8627539f6c1c46e6ae9287058f7cc}{helib\+::apply\+Perm\+To\+Vec}}$<$ N\+T\+L\+::\+Z\+ZX $>$ (\begin{DoxyParamCaption}\item[{std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{out,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{in,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{p1 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad94c1a39dcabf4a83066a2908a02e274}\label{namespacehelib_ad94c1a39dcabf4a83066a2908a02e274}} 
\index{helib@{helib}!areTimersOn@{areTimersOn}}
\index{areTimersOn@{areTimersOn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{areTimersOn()}{areTimersOn()}}
{\footnotesize\ttfamily bool helib\+::are\+Timers\+On (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_acced988b8c7248219e7c13e20d1d0e6c}\label{namespacehelib_acced988b8c7248219e7c13e20d1d0e6c}} 
\index{helib@{helib}!argmax@{argmax}}
\index{argmax@{argmax}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{argmax()}{argmax()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily long helib\+::argmax (\begin{DoxyParamCaption}\item[{std\+::vector$<$ long $>$ \&}]{v,  }\item[{bool($\ast$)(long, long)}]{more\+Than }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



A variant with a specialized comparison function ($\ast$more\+Than)(a,b) returns the comparison a$>$b. 

\mbox{\Hypertarget{namespacehelib_ae84a9818e92cbee595e4895ad9dee849}\label{namespacehelib_ae84a9818e92cbee595e4895ad9dee849}} 
\index{helib@{helib}!argmax@{argmax}}
\index{argmax@{argmax}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{argmax()}{argmax()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
long helib\+::argmax (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a4218a947a483c68d1727c537c216c347}\label{namespacehelib_a4218a947a483c68d1727c537c216c347}} 
\index{helib@{helib}!argmin@{argmin}}
\index{argmin@{argmin}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{argmin()}{argmin()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
long helib\+::argmin (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aaa88363f3a91a37ba8e213b0cb764ea5}\label{namespacehelib_aaa88363f3a91a37ba8e213b0cb764ea5}} 
\index{helib@{helib}!argminmax@{argminmax}}
\index{argminmax@{argminmax}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{argminmax()}{argminmax()}}
{\footnotesize\ttfamily template$<$typename T , bool max\+Flag$>$ \\
long helib\+::argminmax (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}



Find the index of the (first) largest/smallest element. 

These procedures are roughly just simpler variants of std\+::max\+\_\+element and std\+::min\+\_\+element. argmin/argmax are implemented as a template, so the code must be placed in the header file for the compiler to find it. The class T must have an implementation of operator$>$ and operator$<$ for this template to work. 
\begin{DoxyTemplParams}{Template Parameters}
{\em max\+Flag} & A boolean value\+: true -\/ argmax, false -\/ argmin \\
\hline
\end{DoxyTemplParams}
\mbox{\Hypertarget{namespacehelib_aec77ae5fa0fd11a0a42e07fefe49b99d}\label{namespacehelib_aec77ae5fa0fd11a0a42e07fefe49b99d}} 
\index{helib@{helib}!assertEq@{assertEq}}
\index{assertEq@{assertEq}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{assertEq()}{assertEq()}}
{\footnotesize\ttfamily template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ \\
void helib\+::assert\+Eq (\begin{DoxyParamCaption}\item[{const T \&}]{a,  }\item[{const T \&}]{b,  }\item[{const std\+::string \&}]{message }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function throwing an exception of type Exception\+Ty if the two arguments are not equal.


\begin{DoxyTemplParams}{Template Parameters}
{\em Exception\+Ty} & type of the exception thrown. \\
\hline
{\em T} & type of the elements to be compared. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em a} & the first element to be compared. \\
\hline
{\em b} & the second element to be compared. \\
\hline
{\em message} & the message of the exception raised if the two values are not equal. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Exception\+Ty} & exception if the two values are not equal. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Exception\+Ty first and T defaulted to void so that one can specify only Exception\+Ty, letting T be inferred from the argument passed. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_ad5fc5ad34739ea66baa96f988dd07beb}\label{namespacehelib_ad5fc5ad34739ea66baa96f988dd07beb}} 
\index{helib@{helib}!assertFalse@{assertFalse}}
\index{assertFalse@{assertFalse}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{assertFalse()}{assertFalse()}}
{\footnotesize\ttfamily template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ \\
void helib\+::assert\+False (\begin{DoxyParamCaption}\item[{T}]{value,  }\item[{const std\+::string \&}]{message }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function throwing an exception of type Exception\+Ty if the condition is true.


\begin{DoxyTemplParams}{Template Parameters}
{\em Exception\+Ty} & type of the exception thrown. \\
\hline
{\em T} & type of the condition being checked (must be a bool). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em value} & the condition being checked. \\
\hline
{\em message} & the message of the exception raised if the condition is true. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Exception\+Ty} & exception if condition is true. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Exception\+Ty first and T defaulted to void so that one can specify only Exception\+Ty, letting T be inferred from the argument passed. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a8e36344202aac3b245f5ba71f69a3e8b}\label{namespacehelib_a8e36344202aac3b245f5ba71f69a3e8b}} 
\index{helib@{helib}!assertInRange@{assertInRange}}
\index{assertInRange@{assertInRange}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{assertInRange()}{assertInRange()}}
{\footnotesize\ttfamily template$<$typename Exception\+Ty  = \+::helib\+::\+Out\+Of\+Range\+Error, typename T  = void$>$ \\
void helib\+::assert\+In\+Range (\begin{DoxyParamCaption}\item[{const T \&}]{elem,  }\item[{const T \&}]{min,  }\item[{const T \&}]{max,  }\item[{const std\+::string \&}]{message,  }\item[{bool}]{right\+\_\+inclusive = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function throwing an exception of type Exception\+Ty if the element is in the range \mbox{[}min,max) or \mbox{[}min, max\mbox{]}


\begin{DoxyTemplParams}{Template Parameters}
{\em Exception\+Ty} & type of the exception thrown. \\
\hline
{\em T} & type of the element (and of the range). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em elem} & the element to be tested. \\
\hline
{\em min} & the left side of the range (always inclusive). \\
\hline
{\em max} & the right side of the range (default exclusive). \\
\hline
{\em message} & the message of the exception raised if the element is not in the range. \\
\hline
{\em right\+\_\+inclusive} & flag specifying if the right side is inclusive (default false). \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Exception\+Ty} & exception if elem is not in the range \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Exception\+Ty first and T defaulted to void so that one can specify only Exception\+Ty, letting T be inferred from the argument passed. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_acd5b530c0837ef9111dc4a361364d669}\label{namespacehelib_acd5b530c0837ef9111dc4a361364d669}} 
\index{helib@{helib}!assertNeq@{assertNeq}}
\index{assertNeq@{assertNeq}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{assertNeq()}{assertNeq()}}
{\footnotesize\ttfamily template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ \\
void helib\+::assert\+Neq (\begin{DoxyParamCaption}\item[{const T \&}]{a,  }\item[{const T \&}]{b,  }\item[{const std\+::string \&}]{message }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function throwing an exception of type Exception\+Ty if the two arguments are equal.


\begin{DoxyTemplParams}{Template Parameters}
{\em Exception\+Ty} & type of the exception thrown. \\
\hline
{\em T} & type of the elements to be compared. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em a} & the first element to be compared. \\
\hline
{\em b} & the second element to be compared. \\
\hline
{\em message} & the message of the exception raised if the two values are equal. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Exception\+Ty} & exception if the two values are equal. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Exception\+Ty first and T defaulted to void so that one can specify only Exception\+Ty, letting T be inferred from the argument passed. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_aa7b1da8169ee8b9a0ab221e4c67961c5}\label{namespacehelib_aa7b1da8169ee8b9a0ab221e4c67961c5}} 
\index{helib@{helib}!assertNotNull@{assertNotNull}}
\index{assertNotNull@{assertNotNull}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{assertNotNull()}{assertNotNull()}}
{\footnotesize\ttfamily template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ \\
void helib\+::assert\+Not\+Null (\begin{DoxyParamCaption}\item[{const T \&}]{p,  }\item[{const std\+::string \&}]{message }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function throwing an exception of type Exception\+Ty if the argument is nullptr.


\begin{DoxyTemplParams}{Template Parameters}
{\em Exception\+Ty} & type of the exception thrown. \\
\hline
{\em T} & type of the element. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & the element to be tested. \\
\hline
{\em message} & the message of the exception raised if the element is nullptr. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Exception\+Ty} & exception if p is nullptr. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Exception\+Ty first and T defaulted to void so that one can specify only Exception\+Ty, letting T be inferred from the argument passed. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_aca37b5e05bffd4550c995e83594d7325}\label{namespacehelib_aca37b5e05bffd4550c995e83594d7325}} 
\index{helib@{helib}!assertTrue@{assertTrue}}
\index{assertTrue@{assertTrue}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{assertTrue()}{assertTrue()}}
{\footnotesize\ttfamily template$<$typename Exception\+Ty  = \+::helib\+::\+Logic\+Error, typename T  = void$>$ \\
void helib\+::assert\+True (\begin{DoxyParamCaption}\item[{const T \&}]{value,  }\item[{const std\+::string \&}]{message }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function throwing an exception of type Exception\+Ty if the condition is false.


\begin{DoxyTemplParams}{Template Parameters}
{\em Exception\+Ty} & type of the exception thrown. \\
\hline
{\em T} & type of the condition being checked (must be a bool). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em value} & the condition being checked. \\
\hline
{\em message} & the message of the exception raised if the condition is false. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Exception\+Ty} & exception if condition is false. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Exception\+Ty first and T defaulted to void so that one can specify only Exception\+Ty, letting T be inferred from the argument passed. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a1040284398724d43661ac3eff7a7400e}\label{namespacehelib_a1040284398724d43661ac3eff7a7400e}} 
\index{helib@{helib}!atoVec@{atoVec}}
\index{atoVec@{atoVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{atoVec()}{atoVec()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
N\+T\+L\+::\+Vec$<$T$>$ helib\+::ato\+Vec (\begin{DoxyParamCaption}\item[{const char $\ast$}]{a }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acdd11aa1bf58d7ac5843fe3ee5fb244c}\label{namespacehelib_acdd11aa1bf58d7ac5843fe3ee5fb244c}} 
\index{helib@{helib}!atovector@{atovector}}
\index{atovector@{atovector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{atovector()}{atovector()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$T$>$ helib\+::atovector (\begin{DoxyParamCaption}\item[{const char $\ast$}]{a }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a00e504f2374c5e7357c7608a94527887}\label{namespacehelib_a00e504f2374c5e7357c7608a94527887}} 
\index{helib@{helib}!balanced\_MulMod@{balanced\_MulMod}}
\index{balanced\_MulMod@{balanced\_MulMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{balanced\_MulMod()}{balanced\_MulMod()}}
{\footnotesize\ttfamily void helib\+::balanced\+\_\+\+Mul\+Mod (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{out,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f,  }\item[{long}]{a,  }\item[{long}]{q }\end{DoxyParamCaption})}

Multiply the polynomial f by the integer a modulo q output coefficients are balanced (appropriately randomized for even q) \mbox{\Hypertarget{namespacehelib_a508dcf9321109128c609e466a3e33181}\label{namespacehelib_a508dcf9321109128c609e466a3e33181}} 
\index{helib@{helib}!balanced\_zzX@{balanced\_zzX}}
\index{balanced\_zzX@{balanced\_zzX}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{balanced\_zzX()}{balanced\_zzX()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} helib\+::balanced\+\_\+zzX (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+G\+F2X \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7b1aa9d391c181e780742a2117e9af78}\label{namespacehelib_a7b1aa9d391c181e780742a2117e9af78}} 
\index{helib@{helib}!balanced\_zzX@{balanced\_zzX}}
\index{balanced\_zzX@{balanced\_zzX}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{balanced\_zzX()}{balanced\_zzX()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} helib\+::balanced\+\_\+zzX (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af183ee91810e5601837e62dfb85df0cd}\label{namespacehelib_af183ee91810e5601837e62dfb85df0cd}} 
\index{helib@{helib}!balRem@{balRem}}
\index{balRem@{balRem}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{balRem()}{balRem()}}
{\footnotesize\ttfamily long helib\+::bal\+Rem (\begin{DoxyParamCaption}\item[{long}]{a,  }\item[{long}]{q }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Return balanced remainder. Assumes a in \mbox{[}0, q) and returns balanced remainder in (-\/q/2, q/2\mbox{]} \mbox{\Hypertarget{namespacehelib_a6cc8eab5085d47ef2587ff4253ec5d77}\label{namespacehelib_a6cc8eab5085d47ef2587ff4253ec5d77}} 
\index{helib@{helib}!binaryCond@{binaryCond}}
\index{binaryCond@{binaryCond}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{binaryCond()}{binaryCond()}}
{\footnotesize\ttfamily void helib\+::binary\+Cond (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{cond,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{true\+Value,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{false\+Value }\end{DoxyParamCaption})}



Implementation of {\ttfamily output = cond $\ast$ true\+Value + (1 -\/ cond) $\ast$ false\+Value}. 

Implementation of output = cond ? true\+Value \+: false\+Value.


\begin{DoxyParams}{Parameters}
{\em output} & Equal to {\ttfamily true\+Value} in slots where {\ttfamily cond} is one and {\ttfamily false\+Value} in slots where {\ttfamily cond} is zero. \\
\hline
{\em cond} & The condition, namely a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}} containing elements of \{0,1\} in each slot. \\
\hline
{\em true\+Value} & Value of {\ttfamily output} wherever {\ttfamily cond} is one. \\
\hline
{\em false\+Value} & Value of {\ttfamily output} wherever {\ttfamily cond} is zero. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\ttfamily true\+Value}, {\ttfamily false\+Value} and {\ttfamily output} must have the same size. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_aa08be8ce0b0f4ca1f870c56508889598}\label{namespacehelib_aa08be8ce0b0f4ca1f870c56508889598}} 
\index{helib@{helib}!binaryMask@{binaryMask}}
\index{binaryMask@{binaryMask}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{binaryMask()}{binaryMask()}}
{\footnotesize\ttfamily void helib\+::binary\+Mask (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{binary\+Nums,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{mask }\end{DoxyParamCaption})}



Zeroes the slots of {\ttfamily binary\+Nums} where the corresponding slot of {\ttfamily mask} is 0. 

Apply mask across the vector of bits slot-\/wise.


\begin{DoxyParams}{Parameters}
{\em binary\+Nums} & Input bits on which to mask (this is done in place). \\
\hline
{\em mask} & Encrypted mask indicating desired slots. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_aa51c5cbd9691dfde759a98c2d7b48542}\label{namespacehelib_aa51c5cbd9691dfde759a98c2d7b48542}} 
\index{helib@{helib}!binSumReduction@{binSumReduction}}
\index{binSumReduction@{binSumReduction}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{binSumReduction()}{binSumReduction()}}
{\footnotesize\ttfamily template$<$typename T\+XT $>$ \\
void helib\+::bin\+Sum\+Reduction (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T\+XT $>$ \&}]{ctxt\+Array }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Performs a binary summation of a vector of elements. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T\+XT} & type of the elements of which to sum. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ctxt\+Array} & The array on which to perform the binary sum. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function is destructive on the array. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_af6cd0b7c9b7fa0afbb885295f10d9354}\label{namespacehelib_af6cd0b7c9b7fa0afbb885295f10d9354}} 
\index{helib@{helib}!bitSetToLong@{bitSetToLong}}
\index{bitSetToLong@{bitSetToLong}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{bitSetToLong()}{bitSetToLong()}}
{\footnotesize\ttfamily long helib\+::bit\+Set\+To\+Long (\begin{DoxyParamCaption}\item[{long}]{bits,  }\item[{long}]{bit\+Size }\end{DoxyParamCaption})}



Considers {\ttfamily bits} as a vector of bits and returns the value it represents when interpreted as a n-\/bit 2\textquotesingle{}s complement number, where n is given by {\ttfamily bit\+Size}. 


\begin{DoxyParams}{Parameters}
{\em bits} & The value containing the bits to be reinterpreted. \\
\hline
{\em bit\+Size} & The number of bits to use, taken from the least significant end of {\ttfamily bits}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the reinterpreted number as a long. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_a95a2868fe4324ee643869930d159f8ff}\label{namespacehelib_a95a2868fe4324ee643869930d159f8ff}} 
\index{helib@{helib}!bitwiseAnd@{bitwiseAnd}}
\index{bitwiseAnd@{bitwiseAnd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{bitwiseAnd()}{bitwiseAnd()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::bitwise\+And (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{input,  }\item[{const std\+::vector$<$ long $>$}]{mask }\end{DoxyParamCaption})}



Compute a bitwise A\+ND between {\ttfamily input} and a {\ttfamily std\+::vector$<$long$>$}. 

Compute a bitwise A\+ND between {\ttfamily input} and {\ttfamily mask}.


\begin{DoxyParams}{Parameters}
{\em output} & Equal to the output of the A\+ND operation. \\
\hline
{\em input} & Number to A\+ND. \\
\hline
{\em mask} & Number to A\+ND with {\ttfamily input}. This should be a vector of elements of \{0,1\}. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The size of {\ttfamily output} and {\ttfamily input} must be the same. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a6e4ba60fb6ef861f9601a3c22c589315}\label{namespacehelib_a6e4ba60fb6ef861f9601a3c22c589315}} 
\index{helib@{helib}!bitwiseAnd@{bitwiseAnd}}
\index{bitwiseAnd@{bitwiseAnd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{bitwiseAnd()}{bitwiseAnd()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::bitwise\+And (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{rhs }\end{DoxyParamCaption})}



Compute a bitwise A\+ND between {\ttfamily lhs} and {\ttfamily rhs}. 


\begin{DoxyParams}{Parameters}
{\em output} & Result of bitwise {\ttfamily lhs} A\+ND {\ttfamily rhs}. \\
\hline
{\em lhs} & Left operand to the A\+ND operation. \\
\hline
{\em rhs} & Right operand to the A\+ND operation. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\ttfamily output}, {\ttfamily lhs} and {\ttfamily rhs} must all have the same size. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a3bc4da63675257eacdf323d32ca23a83}\label{namespacehelib_a3bc4da63675257eacdf323d32ca23a83}} 
\index{helib@{helib}!bitwiseNot@{bitwiseNot}}
\index{bitwiseNot@{bitwiseNot}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{bitwiseNot()}{bitwiseNot()}}
{\footnotesize\ttfamily void helib\+::bitwise\+Not (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{input }\end{DoxyParamCaption})}



Compute a bitwise N\+OT of {\ttfamily input}. 


\begin{DoxyParams}{Parameters}
{\em output} & Result of bit-\/flipping {\ttfamily input}. \\
\hline
{\em input} & Binary number to be bit-\/flipped. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The size of {\ttfamily output} and {\ttfamily input} must be the same. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a2928d18450500f401e36d50a8288bf0e}\label{namespacehelib_a2928d18450500f401e36d50a8288bf0e}} 
\index{helib@{helib}!bitwiseOr@{bitwiseOr}}
\index{bitwiseOr@{bitwiseOr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{bitwiseOr()}{bitwiseOr()}}
{\footnotesize\ttfamily void helib\+::bitwise\+Or (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{rhs }\end{DoxyParamCaption})}



Compute a bitwise OR between {\ttfamily lhs} and {\ttfamily rhs}. 


\begin{DoxyParams}{Parameters}
{\em output} & Result of bitwise {\ttfamily lhs} OR {\ttfamily rhs}. \\
\hline
{\em lhs} & Left operand to the OR operation. \\
\hline
{\em rhs} & Right operand to the OR operation. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\ttfamily output}, {\ttfamily lhs} and {\ttfamily rhs} must all have the same size. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a7a59ff05d1c4f1800bb2010e451576ab}\label{namespacehelib_a7a59ff05d1c4f1800bb2010e451576ab}} 
\index{helib@{helib}!bitwiseRotate@{bitwiseRotate}}
\index{bitwiseRotate@{bitwiseRotate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{bitwiseRotate()}{bitwiseRotate()}}
{\footnotesize\ttfamily void helib\+::bitwise\+Rotate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{input,  }\item[{long}]{rotamt }\end{DoxyParamCaption})}



Rotate {\ttfamily input} by {\ttfamily rotamt}. 

Rotate binary numbers by {\ttfamily rotamt}.


\begin{DoxyParams}{Parameters}
{\em output} & Rotated result. \\
\hline
{\em input} & The number to be bitwise-\/rotated. \\
\hline
{\em rotamt} & The amount by which to rotate {\ttfamily input}. May be negative for opposite-\/direction rotations. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
For positive {\ttfamily rotamt} arguments, this rotates towards the most-\/significant end (i.\+e. the same direction as left\+Bitwise\+Shift). 

The size of {\ttfamily output} and {\ttfamily input} must be the same. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_abaa682a93edca39cb5ce5524219c486c}\label{namespacehelib_abaa682a93edca39cb5ce5524219c486c}} 
\index{helib@{helib}!bitwiseXOR@{bitwiseXOR}}
\index{bitwiseXOR@{bitwiseXOR}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{bitwiseXOR()}{bitwiseXOR()}}
{\footnotesize\ttfamily void helib\+::bitwise\+X\+OR (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{rhs }\end{DoxyParamCaption})}



Compute a bitwise X\+OR between {\ttfamily lhs} and {\ttfamily rhs}. 


\begin{DoxyParams}{Parameters}
{\em output} & Result of bitwise {\ttfamily lhs} X\+OR {\ttfamily rhs}. \\
\hline
{\em lhs} & Left operand to the X\+OR operation. \\
\hline
{\em rhs} & Right operand to the X\+OR operation. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\ttfamily output}, {\ttfamily lhs} and {\ttfamily rhs} must all have the same size. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_ab66ba03453e871a61eda59e0f8e574af}\label{namespacehelib_ab66ba03453e871a61eda59e0f8e574af}} 
\index{helib@{helib}!BluesteinFFT@{BluesteinFFT}}
\index{BluesteinFFT@{BluesteinFFT}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{BluesteinFFT()}{BluesteinFFT()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::\+Bluestein\+F\+FT (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+pX \&}]{x,  }\item[{long}]{n,  }\item[{const N\+T\+L\+::zz\+\_\+p \&}]{root,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{powers,  }\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::mulmod\+\_\+precon\+\_\+t $>$ \&}]{powers\+\_\+aux,  }\item[{const N\+T\+L\+::fft\+Rep \&}]{Rb }\end{DoxyParamCaption})}



apply bluestein 

\mbox{\Hypertarget{namespacehelib_a76f968f2ead15d0f33947d7f1bc165f5}\label{namespacehelib_a76f968f2ead15d0f33947d7f1bc165f5}} 
\index{helib@{helib}!BluesteinFFT@{BluesteinFFT}}
\index{BluesteinFFT@{BluesteinFFT}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{BluesteinFFT()}{BluesteinFFT()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::\+Bluestein\+F\+FT (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+pX \&}]{x,  }\item[{long}]{n,  }\item[{U\+N\+U\+S\+ED const N\+T\+L\+::zz\+\_\+p \&}]{root,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{powers,  }\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::mulmod\+\_\+precon\+\_\+t $>$ \&}]{powers\+\_\+aux,  }\item[{const N\+T\+L\+::fft\+Rep \&}]{Rb }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac544d20010a35c78a75ce913a2b15979}\label{namespacehelib_ac544d20010a35c78a75ce913a2b15979}} 
\index{helib@{helib}!BluesteinInit@{BluesteinInit}}
\index{BluesteinInit@{BluesteinInit}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{BluesteinInit()}{BluesteinInit()}}
{\footnotesize\ttfamily void helib\+::\+Bluestein\+Init (\begin{DoxyParamCaption}\item[{long}]{n,  }\item[{const N\+T\+L\+::zz\+\_\+p \&}]{root,  }\item[{N\+T\+L\+::zz\+\_\+pX \&}]{powers,  }\item[{N\+T\+L\+::\+Vec$<$ N\+T\+L\+::mulmod\+\_\+precon\+\_\+t $>$ \&}]{powers\+\_\+aux,  }\item[{N\+T\+L\+::fft\+Rep \&}]{Rb }\end{DoxyParamCaption})}



initialize bluestein 

\mbox{\Hypertarget{namespacehelib_a60c561d9f496e4d62c96dfab1e5040a4}\label{namespacehelib_a60c561d9f496e4d62c96dfab1e5040a4}} 
\index{helib@{helib}!boundFreshNoise@{boundFreshNoise}}
\index{boundFreshNoise@{boundFreshNoise}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{boundFreshNoise()}{boundFreshNoise()}}
{\footnotesize\ttfamily double helib\+::bound\+Fresh\+Noise (\begin{DoxyParamCaption}\item[{long}]{m,  }\item[{long}]{phim,  }\item[{double}]{sigma,  }\item[{double}]{epsilon = {\ttfamily 9e-\/13} }\end{DoxyParamCaption})}

Helper functions, return a bound B such that for random noise terms we have Pr\mbox{[}$\vert$canonical\+Embed(noise)$\vert$\+\_\+\{\textbackslash{}infty\} $>$ B\mbox{]} $<$ epsilon. (The default is epsilon = 2$^\wedge$\{-\/40\}.) \mbox{\Hypertarget{namespacehelib_a16658952887fd437cdaccb4ec43b5717}\label{namespacehelib_a16658952887fd437cdaccb4ec43b5717}} 
\index{helib@{helib}!boundRoundingNoise@{boundRoundingNoise}}
\index{boundRoundingNoise@{boundRoundingNoise}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{boundRoundingNoise()}{boundRoundingNoise()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double helib\+::bound\+Rounding\+Noise (\begin{DoxyParamCaption}\item[{long}]{m,  }\item[{long}]{phim,  }\item[{long}]{p2r,  }\item[{double}]{epsilon = {\ttfamily 9e-\/13} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5c4cfecd6dc28011302b7b86d15dbaa9}\label{namespacehelib_a5c4cfecd6dc28011302b7b86d15dbaa9}} 
\index{helib@{helib}!boundRoundingNoise@{boundRoundingNoise}}
\index{boundRoundingNoise@{boundRoundingNoise}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{boundRoundingNoise()}{boundRoundingNoise()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double helib\+::bound\+Rounding\+Noise (\begin{DoxyParamCaption}\item[{U\+N\+U\+S\+ED long}]{m,  }\item[{long}]{phim,  }\item[{long}]{p2r,  }\item[{double}]{epsilon }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a11554e25622d14682edfa2be22ed6df6}\label{namespacehelib_a11554e25622d14682edfa2be22ed6df6}} 
\index{helib@{helib}!breakPermByDim@{breakPermByDim}}
\index{breakPermByDim@{breakPermByDim}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{breakPermByDim()}{breakPermByDim()}}
{\footnotesize\ttfamily void helib\+::break\+Perm\+By\+Dim (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} $>$ \&}]{out,  }\item[{const \mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{pi,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_signature}{Cube\+Signature}} \&}]{sig }\end{DoxyParamCaption})}



Takes a permutation pi over m-\/dimensional cube C=Z\+\_\+\{n1\} x...x Z\+\_\+\{nm\} and expresses pi as a product pi = rho\+\_\+\{2m-\/1\} o ... o rho\+\_\+2 o rho\+\_\+1 where each rho\+\_\+i is a column permutation along one dimension. Specifically for i$<$m, the permutations rho\+\_\+i and rho\+\_\+\{2(m-\/1)-\/i\} permute the i\textquotesingle{}th dimension. 

\mbox{\Hypertarget{namespacehelib_a060e401ccfa17753d928fb1812fa020f}\label{namespacehelib_a060e401ccfa17753d928fb1812fa020f}} 
\index{helib@{helib}!breakPermTo3@{breakPermTo3}}
\index{breakPermTo3@{breakPermTo3}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{breakPermTo3()}{breakPermTo3()}}
{\footnotesize\ttfamily void helib\+::break\+Perm\+To3 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ long $>$ \&}]{pi,  }\item[{long}]{dim,  }\item[{\mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} \&}]{rho1,  }\item[{\mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ long $>$ \&}]{rho2,  }\item[{\mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} \&}]{rho3 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae5435c81f125b4a3b2fddf126601aed2}\label{namespacehelib_ae5435c81f125b4a3b2fddf126601aed2}} 
\index{helib@{helib}!build\_ConstMultiplier@{build\_ConstMultiplier}}
\index{build\_ConstMultiplier@{build\_ConstMultiplier}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{build\_ConstMultiplier()}{build\_ConstMultiplier()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename RX $>$ \\
std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}}$>$ helib\+::build\+\_\+\+Const\+Multiplier (\begin{DoxyParamCaption}\item[{const RX \&}]{poly }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a34b18eda7cc825761797b906e47f9074}\label{namespacehelib_a34b18eda7cc825761797b906e47f9074}} 
\index{helib@{helib}!build\_ConstMultiplier@{build\_ConstMultiplier}}
\index{build\_ConstMultiplier@{build\_ConstMultiplier}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{build\_ConstMultiplier()}{build\_ConstMultiplier()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename RX , typename type $>$ \\
std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}}$>$ helib\+::build\+\_\+\+Const\+Multiplier (\begin{DoxyParamCaption}\item[{const RX \&}]{poly,  }\item[{long}]{dim,  }\item[{long}]{amt,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array_derived}{Encrypted\+Array\+Derived}}$<$ type $>$ \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa7534536bd1101ec60aa4c8fe1ccdf30}\label{namespacehelib_aa7534536bd1101ec60aa4c8fe1ccdf30}} 
\index{helib@{helib}!buildBenesCostTable@{buildBenesCostTable}}
\index{buildBenesCostTable@{buildBenesCostTable}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildBenesCostTable()}{buildBenesCostTable()}}
{\footnotesize\ttfamily void helib\+::build\+Benes\+Cost\+Table (\begin{DoxyParamCaption}\item[{long}]{n,  }\item[{long}]{k,  }\item[{bool}]{good,  }\item[{N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+Vec$<$ long $>$$>$ \&}]{tab }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af02b70fdba8bb78c1f19964759f497b5}\label{namespacehelib_af02b70fdba8bb78c1f19964759f497b5}} 
\index{helib@{helib}!BuildContext@{BuildContext}}
\index{BuildContext@{BuildContext}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{BuildContext()}{BuildContext()}}
{\footnotesize\ttfamily N\+T\+L\+::zz\+\_\+p\+Context helib\+::\+Build\+Context (\begin{DoxyParamCaption}\item[{long}]{p,  }\item[{long}]{maxroot }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adcfd34a416649164e3b01c4af1c8654e}\label{namespacehelib_adcfd34a416649164e3b01c4af1c8654e}} 
\index{helib@{helib}!buildContextFromAscii@{buildContextFromAscii}}
\index{buildContextFromAscii@{buildContextFromAscii}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildContextFromAscii()}{buildContextFromAscii()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_context}{Context}} $>$ helib\+::build\+Context\+From\+Ascii (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a4036006b2d0e378ce2aa90a5332a8d73}\label{namespacehelib_a4036006b2d0e378ce2aa90a5332a8d73}} 
\index{helib@{helib}!buildContextFromBinary@{buildContextFromBinary}}
\index{buildContextFromBinary@{buildContextFromBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildContextFromBinary()}{buildContextFromBinary()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_context}{Context}} $>$ helib\+::build\+Context\+From\+Binary (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acf194ed39fc9a3694d1a11a0cd4c75d4}\label{namespacehelib_acf194ed39fc9a3694d1a11a0cd4c75d4}} 
\index{helib@{helib}!buildEncryptedArray@{buildEncryptedArray}}
\index{buildEncryptedArray@{buildEncryptedArray}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildEncryptedArray()}{buildEncryptedArray()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_encrypted_array_base}{Encrypted\+Array\+Base}} $\ast$ helib\+::build\+Encrypted\+Array (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra_mod}{P\+Algebra\+Mod}} \&}]{al\+Mod,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{G = {\ttfamily NTL\+:\+:ZZX\+:\+:zero()} }\end{DoxyParamCaption})}



A \char`\"{}factory\char`\"{} for building Encrypted\+Arrays. 

\mbox{\Hypertarget{namespacehelib_a7acbf567c5271c1d20df20c6f4fa1714}\label{namespacehelib_a7acbf567c5271c1d20df20c6f4fa1714}} 
\index{helib@{helib}!buildGeneralAutomorphPrecon@{buildGeneralAutomorphPrecon}}
\index{buildGeneralAutomorphPrecon@{buildGeneralAutomorphPrecon}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildGeneralAutomorphPrecon()}{buildGeneralAutomorphPrecon()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{classhelib_1_1_general_automorph_precon}{General\+Automorph\+Precon}}$>$ helib\+::build\+General\+Automorph\+Precon (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{dim,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae78f42668b74b50bfeec97988619350c}\label{namespacehelib_ae78f42668b74b50bfeec97988619350c}} 
\index{helib@{helib}!buildLinPolyCoeffs@{buildLinPolyCoeffs}}
\index{buildLinPolyCoeffs@{buildLinPolyCoeffs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildLinPolyCoeffs()}{buildLinPolyCoeffs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::build\+Lin\+Poly\+Coeffs (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+\+G\+F2E \&}]{C,  }\item[{const N\+T\+L\+::vec\+\_\+\+G\+F2E \&}]{L,  }\item[{long}]{p,  }\item[{long}]{r }\end{DoxyParamCaption})}



A version for G\+F2\+: must be called with p == 2 and r == 1. 

\mbox{\Hypertarget{namespacehelib_a5711dacd10c102835bd585bff52e32c5}\label{namespacehelib_a5711dacd10c102835bd585bff52e32c5}} 
\index{helib@{helib}!buildLinPolyCoeffs@{buildLinPolyCoeffs}}
\index{buildLinPolyCoeffs@{buildLinPolyCoeffs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildLinPolyCoeffs()}{buildLinPolyCoeffs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::build\+Lin\+Poly\+Coeffs (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&}]{C,  }\item[{const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&}]{L,  }\item[{long}]{p,  }\item[{long}]{r }\end{DoxyParamCaption})}



Combination of build\+Lin\+Poly\+Matrix and ppsolve. 

Obtain the linearized polynomial coefficients from a vector L representing the action of a linear map on the standard basis for zz\+\_\+pE over zz\+\_\+p.

N\+TL\textquotesingle{}s current smallint modulus, zz\+\_\+p\+::modulus(), is assumed to be p$^\wedge$r, for p prime, r $>$= 1 integer. \mbox{\Hypertarget{namespacehelib_a82218a5a8f14a790b60cd7f288863b9d}\label{namespacehelib_a82218a5a8f14a790b60cd7f288863b9d}} 
\index{helib@{helib}!buildLinPolyMatrix@{buildLinPolyMatrix}}
\index{buildLinPolyMatrix@{buildLinPolyMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildLinPolyMatrix()}{buildLinPolyMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::build\+Lin\+Poly\+Matrix (\begin{DoxyParamCaption}\item[{N\+T\+L\+::mat\+\_\+\+G\+F2E \&}]{M,  }\item[{long}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7db28e5ca105b114e0c89655eee171b9}\label{namespacehelib_a7db28e5ca105b114e0c89655eee171b9}} 
\index{helib@{helib}!buildLinPolyMatrix@{buildLinPolyMatrix}}
\index{buildLinPolyMatrix@{buildLinPolyMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildLinPolyMatrix()}{buildLinPolyMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::build\+Lin\+Poly\+Matrix (\begin{DoxyParamCaption}\item[{N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&}]{M,  }\item[{long}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_add048fff3de003ad2b670a9ae3ed6f2b}\label{namespacehelib_add048fff3de003ad2b670a9ae3ed6f2b}} 
\index{helib@{helib}!buildLookupTable@{buildLookupTable}}
\index{buildLookupTable@{buildLookupTable}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildLookupTable()}{buildLookupTable()}}
{\footnotesize\ttfamily void helib\+::build\+Lookup\+Table (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{T,  }\item[{std\+::function$<$ double(double)$>$}]{f,  }\item[{long}]{nbits\+\_\+in,  }\item[{long}]{scale\+\_\+in,  }\item[{long}]{sign\+\_\+in,  }\item[{long}]{nbits\+\_\+out,  }\item[{long}]{scale\+\_\+out,  }\item[{long}]{sign\+\_\+out,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}



Built a table-\/lookup for a function in fixed-\/point representation. 

@function build\+Lookup\+Table F\+I\+X\+E\+D-\/\+P\+O\+I\+NT C\+O\+N\+V\+E\+N\+T\+I\+O\+NS\+: Fixed-\/point numbers are specified by a triple (nbits,scale,signed). Such a number is represented as an integer x with nbits bits. If signed == 1, then x is treated as a signed integer in 2\textquotesingle{}s compliment; otherwise it is as an unsigned integer. The value represented by x is x$\ast$2$^\wedge$\{scale\}.

The build\+Lookup\+Table function builds a lookup table T, which can be used in conjunction with the table\+Lookup function above. The size of T will be 2$^\wedge$\{nbits\+\_\+in\}. For every signed integer x with bit-\/size \textquotesingle{}nbits\+\_\+in\textquotesingle{}, we will have T\mbox{[}x\mbox{]} = f(x $\ast$ 2$^\wedge$\{scale\+\_\+in\}) $\ast$ 2$^\wedge$\{-\/scale\+\_\+out\}), rounded to the nearest integer and truncated to \textquotesingle{}nbits\+\_\+out\textquotesingle{} bits. The bits are packed inside the slots, so it is assumed that each slot has enough room to fit these many bits. (Otherwise we only keep as many low-\/order bits as fit in a slot.)

S\+A\+T\+U\+R\+A\+T\+ED A\+R\+I\+T\+H\+M\+E\+T\+IC\+: Applications of f that return a result that is too large to represent in the output format will be converted to the maximum representable value. Similarly, Applications of f that return a result that is too small will be converted to the minimal representable value. (This applies also to applications of f that return infinites, Na\+Ns will just be mapped to zero.) For this to work correctly, you should be working with standard I\+E\+EE arithmetic...which will be the case on almost all platforms.

E\+X\+A\+M\+P\+LE\+:

build\+Lookup\+Table(T, \mbox{[}\mbox{]}(double x)\{ return 1/x;\}, nbits\+\_\+in, scale\+\_\+in, nbits\+\_\+out, scale\+\_\+out, sign\+\_\+out, ea)

will build a lookup table for inversion. \mbox{\Hypertarget{namespacehelib_af68cc874f7e017cd4c35d1ea52739c0f}\label{namespacehelib_af68cc874f7e017cd4c35d1ea52739c0f}} 
\index{helib@{helib}!buildModChain@{buildModChain}}
\index{buildModChain@{buildModChain}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildModChain()}{buildModChain()}}
{\footnotesize\ttfamily void helib\+::build\+Mod\+Chain (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{long}]{n\+Bits,  }\item[{long}]{n\+Dgts = {\ttfamily 3},  }\item[{bool}]{will\+Be\+Bootstrappable = {\ttfamily false},  }\item[{long}]{sk\+Hwt = {\ttfamily 0},  }\item[{long}]{resolution = {\ttfamily 3},  }\item[{long}]{bits\+In\+Special\+Primes = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af7ad5bd5c310b0ad7f96d6e2065e5b2b}\label{namespacehelib_af7ad5bd5c310b0ad7f96d6e2065e5b2b}} 
\index{helib@{helib}!buildPAlgebraMod@{buildPAlgebraMod}}
\index{buildPAlgebraMod@{buildPAlgebraMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildPAlgebraMod()}{buildPAlgebraMod()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_p_algebra_mod_base}{P\+Algebra\+Mod\+Base}} $\ast$ helib\+::build\+P\+Algebra\+Mod (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{z\+M\+Star,  }\item[{long}]{r }\end{DoxyParamCaption})}



Builds a table, of type P\+A\+\_\+\+G\+F2 if p == 2 and r == 1, and P\+A\+\_\+zz\+\_\+p otherwise. 

\mbox{\Hypertarget{namespacehelib_aa512e08a2be7acf51509eb138d53f819}\label{namespacehelib_aa512e08a2be7acf51509eb138d53f819}} 
\index{helib@{helib}!buildRandomBlockMatrix@{buildRandomBlockMatrix}}
\index{buildRandomBlockMatrix@{buildRandomBlockMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildRandomBlockMatrix()}{buildRandomBlockMatrix()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d}{Block\+Mat\+Mul1D}} $\ast$ helib\+::build\+Random\+Block\+Matrix (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{long}]{dim }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a40abf9db3a61a5c21c6f836acbeb8c80}\label{namespacehelib_a40abf9db3a61a5c21c6f836acbeb8c80}} 
\index{helib@{helib}!buildRandomFullBlockMatrix@{buildRandomFullBlockMatrix}}
\index{buildRandomFullBlockMatrix@{buildRandomFullBlockMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildRandomFullBlockMatrix()}{buildRandomFullBlockMatrix()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_block_mat_mul_full}{Block\+Mat\+Mul\+Full}} $\ast$ helib\+::build\+Random\+Full\+Block\+Matrix (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_afb1a434a5001c49cfce898915c2faa51}\label{namespacehelib_afb1a434a5001c49cfce898915c2faa51}} 
\index{helib@{helib}!buildRandomFullMatrix@{buildRandomFullMatrix}}
\index{buildRandomFullMatrix@{buildRandomFullMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildRandomFullMatrix()}{buildRandomFullMatrix()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_mat_mul_full}{Mat\+Mul\+Full}} $\ast$ helib\+::build\+Random\+Full\+Matrix (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac6dcd30d8cce97ee562725b5c096b464}\label{namespacehelib_ac6dcd30d8cce97ee562725b5c096b464}} 
\index{helib@{helib}!buildRandomMatrix@{buildRandomMatrix}}
\index{buildRandomMatrix@{buildRandomMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildRandomMatrix()}{buildRandomMatrix()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_mat_mul1_d}{Mat\+Mul1D}} $\ast$ helib\+::build\+Random\+Matrix (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{long}]{dim }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3f720bf0e8e389648203490dd91630ec}\label{namespacehelib_a3f720bf0e8e389648203490dd91630ec}} 
\index{helib@{helib}!buildRandomMultiBlockMatrix@{buildRandomMultiBlockMatrix}}
\index{buildRandomMultiBlockMatrix@{buildRandomMultiBlockMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildRandomMultiBlockMatrix()}{buildRandomMultiBlockMatrix()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d}{Block\+Mat\+Mul1D}} $\ast$ helib\+::build\+Random\+Multi\+Block\+Matrix (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{long}]{dim }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3080cc6971659bc69c9c758f42300cb9}\label{namespacehelib_a3080cc6971659bc69c9c758f42300cb9}} 
\index{helib@{helib}!buildRandomMultiMatrix@{buildRandomMultiMatrix}}
\index{buildRandomMultiMatrix@{buildRandomMultiMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildRandomMultiMatrix()}{buildRandomMultiMatrix()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_mat_mul1_d}{Mat\+Mul1D}} $\ast$ helib\+::build\+Random\+Multi\+Matrix (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{long}]{dim }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad1b9141d04abb14f7f9fe94ee4d5c9ed}\label{namespacehelib_ad1b9141d04abb14f7f9fe94ee4d5c9ed}} 
\index{helib@{helib}!buildUnpackSlotEncoding@{buildUnpackSlotEncoding}}
\index{buildUnpackSlotEncoding@{buildUnpackSlotEncoding}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{buildUnpackSlotEncoding()}{buildUnpackSlotEncoding()}}
{\footnotesize\ttfamily void helib\+::build\+Unpack\+Slot\+Encoding (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{unpack\+Slot\+Encoding,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a742ec1357ca244079dacd7c1cb2fcb90}\label{namespacehelib_a742ec1357ca244079dacd7c1cb2fcb90}} 
\index{helib@{helib}!calcPolyNormBnd@{calcPolyNormBnd}}
\index{calcPolyNormBnd@{calcPolyNormBnd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{calcPolyNormBnd()}{calcPolyNormBnd()}}
{\footnotesize\ttfamily double helib\+::calc\+Poly\+Norm\+Bnd (\begin{DoxyParamCaption}\item[{long}]{m }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3afe505ae7315e1226c3fd95f8ea3487}\label{namespacehelib_a3afe505ae7315e1226c3fd95f8ea3487}} 
\index{helib@{helib}!calculateMasks@{calculateMasks}}
\index{calculateMasks@{calculateMasks}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{calculateMasks()}{calculateMasks()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T\+XT $>$ \\
\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}$>$ helib\+::calculate\+Masks (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$}]{query,  }\item[{const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{database }\end{DoxyParamCaption})}



Given a query set and a database, calculates a mask of \{0,1\} where 1 signifies a matching element and 0 otherwise. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T\+XT} & type of the query set. Must be a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} or {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ea} & The encrypted array object holding information about the scheme. \\
\hline
{\em query} & The query set to mask against the database. Must be a row vector of the same dimension as the second dimension of the database matrix. \\
\hline
{\em database} & The matrix holding the encrypted database. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The calculated mask. Is the same size as the database. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This is an overloaded function for when the database is encrypted. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_ac65801611ad6b47e4cb4c37bf86e5be5}\label{namespacehelib_ac65801611ad6b47e4cb4c37bf86e5be5}} 
\index{helib@{helib}!calculateMasks@{calculateMasks}}
\index{calculateMasks@{calculateMasks}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{calculateMasks()}{calculateMasks()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T\+XT $>$ \\
\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$T\+XT$>$ helib\+::calculate\+Masks (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$}]{query,  }\item[{const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$$>$ \&}]{database }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given a query set and a database, calculates a mask of \{0,1\} where 1 signifies a matching element and 0 otherwise. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T\+XT} & type of the query set. Must be a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} or {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ea} & The encrypted array object holding information about the scheme. \\
\hline
{\em query} & The query set to mask against the database. Must be a row vector of the same dimension as the second dimension of the database matrix. \\
\hline
{\em database} & The matrix holding the plaintext database. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The calculated mask. Is the same size as the database. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This is an overloaded function for when the database is not encrypted. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a78b9e18a6520b9b54c6adc3096bdaf87}\label{namespacehelib_a78b9e18a6520b9b54c6adc3096bdaf87}} 
\index{helib@{helib}!calculateScores@{calculateScores}}
\index{calculateScores@{calculateScores}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{calculateScores()}{calculateScores()}}
{\footnotesize\ttfamily template$<$typename T\+XT $>$ \\
\mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$T\+XT$>$ helib\+::calculate\+Scores (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ long $>$$>$}]{index\+\_\+sets,  }\item[{const std\+::vector$<$ long $>$ \&}]{offsets,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ long $>$$>$ \&}]{weights,  }\item[{const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T\+XT $>$ \&}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given a mask and information about the query to be performed, calculates a score for each matching element signified by the mask. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T\+XT} & type of the mask matrix. Must be a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} or {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em index\+\_\+sets} & The set of indicies signifying which columns of the mask to query. \\
\hline
{\em offsets} & The constant term to be added to the final score of each queried column. \\
\hline
{\em weights} & The weighted importance assigned to each queried column. \\
\hline
{\em mask} & The mask with which to calculate the score from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A single {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}} or {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} containing the total score for each queried column. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_a11746f6a5bcf33d5667cfaae083f3e35}\label{namespacehelib_a11746f6a5bcf33d5667cfaae083f3e35}} 
\index{helib@{helib}!calculateSetIntersection@{calculateSetIntersection}}
\index{calculateSetIntersection@{calculateSetIntersection}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{calculateSetIntersection()}{calculateSetIntersection()}}
{\footnotesize\ttfamily template$<$typename T\+XT $>$ \\
T\+XT helib\+::calculate\+Set\+Intersection (\begin{DoxyParamCaption}\item[{const T\+XT \&}]{query,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{server\+\_\+set }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given two sets, calculates and returns the set intersection. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T\+XT} & type of the query set. Must be a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} or {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em query} & The query set of type {\ttfamily T\+XT} where the elements of the set are held in the slots. \\
\hline
{\em server\+\_\+set} & The server set. A vector of integer polynomials. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A set of the same size as {\ttfamily query} holding the elements in the intersecting set. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_ab2d7f36557c69a4840112f35af186a29}\label{namespacehelib_ab2d7f36557c69a4840112f35af186a29}} 
\index{helib@{helib}!card@{card}}
\index{card@{card}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{card()}{card()}}
{\footnotesize\ttfamily long helib\+::card (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s }\end{DoxyParamCaption})}



Functional cardinality. 

\mbox{\Hypertarget{namespacehelib_a887b96d1f7918079c15b6fa1d8cbfae4}\label{namespacehelib_a887b96d1f7918079c15b6fa1d8cbfae4}} 
\index{helib@{helib}!CheckCtxt@{CheckCtxt}}
\index{CheckCtxt@{CheckCtxt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CheckCtxt()}{CheckCtxt()}}
{\footnotesize\ttfamily void helib\+::\+Check\+Ctxt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{c,  }\item[{const char $\ast$}]{label }\end{DoxyParamCaption})}



print to cerr some info about ciphertext 

\mbox{\Hypertarget{namespacehelib_ac845c61472e33fa76df608e536b25b5a}\label{namespacehelib_ac845c61472e33fa76df608e536b25b5a}} 
\index{helib@{helib}!checkNoise@{checkNoise}}
\index{checkNoise@{checkNoise}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{checkNoise()}{checkNoise()}}
{\footnotesize\ttfamily void helib\+::check\+Noise (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk,  }\item[{const std\+::string \&}]{msg,  }\item[{double}]{thresh = {\ttfamily 10.0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5ec3f9852eabd8796caf38d347501acd}\label{namespacehelib_a5ec3f9852eabd8796caf38d347501acd}} 
\index{helib@{helib}!CKKS\_canonicalEmbedding@{CKKS\_canonicalEmbedding}}
\index{CKKS\_canonicalEmbedding@{CKKS\_canonicalEmbedding}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CKKS\_canonicalEmbedding()}{CKKS\_canonicalEmbedding()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::\+C\+K\+K\+S\+\_\+canonical\+Embedding (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&}]{v,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7cd57ab6741a87f8b261d0a1417b8c5b}\label{namespacehelib_a7cd57ab6741a87f8b261d0a1417b8c5b}} 
\index{helib@{helib}!CKKS\_canonicalEmbedding@{CKKS\_canonicalEmbedding}}
\index{CKKS\_canonicalEmbedding@{CKKS\_canonicalEmbedding}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CKKS\_canonicalEmbedding()}{CKKS\_canonicalEmbedding()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void helib\+::\+C\+K\+K\+S\+\_\+canonical\+Embedding (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&}]{v,  }\item[{const std\+::vector$<$ double $>$ \&}]{f,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_affe1779765ee918f4c7e869ed86baf6a}\label{namespacehelib_affe1779765ee918f4c7e869ed86baf6a}} 
\index{helib@{helib}!CKKS\_canonicalEmbedding@{CKKS\_canonicalEmbedding}}
\index{CKKS\_canonicalEmbedding@{CKKS\_canonicalEmbedding}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CKKS\_canonicalEmbedding()}{CKKS\_canonicalEmbedding()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::\+C\+K\+K\+S\+\_\+canonical\+Embedding (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{f,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

Computes canonical embedding. Requires p==-\/1 and m==2$^\wedge$k where k $>$=2 and f.\+length() $<$ m/2. Sets v\mbox{[}m/4-\/1-\/i\mbox{]} = D\+FT\mbox{[}palg.\+ith\+\_\+rep(i)\mbox{]} for i in range(m/4), where D\+FT\mbox{[}j\mbox{]} = f(\+W$^\wedge$j) for j in range(m), and W = exp(-\/2$\ast$pi$\ast$\+I/m). \mbox{\Hypertarget{namespacehelib_a5ec40f00efeb846267027bd14353fe4a}\label{namespacehelib_a5ec40f00efeb846267027bd14353fe4a}} 
\index{helib@{helib}!CKKS\_embedInSlots@{CKKS\_embedInSlots}}
\index{CKKS\_embedInSlots@{CKKS\_embedInSlots}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CKKS\_embedInSlots()}{CKKS\_embedInSlots()}}
{\footnotesize\ttfamily void helib\+::\+C\+K\+K\+S\+\_\+embed\+In\+Slots (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{f,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a719cb433e43e9f4a88ada8b72d3b715d}{cx\+\_\+double}} $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg,  }\item[{double}]{scaling }\end{DoxyParamCaption})}

Requires p==-\/1 and m==2$^\wedge$k where k $>$=2. Computes the inverse of canonical embedding, scaled by scaling and then rounded to nearest integer. \mbox{\Hypertarget{namespacehelib_aaa77bdb78bd529a55c239df60039e335}\label{namespacehelib_aaa77bdb78bd529a55c239df60039e335}} 
\index{helib@{helib}!cleanupDebugGlobals@{cleanupDebugGlobals}}
\index{cleanupDebugGlobals@{cleanupDebugGlobals}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{cleanupDebugGlobals()}{cleanupDebugGlobals()}}
{\footnotesize\ttfamily void helib\+::cleanup\+Debug\+Globals (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Cleanup function for clearing the global debug variables. 

\mbox{\Hypertarget{namespacehelib_ada22455ae91e6bacc49e719536a8c5da}\label{namespacehelib_ada22455ae91e6bacc49e719536a8c5da}} 
\index{helib@{helib}!clear@{clear}}
\index{clear@{clear}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily void helib\+::clear (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a3b607a9ca070971badf105209dc47583}\label{namespacehelib_a3b607a9ca070971badf105209dc47583}} 
\index{helib@{helib}!closeToOne@{closeToOne}}
\index{closeToOne@{closeToOne}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{closeToOne()}{closeToOne()}}
{\footnotesize\ttfamily bool helib\+::close\+To\+One (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::xdouble \&}]{x,  }\item[{long}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a3f7865779ff5d7047037583852782963}\label{namespacehelib_a3f7865779ff5d7047037583852782963}} 
\index{helib@{helib}!coeffsL2Norm@{coeffsL2Norm}}
\index{coeffsL2Norm@{coeffsL2Norm}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{coeffsL2Norm()}{coeffsL2Norm()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::coeffs\+L2\+Norm (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a3ae9e83dde78e745c57a36e18fc4372b}\label{namespacehelib_a3ae9e83dde78e745c57a36e18fc4372b}} 
\index{helib@{helib}!coeffsL2Norm@{coeffsL2Norm}}
\index{coeffsL2Norm@{coeffsL2Norm}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{coeffsL2Norm()}{coeffsL2Norm()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::coeffs\+L2\+Norm (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a52c99506d6fcb0a0f0611a555e77fab3}\label{namespacehelib_a52c99506d6fcb0a0f0611a555e77fab3}} 
\index{helib@{helib}!coeffsL2Norm@{coeffsL2Norm}}
\index{coeffsL2Norm@{coeffsL2Norm}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{coeffsL2Norm()}{coeffsL2Norm()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily double helib\+::coeffs\+L2\+Norm (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ac39c73d6b51367807eca721bb748aadc}\label{namespacehelib_ac39c73d6b51367807eca721bb748aadc}} 
\index{helib@{helib}!coeffsL2NormSquared@{coeffsL2NormSquared}}
\index{coeffsL2NormSquared@{coeffsL2NormSquared}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{coeffsL2NormSquared()}{coeffsL2NormSquared()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::coeffs\+L2\+Norm\+Squared (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a09fe1adbf8a3a923231957865d6f7ade}\label{namespacehelib_a09fe1adbf8a3a923231957865d6f7ade}} 
\index{helib@{helib}!coeffsL2NormSquared@{coeffsL2NormSquared}}
\index{coeffsL2NormSquared@{coeffsL2NormSquared}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{coeffsL2NormSquared()}{coeffsL2NormSquared()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::coeffs\+L2\+Norm\+Squared (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a05eeef94d05d407f020712567c5eef27}\label{namespacehelib_a05eeef94d05d407f020712567c5eef27}} 
\index{helib@{helib}!coeffsL2NormSquared@{coeffsL2NormSquared}}
\index{coeffsL2NormSquared@{coeffsL2NormSquared}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{coeffsL2NormSquared()}{coeffsL2NormSquared()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily double helib\+::coeffs\+L2\+Norm\+Squared (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{f }\end{DoxyParamCaption})}



The L2-\/norm of an element (in coefficient representation) 

\mbox{\Hypertarget{namespacehelib_aed4e8a7e6a0c99087b87431d7478e4d6}\label{namespacehelib_aed4e8a7e6a0c99087b87431d7478e4d6}} 
\index{helib@{helib}!comparePAlgebra@{comparePAlgebra}}
\index{comparePAlgebra@{comparePAlgebra}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{comparePAlgebra()}{comparePAlgebra()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool helib\+::compare\+P\+Algebra (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg,  }\item[{unsigned long}]{m,  }\item[{unsigned long}]{p,  }\item[{unsigned long}]{r,  }\item[{const std\+::vector$<$ long $>$ \&}]{gens,  }\item[{const std\+::vector$<$ long $>$ \&}]{ords }\end{DoxyParamCaption})}



returns true if the palg parameters match the rest, false otherwise 

\mbox{\Hypertarget{namespacehelib_ad733002556086f79ab0153f09916d2be}\label{namespacehelib_ad733002556086f79ab0153f09916d2be}} 
\index{helib@{helib}!comparePAlgebra@{comparePAlgebra}}
\index{comparePAlgebra@{comparePAlgebra}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{comparePAlgebra()}{comparePAlgebra()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool helib\+::compare\+P\+Algebra (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg,  }\item[{unsigned long}]{m,  }\item[{unsigned long}]{p,  }\item[{U\+N\+U\+S\+ED unsigned long}]{r,  }\item[{const std\+::vector$<$ long $>$ \&}]{gens,  }\item[{const std\+::vector$<$ long $>$ \&}]{ords }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2eda8a61661cec76566fb5c6f475eb24}\label{namespacehelib_a2eda8a61661cec76566fb5c6f475eb24}} 
\index{helib@{helib}!compareTwoNumbers@{compareTwoNumbers}}
\index{compareTwoNumbers@{compareTwoNumbers}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{compareTwoNumbers()}{compareTwoNumbers()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::compare\+Two\+Numbers (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{max,  }\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{min,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{mu,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ni,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{b,  }\item[{bool}]{twos\+Complement = {\ttfamily false},  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Compares two integers in binary {\ttfamily a}, {\ttfamily b}. Returns {\ttfamily max(a, b)}, {\ttfamily min(a, b)} and indicator bits {\ttfamily mu}=({\ttfamily a}$>${\ttfamily b}) and {\ttfamily ni}=({\ttfamily a}$<${\ttfamily b}) 


\begin{DoxyParams}{Parameters}
{\em max} & Maximum of {\ttfamily a} and {\ttfamily b}. \\
\hline
{\em min} & Minimum of {\ttfamily a} and {\ttfamily b}. \\
\hline
{\em mu} & Indicator bits {\ttfamily mu}=({\ttfamily a}$>${\ttfamily b}). \\
\hline
{\em ni} & Indicator bits {\ttfamily ni}=({\ttfamily a}$<${\ttfamily b}). \\
\hline
{\em a} & First number to compare. \\
\hline
{\em b} & Second number to compare. \\
\hline
{\em twos\+Complement} & When set to {\ttfamily true}, the inputs are signed integers in 2\textquotesingle{}s complement. If set to {\ttfamily false} (default), unsigned comparison is performed. \\
\hline
{\em unpack\+Slot\+Encoding} & Vector of constants for unpacking, as used in bootstrapping. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If {\ttfamily a}={\ttfamily b} then {\ttfamily mu}={\ttfamily ni}={\ttfamily 0} 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_ad7d423993b1ba7f3a05bb0184d6e5dd8}\label{namespacehelib_ad7d423993b1ba7f3a05bb0184d6e5dd8}} 
\index{helib@{helib}!compareTwoNumbers@{compareTwoNumbers}}
\index{compareTwoNumbers@{compareTwoNumbers}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{compareTwoNumbers()}{compareTwoNumbers()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::compare\+Two\+Numbers (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{mu,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ni,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{b,  }\item[{bool}]{twos\+Complement = {\ttfamily false},  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Compares two integers in binary {\ttfamily a}, {\ttfamily b}. Returns only indicator bits {\ttfamily mu}=({\ttfamily a}$>${\ttfamily b}) and {\ttfamily ni}=({\ttfamily a}$<${\ttfamily b}). 


\begin{DoxyParams}{Parameters}
{\em mu} & Indicator bits {\ttfamily mu}=({\ttfamily a}$>${\ttfamily b}). \\
\hline
{\em ni} & Indicator bits {\ttfamily ni}=({\ttfamily a}$<${\ttfamily b}). \\
\hline
{\em a} & First number to compare. \\
\hline
{\em b} & Second number to compare. \\
\hline
{\em twos\+Complement} & When set to {\ttfamily true}, the inputs are signed integers in 2\textquotesingle{}s complement. If set to {\ttfamily false} (default), unsigned comparison is performed. \\
\hline
{\em unpack\+Slot\+Encoding} & Vector of constants for unpacking, as used in bootstrapping. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If {\ttfamily a}={\ttfamily b} then {\ttfamily mu}={\ttfamily ni}={\ttfamily 0} 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_aa6a682bb0c0c84f0d6eaddde8fd2f8b9}\label{namespacehelib_aa6a682bb0c0c84f0d6eaddde8fd2f8b9}} 
\index{helib@{helib}!compareTwoNumbersImplementation@{compareTwoNumbersImplementation}}
\index{compareTwoNumbersImplementation@{compareTwoNumbersImplementation}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{compareTwoNumbersImplementation()}{compareTwoNumbersImplementation()}}
{\footnotesize\ttfamily void helib\+::compare\+Two\+Numbers\+Implementation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{max,  }\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{min,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{mu,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ni,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{aa,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{bb,  }\item[{bool}]{twos\+Complement,  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding,  }\item[{bool}]{cmp\+\_\+only }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa13b0418c17fe6b26a2006507d2b57ac}\label{namespacehelib_aa13b0418c17fe6b26a2006507d2b57ac}} 
\index{helib@{helib}!computeAllProducts@{computeAllProducts}}
\index{computeAllProducts@{computeAllProducts}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{computeAllProducts()}{computeAllProducts()}}
{\footnotesize\ttfamily void helib\+::compute\+All\+Products (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{products,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{array,  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}

For an n-\/size array, compute the 2$^\wedge$n products products\mbox{[}j\mbox{]} = \textbackslash{}prod\+\_\+\{i s.\+t. j\+\_\+i=1\} array\mbox{[}i\mbox{]} \textbackslash{}times \textbackslash{}prod\+\_\+\{i s.\+t. j\+\_\+i=0\}(a-\/array\mbox{[}i\mbox{]}) \mbox{\Hypertarget{namespacehelib_a5db58bd9f9ec928c07dc95b2bd2aa26b}\label{namespacehelib_a5db58bd9f9ec928c07dc95b2bd2aa26b}} 
\index{helib@{helib}!computeDivVec@{computeDivVec}}
\index{computeDivVec@{computeDivVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{computeDivVec()}{computeDivVec()}}
{\footnotesize\ttfamily void helib\+::compute\+Div\+Vec (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{div\+Vec,  }\item[{long}]{m,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{pow\+Vec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_abf8bfb70b1212c781ee1c510a2f456cf}\label{namespacehelib_abf8bfb70b1212c781ee1c510a2f456cf}} 
\index{helib@{helib}!computeIntervalForMul@{computeIntervalForMul}}
\index{computeIntervalForMul@{computeIntervalForMul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{computeIntervalForMul()}{computeIntervalForMul()}}
{\footnotesize\ttfamily void helib\+::compute\+Interval\+For\+Mul (\begin{DoxyParamCaption}\item[{double \&}]{lo,  }\item[{double \&}]{hi,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9e5b39e20fa9f25946cbd4f0064c32a1}\label{namespacehelib_a9e5b39e20fa9f25946cbd4f0064c32a1}} 
\index{helib@{helib}!computeIntervalForSqr@{computeIntervalForSqr}}
\index{computeIntervalForSqr@{computeIntervalForSqr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{computeIntervalForSqr()}{computeIntervalForSqr()}}
{\footnotesize\ttfamily void helib\+::compute\+Interval\+For\+Sqr (\begin{DoxyParamCaption}\item[{double \&}]{lo,  }\item[{double \&}]{hi,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aacdc9f121e0356fcc0c2d469126da20c}\label{namespacehelib_aacdc9f121e0356fcc0c2d469126da20c}} 
\index{helib@{helib}!computeInvVec@{computeInvVec}}
\index{computeInvVec@{computeInvVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{computeInvVec()}{computeInvVec()}}
{\footnotesize\ttfamily void helib\+::compute\+Inv\+Vec (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{inv\+Vec,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{div\+Vec,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{pow\+Vec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_af1c49d134949a4cf5cc7ef6c0ffa1206}\label{namespacehelib_af1c49d134949a4cf5cc7ef6c0ffa1206}} 
\index{helib@{helib}!ComputeOneGenMapping@{ComputeOneGenMapping}}
\index{ComputeOneGenMapping@{ComputeOneGenMapping}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ComputeOneGenMapping()}{ComputeOneGenMapping()}}
{\footnotesize\ttfamily void helib\+::\+Compute\+One\+Gen\+Mapping (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{gen\+Map,  }\item[{const \mbox{\hyperlink{namespacehelib_a22b83b7df1af539c07c804d7888448ce}{One\+Generator\+Tree}} \&}]{T }\end{DoxyParamCaption})}



to a single generator tree 

\mbox{\Hypertarget{namespacehelib_a9837bdade0e2dabb7bbf0d03a5e2e93b}\label{namespacehelib_a9837bdade0e2dabb7bbf0d03a5e2e93b}} 
\index{helib@{helib}!computeProd@{computeProd}}
\index{computeProd@{computeProd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{computeProd()}{computeProd()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily long helib\+::compute\+Prod (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{vec }\end{DoxyParamCaption})}



returns \textbackslash{}prod\+\_\+d vec\mbox{[}d\mbox{]} 

\mbox{\Hypertarget{namespacehelib_aababf76c7325db9e7409cf950a581993}\label{namespacehelib_aababf76c7325db9e7409cf950a581993}} 
\index{helib@{helib}!computeProd@{computeProd}}
\index{computeProd@{computeProd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{computeProd()}{computeProd()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily long helib\+::compute\+Prod (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ long $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab31dff00b9bd2df3454c7dc7a7edf16b}\label{namespacehelib_ab31dff00b9bd2df3454c7dc7a7edf16b}} 
\index{helib@{helib}!concatBinaryNums@{concatBinaryNums}}
\index{concatBinaryNums@{concatBinaryNums}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{concatBinaryNums()}{concatBinaryNums()}}
{\footnotesize\ttfamily void helib\+::concat\+Binary\+Nums (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{b }\end{DoxyParamCaption})}



Concatenates two binary numbers into a single {\ttfamily Ct\+Ptrs} object. E.\+g. If {\ttfamily a=10111}, {\ttfamily b=00101} then {\ttfamily output = 1011100101}. 

Concatenate two binary numbers into a single {\ttfamily Ct\+Ptrs} object.


\begin{DoxyParams}{Parameters}
{\em output} & Equal to the concatenation of {\ttfamily a} and {\ttfamily b}. \\
\hline
{\em a} & First number to copy into {\ttfamily output}. \\
\hline
{\em b} & Second number to concatenate to {\ttfamily a}. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The size of {\ttfamily output} must be of size {\ttfamily a.\+size() + b.\+size()}. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_af5a79c25bb9e1285c93b486ce07c4d52}\label{namespacehelib_af5a79c25bb9e1285c93b486ce07c4d52}} 
\index{helib@{helib}!conv@{conv}}
\index{conv@{conv}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{conv()}{conv()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::conv (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{d,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a5f5fe8f0918a6b964a75728b61d15c2c}\label{namespacehelib_a5f5fe8f0918a6b964a75728b61d15c2c}} 
\index{helib@{helib}!conv@{conv}}
\index{conv@{conv}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{conv()}{conv()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::conv (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{p,  }\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{d }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a194a7e93c41b4da649614c39e9a77c8f}\label{namespacehelib_a194a7e93c41b4da649614c39e9a77c8f}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/18]}}
{\footnotesize\ttfamily template$<$typename T1 , typename T2 $>$ \\
T1 helib\+::convert (\begin{DoxyParamCaption}\item[{const T2 \&}]{v2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a877d5bbaf6ad7ef25042c6711e6a6aa2}\label{namespacehelib_a877d5bbaf6ad7ef25042c6711e6a6aa2}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{long \&}]{x1,  }\item[{const N\+T\+L\+::\+G\+F2X \&}]{x2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ad7d74d8c1673da0da8d2d53a9f56f30a}\label{namespacehelib_ad7d74d8c1673da0da8d2d53a9f56f30a}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [3/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{long \&}]{x1,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{x2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a4b9c95cba9d0a0f6f4a8220548276003}\label{namespacehelib_a4b9c95cba9d0a0f6f4a8220548276003}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [4/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+G\+F2X \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{in }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa20c6011cba88e302d44bb0db4a6e7f8}\label{namespacehelib_aa20c6011cba88e302d44bb0db4a6e7f8}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [5/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&}]{X,  }\item[{const std\+::vector$<$ std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$$>$ \&}]{A }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a195d039398c66533aa7a1ba455ffcd4b}\label{namespacehelib_a195d039398c66533aa7a1ba455ffcd4b}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [6/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+G\+F2X \&}]{in }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1eb539ffd2cd2268861ad793f88f6393}\label{namespacehelib_a1eb539ffd2cd2268861ad793f88f6393}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [7/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{out,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{in,  }\item[{bool}]{symmetric = {\ttfamily true} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7508506eab50bf677b80d5dc6669c980}\label{namespacehelib_a7508506eab50bf677b80d5dc6669c980}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [8/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{in }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a33593bb6e050f5639138bf3f76a28d8c}\label{namespacehelib_a33593bb6e050f5639138bf3f76a28d8c}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [9/18]}}
{\footnotesize\ttfamily template$<$typename T1 , typename T2 $>$ \\
void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T1 $>$ \&}]{v1,  }\item[{const std\+::vector$<$ T2 $>$ \&}]{v2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_afea2ca2bb25fb996d1d3544a353d83eb}\label{namespacehelib_afea2ca2bb25fb996d1d3544a353d83eb}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [10/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&}]{X,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{A }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a4d6406c9fda9c55cde649bc033ad7317}\label{namespacehelib_a4d6406c9fda9c55cde649bc033ad7317}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [11/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+pX \&}]{x,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_af3ddd5fc2763e981326700c9dcc2e777}\label{namespacehelib_af3ddd5fc2763e981326700c9dcc2e777}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [12/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{in }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af1ec8745473d116541a8b302dfa70fa9}\label{namespacehelib_af1ec8745473d116541a8b302dfa70fa9}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [13/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{X,  }\item[{const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&}]{A }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a89daf2e69e1e8c09c09311b1430021f4}\label{namespacehelib_a89daf2e69e1e8c09c09311b1430021f4}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [14/18]}}
{\footnotesize\ttfamily void helib\+::convert (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$$>$ \&}]{X,  }\item[{const N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&}]{A }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa59b9ea3393970dcb1c4a9ef6ef310ef}\label{namespacehelib_aa59b9ea3393970dcb1c4a9ef6ef310ef}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [15/18]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::convert (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v1,  }\item[{const std\+::vector$<$ T $>$ \&}]{v2 }\end{DoxyParamCaption})}



Trivial type conversion, useful for generic code. 

\mbox{\Hypertarget{namespacehelib_ab5d8cacfd0370294ae07fb571ee2caee}\label{namespacehelib_ab5d8cacfd0370294ae07fb571ee2caee}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [16/18]}}
{\footnotesize\ttfamily template$<$typename T1 , typename T2 $>$ \\
void helib\+::convert (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T1 $>$ \&}]{v1,  }\item[{const N\+T\+L\+::\+Vec$<$ T2 $>$ \&}]{v2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a59e1e9edc58b546c8d12a4cb56812f81}\label{namespacehelib_a59e1e9edc58b546c8d12a4cb56812f81}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [17/18]}}
{\footnotesize\ttfamily template$<$typename T1 , typename T2 $>$ \\
void helib\+::convert (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T1 $>$ \&}]{v1,  }\item[{const std\+::vector$<$ T2 $>$ \&}]{v2 }\end{DoxyParamCaption})}



generic vector conversion routines 

\mbox{\Hypertarget{namespacehelib_ab2e47ad408b14cf352174243c3c8adf6}\label{namespacehelib_ab2e47ad408b14cf352174243c3c8adf6}} 
\index{helib@{helib}!convert@{convert}}
\index{convert@{convert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}\hspace{0.1cm}{\footnotesize\ttfamily [18/18]}}
{\footnotesize\ttfamily template$<$typename T1 , typename T2 $>$ \\
void helib\+::convert (\begin{DoxyParamCaption}\item[{T1 \&}]{x1,  }\item[{const T2 \&}]{x2 }\end{DoxyParamCaption})}



A generic template that resolves to N\+TL\textquotesingle{}s conv routine. 

\mbox{\Hypertarget{namespacehelib_ae05ae4d1e5789165fa5fe70824e87077}\label{namespacehelib_ae05ae4d1e5789165fa5fe70824e87077}} 
\index{helib@{helib}!convertDataToSlotVector@{convertDataToSlotVector}}
\index{convertDataToSlotVector@{convertDataToSlotVector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{convertDataToSlotVector()}{convertDataToSlotVector()}}
{\footnotesize\ttfamily template$<$typename From , typename Scheme $>$ \\
std\+::vector$<$typename Scheme\+::\+Slot\+Type$>$ helib\+::convert\+Data\+To\+Slot\+Vector (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ From $>$ \&}]{data,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Converts {\ttfamily std\+::vector$<$From$>$} to {\ttfamily std\+::vector$<$Scheme\+::\+Slot\+Type$>$}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em From} & Type of the element in the input vector. \\
\hline
{\em Scheme} & The encryption scheme to be used, must be {\ttfamily \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}} or {\ttfamily \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & Vector to be converted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of converted values of type {\ttfamily Scheme\+::\+Slot\+Type}. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Only exists for {\ttfamily \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}} and {\ttfamily \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}}. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_afcde52d4dcf5f9f26931c54efa401258}\label{namespacehelib_afcde52d4dcf5f9f26931c54efa401258}} 
\index{helib@{helib}!CRTcoeff@{CRTcoeff}}
\index{CRTcoeff@{CRTcoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CRTcoeff()}{CRTcoeff()}}
{\footnotesize\ttfamily long helib\+::\+C\+R\+Tcoeff (\begin{DoxyParamCaption}\item[{long}]{p,  }\item[{long}]{q,  }\item[{bool}]{symmetric = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a C\+RT coefficient\+: x = (0 mod p, 1 mod q). If symmetric is set then x \textbackslash{}in \mbox{[}-\/pq/2, pq/2), else x \textbackslash{}in \mbox{[}0,pq) 

\mbox{\Hypertarget{namespacehelib_a181a74dc451ffc410450d6c238f2a68c}\label{namespacehelib_a181a74dc451ffc410450d6c238f2a68c}} 
\index{helib@{helib}!Cyclotomic@{Cyclotomic}}
\index{Cyclotomic@{Cyclotomic}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{Cyclotomic()}{Cyclotomic()}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::\+Cyclotomic (\begin{DoxyParamCaption}\item[{long}]{N }\end{DoxyParamCaption})}



Compute cyclotomic polynomial. 

\mbox{\Hypertarget{namespacehelib_a7d7757fc124c051547f6d8d62f57e6ee}\label{namespacehelib_a7d7757fc124c051547f6d8d62f57e6ee}} 
\index{helib@{helib}!decode@{decode}}
\index{decode@{decode}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{decode()}{decode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::decode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{std\+::vector$<$ long $>$ \&}]{array,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a37ce1cf83ebb14807ec5fd0ecebd03be}\label{namespacehelib_a37ce1cf83ebb14807ec5fd0ecebd03be}} 
\index{helib@{helib}!decode@{decode}}
\index{decode@{decode}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{decode()}{decode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::decode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{array,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a19a60ea778c6bbcc5d2732ca137c7e15}\label{namespacehelib_a19a60ea778c6bbcc5d2732ca137c7e15}} 
\index{helib@{helib}!decryptAndCompare@{decryptAndCompare}}
\index{decryptAndCompare@{decryptAndCompare}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{decryptAndCompare()}{decryptAndCompare()}}
{\footnotesize\ttfamily bool helib\+::decrypt\+And\+Compare (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a436a592900880109024757d11bb3949d}\label{namespacehelib_a436a592900880109024757d11bb3949d}} 
\index{helib@{helib}!decryptAndPrint@{decryptAndPrint}}
\index{decryptAndPrint@{decryptAndPrint}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{decryptAndPrint()}{decryptAndPrint()}}
{\footnotesize\ttfamily void helib\+::decrypt\+And\+Print (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{long}]{flags = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1285dad7ef04a62fde04003b87ee1110}\label{namespacehelib_a1285dad7ef04a62fde04003b87ee1110}} 
\index{helib@{helib}!decryptBinaryNums@{decryptBinaryNums}}
\index{decryptBinaryNums@{decryptBinaryNums}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{decryptBinaryNums()}{decryptBinaryNums()}}
{\footnotesize\ttfamily void helib\+::decrypt\+Binary\+Nums (\begin{DoxyParamCaption}\item[{std\+::vector$<$ long $>$ \&}]{p\+Nums,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{e\+Nums,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{s\+Key,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{bool}]{twos\+Complement = {\ttfamily false},  }\item[{bool}]{all\+Slots = {\ttfamily true} }\end{DoxyParamCaption})}



Decrypt the binary numbers that are encrypted in e\+Nums. 


\begin{DoxyParams}{Parameters}
{\em p\+Nums} & vector to decrypt the binary numbers into. \\
\hline
{\em e\+Nums} & encrypted binary numbers of which to be decrypted. \\
\hline
{\em s\+Key} & secret key used for decryption. \\
\hline
{\em ea} & encrypted array that holds necessary information for decryption. \\
\hline
{\em twos\+Complement} & when set to true, the number to decrypt is a signed integer in 2\textquotesingle{}s complement. \\
\hline
{\em all\+Slots} & when set to false, return only the sub-\/cube with index=0 in the last dimension within each ciphertext.\\
\hline
\end{DoxyParams}
The bits are encrypted in a bit-\/sliced manner. Namely, enc\+Nums\mbox{[}0\mbox{]} contains the L\+SB of all the numbers, enc\+Nums\mbox{[}1\mbox{]} the next bits from all, etc. If twos\+Complement==true then the number is interpreted as a signed integer in 2\textquotesingle{}s-\/complement representation. If all\+Slots==false then we only return the subcube with index i=0 in the last dimension within each ciphertext. Namely, the bit for the j\textquotesingle{}th counter is found in slot of index j$\ast$size\+Of(last\+Dim). \mbox{\Hypertarget{namespacehelib_aa19a69725c1500ca956f0a89dd7226e8}\label{namespacehelib_aa19a69725c1500ca956f0a89dd7226e8}} 
\index{helib@{helib}!defaultPmiddle@{defaultPmiddle}}
\index{defaultPmiddle@{defaultPmiddle}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{defaultPmiddle()}{defaultPmiddle()}}
{\footnotesize\ttfamily long helib\+::default\+Pmiddle (\begin{DoxyParamCaption}\item[{long}]{delta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a7ae485ed628fe5d0b73b7fc80efcfb36}\label{namespacehelib_a7ae485ed628fe5d0b73b7fc80efcfb36}} 
\index{helib@{helib}!defaultQmiddle@{defaultQmiddle}}
\index{defaultQmiddle@{defaultQmiddle}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{defaultQmiddle()}{defaultQmiddle()}}
{\footnotesize\ttfamily long helib\+::default\+Qmiddle (\begin{DoxyParamCaption}\item[{long}]{delta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a511bb2a1c3583d18b858d5362489139c}\label{namespacehelib_a511bb2a1c3583d18b858d5362489139c}} 
\index{helib@{helib}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::deserialize (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&}]{poly }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em is} & Input {\ttfamily std\+::istream}. \\
\hline
{\em poly} & Destination {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classhelib_1_1_i_o_error}{I\+O\+Error}}} & if the stream is badly formatted (i.\+e. it is not delimited by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}). \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
{\ttfamily poly} must be constructed with an appropriate p2r and G {\bfseries{B\+E\+F\+O\+RE}} calling this function. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{PolyMod my\_poly(p2r, G);}
\DoxyCodeLine{\mbox{\hyperlink{namespacehelib_aa69f30064b062723cecac335a73fdcdd}{deserialize}}(std::cin, my\_poly);}
\end{DoxyCode}

\end{DoxyNote}
The input stream has to be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each element of the list will be deserialized as a coefficient of the polynomial.~\newline
For example \textquotesingle{}\mbox{[}\textquotesingle{}coef0\textquotesingle{}, \textquotesingle{}coef1\textquotesingle{}, \textquotesingle{}coef2\textquotesingle{}\mbox{]}\textquotesingle{} will be deserialized as a {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object {\ttfamily poly} where {\ttfamily poly\mbox{[}0\mbox{]}=coef0}, {\ttfamily poly\mbox{[}1\mbox{]}=coef1}, {\ttfamily poly\mbox{[}2\mbox{]}=coef2} and {\ttfamily poly\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}. \mbox{\Hypertarget{namespacehelib_a9b41101191111377485d5adf5c4693c1}\label{namespacehelib_a9b41101191111377485d5adf5c4693c1}} 
\index{helib@{helib}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
void helib\+::deserialize (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{ptxt }\end{DoxyParamCaption})}



Function to deserialize a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$Scheme$>$}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scheme} & The {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object scheme. Can be only be {\ttfamily \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}} or {\ttfamily \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em is} & Input {\ttfamily std\+::istream}. \\
\hline
{\em ptxt} & Destination {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classhelib_1_1_i_o_error}{I\+O\+Error}}} & if the stream is badly formatted (i.\+e. it is not delimited by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}). \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
{\ttfamily ptxt} must be constructed with an appropriate context {\bfseries{B\+E\+F\+O\+RE}} calling this function. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{Ptxt my\_ptxt(context);}
\DoxyCodeLine{\mbox{\hyperlink{namespacehelib_aa69f30064b062723cecac335a73fdcdd}{deserialize}}(std::cin, my\_ptxt);}
\end{DoxyCode}

\end{DoxyNote}
The input stream has to be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each element of the list will be deserialized as a slot of the type determined by the scheme.~\newline
If the number of tokens in the list is less than the number of slots, the remaining slots will be padded by 0.~\newline
For example \textquotesingle{}\mbox{[}\textquotesingle{}slot0\textquotesingle{}, \textquotesingle{}slot1\textquotesingle{}, \textquotesingle{}slot2\textquotesingle{}\mbox{]}\textquotesingle{} will be deserialized as a plaintext {\ttfamily ptxt} where {\ttfamily ptxt\mbox{[}0\mbox{]}=slot0}, {\ttfamily ptxt\mbox{[}1\mbox{]}=slot1}, {\ttfamily ptxt\mbox{[}2\mbox{]}=slot2} and {\ttfamily ptxt\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}. \mbox{\Hypertarget{namespacehelib_aa69f30064b062723cecac335a73fdcdd}\label{namespacehelib_aa69f30064b062723cecac335a73fdcdd}} 
\index{helib@{helib}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::deserialize (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{std\+::complex$<$ double $>$ \&}]{num }\end{DoxyParamCaption})}



Deserialize a {\ttfamily std\+::complex$<$double$>$} from the input stream {\ttfamily is} delimited by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{} (instead of the default \textquotesingle{}(\textquotesingle{}, \textquotesingle{})\textquotesingle{}). 


\begin{DoxyParams}{Parameters}
{\em is} & The input stream reference. \\
\hline
{\em num} & The complex number to deserialize. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classhelib_1_1_i_o_error}{I\+O\+Error}}} & if the stream contains more than 2 parts.\\
\hline
\end{DoxyExceptions}
The input stream has to be formatted as \textquotesingle{}\mbox{[}\textquotesingle{}number\textquotesingle{}\mbox{]}\textquotesingle{} (this will be deserialized as (number, 0)) or \textquotesingle{}\mbox{[}\textquotesingle{}real\+\_\+part\textquotesingle{}, \textquotesingle{}imag\+\_\+part\textquotesingle{}\mbox{]}\textquotesingle{} (this will be deserialized as (real\+\_\+part, imag\+\_\+part)). \mbox{\Hypertarget{namespacehelib_a7935d14fb3f04f52a685e6655d12e613}\label{namespacehelib_a7935d14fb3f04f52a685e6655d12e613}} 
\index{helib@{helib}!deserialize$<$ BGV $>$@{deserialize$<$ BGV $>$}}
\index{deserialize$<$ BGV $>$@{deserialize$<$ BGV $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{deserialize$<$ BGV $>$()}{deserialize< BGV >()}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_aa69f30064b062723cecac335a73fdcdd}{helib\+::deserialize}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0f0989e95794866905149bd8defaa3f8}\label{namespacehelib_a0f0989e95794866905149bd8defaa3f8}} 
\index{helib@{helib}!deserialize$<$ CKKS $>$@{deserialize$<$ CKKS $>$}}
\index{deserialize$<$ CKKS $>$@{deserialize$<$ CKKS $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{deserialize$<$ CKKS $>$()}{deserialize< CKKS >()}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_aa69f30064b062723cecac335a73fdcdd}{helib\+::deserialize}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a90b78436c866a0477b9b2957a50bb119}\label{namespacehelib_a90b78436c866a0477b9b2957a50bb119}} 
\index{helib@{helib}!DestMulAdd@{DestMulAdd}}
\index{DestMulAdd@{DestMulAdd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DestMulAdd()}{DestMulAdd()}}
{\footnotesize\ttfamily void helib\+::\+Dest\+Mul\+Add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{x,  }\item[{const std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}} $>$ \&}]{a,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9a593337ace30bc0dd968cae8ed4564b}\label{namespacehelib_a9a593337ace30bc0dd968cae8ed4564b}} 
\index{helib@{helib}!disjoint@{disjoint}}
\index{disjoint@{disjoint}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{disjoint()}{disjoint()}}
{\footnotesize\ttfamily bool helib\+::disjoint (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Functional disjoint. 

\mbox{\Hypertarget{namespacehelib_a9965244b44a7884f3e08999f6adec16f}\label{namespacehelib_a9965244b44a7884f3e08999f6adec16f}} 
\index{helib@{helib}!div@{div}}
\index{div@{div}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{div()}{div()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::div (\begin{DoxyParamCaption}\item[{std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{x,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acbe210bf717f8ba00aca5995fb479593}\label{namespacehelib_acbe210bf717f8ba00aca5995fb479593}} 
\index{helib@{helib}!div@{div}}
\index{div@{div}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{div()}{div()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::div (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{res,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad8ff9e17791a3dd96ca79b2dd4d0654d}\label{namespacehelib_ad8ff9e17791a3dd96ca79b2dd4d0654d}} 
\index{helib@{helib}!divc@{divc}}
\index{divc@{divc}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{divc()}{divc()}}
{\footnotesize\ttfamily long helib\+::divc (\begin{DoxyParamCaption}\item[{long}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



returns ceiling(a/b); assumes a $>$=0, b$>$0, a+b $<$= M\+A\+X\+\_\+\+L\+O\+NG 

\mbox{\Hypertarget{namespacehelib_ae695d0fc0099e58790b874885c563efd}\label{namespacehelib_ae695d0fc0099e58790b874885c563efd}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::AddFun $>$@{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$@{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$()}{DoubleCRT::Op< DoubleCRT::AddFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Add\+Fun $>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{other,  }\item[{Add\+Fun}]{fun,  }\item[{bool}]{match\+Index\+Sets }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab878e7e7e17b6d6caf65e7f289965e28}\label{namespacehelib_ab878e7e7e17b6d6caf65e7f289965e28}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::AddFun $>$@{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$@{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$()}{DoubleCRT::Op< DoubleCRT::AddFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Add\+Fun $>$ (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+ZZ \&}]{num,  }\item[{Add\+Fun}]{fun }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad523a1ce005b9562e1574d19f8ce7936}\label{namespacehelib_ad523a1ce005b9562e1574d19f8ce7936}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::AddFun $>$@{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$@{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::AddFun $>$()}{DoubleCRT::Op< DoubleCRT::AddFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Add\+Fun $>$ (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{Add\+Fun}]{fun }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae75ba76e26d04df9d1a9fca73d3a718b}\label{namespacehelib_ae75ba76e26d04df9d1a9fca73d3a718b}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::MulFun $>$@{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$@{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$()}{DoubleCRT::Op< DoubleCRT::MulFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Mul\+Fun $>$ (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+ZZ \&}]{num,  }\item[{Mul\+Fun}]{fun }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6a6290cf4257cb23cf95aa5c354c46e6}\label{namespacehelib_a6a6290cf4257cb23cf95aa5c354c46e6}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::MulFun $>$@{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$@{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::MulFun $>$()}{DoubleCRT::Op< DoubleCRT::MulFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Mul\+Fun $>$ (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{Mul\+Fun}]{fun }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae3db7c0c4fd741adba512c54bc7c3ee4}\label{namespacehelib_ae3db7c0c4fd741adba512c54bc7c3ee4}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::SubFun $>$@{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$@{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$()}{DoubleCRT::Op< DoubleCRT::SubFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Sub\+Fun $>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{other,  }\item[{Sub\+Fun}]{fun,  }\item[{bool}]{match\+Index\+Sets }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3891679919f78713c9067c3ae9f9ad0c}\label{namespacehelib_a3891679919f78713c9067c3ae9f9ad0c}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::SubFun $>$@{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$@{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$()}{DoubleCRT::Op< DoubleCRT::SubFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Sub\+Fun $>$ (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+ZZ \&}]{num,  }\item[{Sub\+Fun}]{fun }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adcba19e19a8aae778a080d8a4833f2d1}\label{namespacehelib_adcba19e19a8aae778a080d8a4833f2d1}} 
\index{helib@{helib}!DoubleCRT::Op$<$ DoubleCRT::SubFun $>$@{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$}}
\index{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$@{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{DoubleCRT::Op$<$ DoubleCRT::SubFun $>$()}{DoubleCRT::Op< DoubleCRT::SubFun >()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}}\& helib\+::\+Double\+C\+R\+T\+::\+Op$<$ Double\+C\+R\+T\+::\+Sub\+Fun $>$ (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{Sub\+Fun}]{fun }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_abc33dc76f8abeaf3557b98dd5a400922}\label{namespacehelib_abc33dc76f8abeaf3557b98dd5a400922}} 
\index{helib@{helib}!EDF@{EDF}}
\index{EDF@{EDF}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{EDF()}{EDF()}}
{\footnotesize\ttfamily void helib\+::\+E\+DF (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&}]{v,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{f,  }\item[{long}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a309c3ca72a6d812a3ea23d62e48e42bf}\label{namespacehelib_a309c3ca72a6d812a3ea23d62e48e42bf}} 
\index{helib@{helib}!embeddingLargestCoeff@{embeddingLargestCoeff}}
\index{embeddingLargestCoeff@{embeddingLargestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{embeddingLargestCoeff()}{embeddingLargestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::embedding\+Largest\+Coeff (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aff1d310e2dc35b38b4f87aeaa0e8c73c}\label{namespacehelib_aff1d310e2dc35b38b4f87aeaa0e8c73c}} 
\index{helib@{helib}!embeddingLargestCoeff@{embeddingLargestCoeff}}
\index{embeddingLargestCoeff@{embeddingLargestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{embeddingLargestCoeff()}{embeddingLargestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::embedding\+Largest\+Coeff (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3a9543f301395b419a4026ea72424c01}\label{namespacehelib_a3a9543f301395b419a4026ea72424c01}} 
\index{helib@{helib}!embeddingLargestCoeff@{embeddingLargestCoeff}}
\index{embeddingLargestCoeff@{embeddingLargestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{embeddingLargestCoeff()}{embeddingLargestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily double helib\+::embedding\+Largest\+Coeff (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ double $>$ \&}]{f,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1163a93bce42908b4edfa4e2a2989c49}\label{namespacehelib_a1163a93bce42908b4edfa4e2a2989c49}} 
\index{helib@{helib}!embeddingLargestCoeff@{embeddingLargestCoeff}}
\index{embeddingLargestCoeff@{embeddingLargestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{embeddingLargestCoeff()}{embeddingLargestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily double helib\+::embedding\+Largest\+Coeff (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{f,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

Computing the L-\/infinity norm of the canonical embedding Assumed\+: deg(f) $<$ phi(m). \mbox{\Hypertarget{namespacehelib_a338704cc219609b1663cc3b5bf1cb631}\label{namespacehelib_a338704cc219609b1663cc3b5bf1cb631}} 
\index{helib@{helib}!embeddingLargestCoeff\_x2@{embeddingLargestCoeff\_x2}}
\index{embeddingLargestCoeff\_x2@{embeddingLargestCoeff\_x2}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{embeddingLargestCoeff\_x2()}{embeddingLargestCoeff\_x2()}}
{\footnotesize\ttfamily void helib\+::embedding\+Largest\+Coeff\+\_\+x2 (\begin{DoxyParamCaption}\item[{double \&}]{norm1,  }\item[{double \&}]{norm2,  }\item[{const std\+::vector$<$ double $>$ \&}]{f1,  }\item[{const std\+::vector$<$ double $>$ \&}]{f2,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad94835a294c90ee0ea0336561c8f38ad}\label{namespacehelib_ad94835a294c90ee0ea0336561c8f38ad}} 
\index{helib@{helib}!empty@{empty}}
\index{empty@{empty}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily bool helib\+::empty (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_aab8cf8fcdf629a076db0d0206670a7c3}\label{namespacehelib_aab8cf8fcdf629a076db0d0206670a7c3}} 
\index{helib@{helib}!encode@{encode}}
\index{encode@{encode}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{encode()}{encode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void helib\+::encode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acf08ccbcd03824fa3825640c1b171481}\label{namespacehelib_acf08ccbcd03824fa3825640c1b171481}} 
\index{helib@{helib}!encode@{encode}}
\index{encode@{encode}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{encode()}{encode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void helib\+::encode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const std\+::vector$<$ long $>$ \&}]{array }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac40cf1967be4e2bf1b9a63564abe3485}\label{namespacehelib_ac40cf1967be4e2bf1b9a63564abe3485}} 
\index{helib@{helib}!encode@{encode}}
\index{encode@{encode}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{encode()}{encode()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void helib\+::encode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{array }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a517b7c650eafd6c9ac20ef4605a4d4a1}\label{namespacehelib_a517b7c650eafd6c9ac20ef4605a4d4a1}} 
\index{helib@{helib}!encode@{encode}}
\index{encode@{encode}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{encode()}{encode()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void helib\+::encode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{long}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_abcdd1f22927d282e9bbce15a18f5f3ad}\label{namespacehelib_abcdd1f22927d282e9bbce15a18f5f3ad}} 
\index{helib@{helib}!endBuildModChain@{endBuildModChain}}
\index{endBuildModChain@{endBuildModChain}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{endBuildModChain()}{endBuildModChain()}}
{\footnotesize\ttfamily void helib\+::end\+Build\+Mod\+Chain (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa271293d5f46187af89cc81ecb0235e9}\label{namespacehelib_aa271293d5f46187af89cc81ecb0235e9}} 
\index{helib@{helib}!equals@{equals}}
\index{equals@{equals}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{equals()}{equals()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily bool helib\+::equals (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae140aabda8f5c9ace67b657134451df8}\label{namespacehelib_ae140aabda8f5c9ace67b657134451df8}} 
\index{helib@{helib}!equals@{equals}}
\index{equals@{equals}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{equals()}{equals()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool helib\+::equals (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const std\+::vector$<$ long $>$ \&}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aab2e1e9931564eca3665358957b06cd3}\label{namespacehelib_aab2e1e9931564eca3665358957b06cd3}} 
\index{helib@{helib}!equals@{equals}}
\index{equals@{equals}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{equals()}{equals()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool helib\+::equals (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3f9b160771517accfb43d16c5590942c}\label{namespacehelib_a3f9b160771517accfb43d16c5590942c}} 
\index{helib@{helib}!extendExtractDigits@{extendExtractDigits}}
\index{extendExtractDigits@{extendExtractDigits}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{extendExtractDigits()}{extendExtractDigits()}}
{\footnotesize\ttfamily void helib\+::extend\+Extract\+Digits (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{digits,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{c,  }\item[{long}]{r,  }\item[{long}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab463f07c91389f56b58bb09da140230d}\label{namespacehelib_ab463f07c91389f56b58bb09da140230d}} 
\index{helib@{helib}!extractDigits@{extractDigits}}
\index{extractDigits@{extractDigits}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{extractDigits()}{extractDigits()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::extract\+Digits (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{digits,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{c,  }\item[{long}]{r,  }\item[{bool}]{short\+Cut }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a90e48196b014916b26112c02883f64e3}\label{namespacehelib_a90e48196b014916b26112c02883f64e3}} 
\index{helib@{helib}!extractDigits@{extractDigits}}
\index{extractDigits@{extractDigits}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{extractDigits()}{extractDigits()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::extract\+Digits (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{digits,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{c,  }\item[{long}]{r = {\ttfamily 0} }\end{DoxyParamCaption})}



Extract the mod-\/p digits of a mod-\/p$^\wedge$r ciphertext. 

extract\+Digits returns in the slots of digits\mbox{[}j\mbox{]} the j\textquotesingle{}th-\/lowest digits from the integers in the slots of the input. Namely, the i\textquotesingle{}th slot of digits\mbox{[}j\mbox{]} contains the j\textquotesingle{}th digit in the p-\/base expansion of the integer in the i\textquotesingle{}th slot of the $\ast$this.

If r==0 then it is set to c.\+effective\+R(). It is assumed that the slots of $\ast$this contains integers mod p$^\wedge$r, i.\+e., that only the free terms are nonzero. If that assumptions does not hold then the result will not be a valid ciphertext anymore.

The \char`\"{}shortcut\char`\"{} flag is deprecated, it often leads to catastrophic failure in the noise estimate. Calling the function with shortcut=true has not effect, except printing a warning message to cerr.

The output ciphertext digits\mbox{[}j\mbox{]} contains the j\textquotesingle{}th digit in the base-\/p expansion of the input, and its plaintext space is modulo p$^\wedge$\{r-\/j\}. All the ciphertexts in the output are at the same level. \mbox{\Hypertarget{namespacehelib_a4a30217f5c0a87bea091193f7dddddc4}\label{namespacehelib_a4a30217f5c0a87bea091193f7dddddc4}} 
\index{helib@{helib}!extractDigitsPacked@{extractDigitsPacked}}
\index{extractDigitsPacked@{extractDigitsPacked}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{extractDigitsPacked()}{extractDigitsPacked()}}
{\footnotesize\ttfamily void helib\+::extract\+Digits\+Packed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{bot\+High,  }\item[{long}]{r,  }\item[{long}]{e\+Prime,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{unpack\+Slot\+Encoding }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac2b1296539466b880a55d12ea9ac6864}\label{namespacehelib_ac2b1296539466b880a55d12ea9ac6864}} 
\index{helib@{helib}!extractDigitsThin@{extractDigitsThin}}
\index{extractDigitsThin@{extractDigitsThin}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{extractDigitsThin()}{extractDigitsThin()}}
{\footnotesize\ttfamily void helib\+::extract\+Digits\+Thin (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{bot\+High,  }\item[{long}]{r,  }\item[{long}]{e\+Prime }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad5b904688ca513ad603df4d470c5ae21}\label{namespacehelib_ad5b904688ca513ad603df4d470c5ae21}} 
\index{helib@{helib}!extractTokenizeRegion@{extractTokenizeRegion}}
\index{extractTokenizeRegion@{extractTokenizeRegion}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{extractTokenizeRegion()}{extractTokenizeRegion()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::stringstream $>$ helib\+::extract\+Tokenize\+Region (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{istr,  }\item[{char}]{begin\+\_\+char,  }\item[{char}]{end\+\_\+char,  }\item[{char}]{separator,  }\item[{bool}]{skip\+\_\+space = {\ttfamily true} }\end{DoxyParamCaption})}



Advance the input stream {\ttfamily istr} beyond white spaces. Then split the region delimited by {\ttfamily begin\+\_\+char} and {\ttfamily end\+\_\+char} at each occurrence of {\ttfamily separator} that is not contained in an inner {\ttfamily begin\+\_\+char} -\/ {\ttfamily end\+\_\+char} section. The function returns a {\ttfamily std\+::vector$<$std\+::stringstream$>$} with the stream of every section of the input region. 


\begin{DoxyParams}{Parameters}
{\em istr} & The stream to be advanced. \\
\hline
{\em begin\+\_\+char} & The character determining the beginning of the region-\/of-\/interest. \\
\hline
{\em end\+\_\+char} & The character determining the end of the region-\/of-\/interest \\
\hline
{\em separator} & The separator character to split at. \\
\hline
{\em skip\+\_\+space} & Boolean value determining whether to skip spaces when extracting the sub-\/streams (default = {\ttfamily true}). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A {\ttfamily std\+::vector$<$std\+::stringstream$>$} with the stream of every section of the input region. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classhelib_1_1_i_o_error}{I\+O\+Error}}} & If the stream is badly formatted (i.\+e. it does not start with {\ttfamily begin\+\_\+char} or it does not end with {\ttfamily end\+\_\+char}). \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Requires {\ttfamily begin\+\_\+char}, {\ttfamily end\+\_\+char} and {\ttfamily separator} to be distinct and different from (space). 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a75dc52f12b0306195238f56bcf4a112b}\label{namespacehelib_a75dc52f12b0306195238f56bcf4a112b}} 
\index{helib@{helib}!factorize@{factorize}}
\index{factorize@{factorize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{factorize()}{factorize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::factorize (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+Pair$<$ long, long $>$$>$ \&}]{factors,  }\item[{long}]{N }\end{DoxyParamCaption})}



Factoring by trial division, only works for N$<$2$^\wedge$\{60\} primes and multiplicities are recorded. 

\mbox{\Hypertarget{namespacehelib_a8d163aa9f73ad476ebd97d7778d79258}\label{namespacehelib_a8d163aa9f73ad476ebd97d7778d79258}} 
\index{helib@{helib}!factorize@{factorize}}
\index{factorize@{factorize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{factorize()}{factorize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void helib\+::factorize (\begin{DoxyParamCaption}\item[{std\+::vector$<$ long $>$ \&}]{factors,  }\item[{long}]{N }\end{DoxyParamCaption})}



Factoring by trial division, only works for N$<$2$^\wedge$\{60\}, only the primes are recorded, not their multiplicity. 

\mbox{\Hypertarget{namespacehelib_a0a26515bfdcb0f7e654cefa0d955d4be}\label{namespacehelib_a0a26515bfdcb0f7e654cefa0d955d4be}} 
\index{helib@{helib}!factorize@{factorize}}
\index{factorize@{factorize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{factorize()}{factorize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::factorize (\begin{DoxyParamCaption}\item[{std\+::vector$<$ N\+T\+L\+::\+ZZ $>$ \&}]{factors,  }\item[{const N\+T\+L\+::\+ZZ \&}]{N }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a028abbe1151a190d5f4ff23bd3a29c3a}\label{namespacehelib_a028abbe1151a190d5f4ff23bd3a29c3a}} 
\index{helib@{helib}!fastPower@{fastPower}}
\index{fastPower@{fastPower}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fastPower()}{fastPower()}}
{\footnotesize\ttfamily void helib\+::fast\+Power (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af35e417bff539eb8c29da182c8365e41}\label{namespacehelib_af35e417bff539eb8c29da182c8365e41}} 
\index{helib@{helib}!fetch\_saved\_values@{fetch\_saved\_values}}
\index{fetch\_saved\_values@{fetch\_saved\_values}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fetch\_saved\_values()}{fetch\_saved\_values()}}
{\footnotesize\ttfamily const std\+::vector$<$ double $>$ $\ast$ helib\+::fetch\+\_\+saved\+\_\+values (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a635ecc26ac755424a9f834d4eca7d68e}\label{namespacehelib_a635ecc26ac755424a9f834d4eca7d68e}} 
\index{helib@{helib}!fifteenOrLess4Four@{fifteenOrLess4Four}}
\index{fifteenOrLess4Four@{fifteenOrLess4Four}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fifteenOrLess4Four()}{fifteenOrLess4Four()}}
{\footnotesize\ttfamily long helib\+::fifteen\+Or\+Less4\+Four (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{out,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{in,  }\item[{long}]{size\+Limit = {\ttfamily 4} }\end{DoxyParamCaption})}



Add together up to fifteen \{0,1\} integers, producing a 4-\/bit counter. 


\begin{DoxyParams}{Parameters}
{\em out} & 4-\/bit counter to be outputted. \\
\hline
{\em in} & bits to be counted. \\
\hline
{\em size\+Limit} & number of bits to compute on, taken from the least significant end. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of output bits that are not identically zero (i.\+e. != null).
\end{DoxyReturn}
Adding fifteen input bits, getting a 4-\/bit counter. Some of the input pointers may be null, but output pointers must point to allocated \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} objects. If size\+Limit$<$4, only that many bits are computed (taken from the least significant end). \begin{DoxyNote}{Note}
This function is currently not thread safe. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a67f0037687252f6999a8526165cd8e41}\label{namespacehelib_a67f0037687252f6999a8526165cd8e41}} 
\index{helib@{helib}!findGenerators@{findGenerators}}
\index{findGenerators@{findGenerators}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{findGenerators()}{findGenerators()}}
{\footnotesize\ttfamily long helib\+::find\+Generators (\begin{DoxyParamCaption}\item[{std\+::vector$<$ long $>$ \&}]{gens,  }\item[{std\+::vector$<$ long $>$ \&}]{ords,  }\item[{long}]{m,  }\item[{long}]{p,  }\item[{const std\+::vector$<$ long $>$ \&}]{candidates = {\ttfamily std\+:\+:vector$<$long$>$()} }\end{DoxyParamCaption})}

Returns in gens a generating set for Zm$\ast$ /

, and in ords the order of these generators. Return value is the order of p in Zm$\ast$. \mbox{\Hypertarget{namespacehelib_abbf9f5de032fca82af2ce94a97041bc6}\label{namespacehelib_abbf9f5de032fca82af2ce94a97041bc6}} 
\index{helib@{helib}!FindM@{FindM}}
\index{FindM@{FindM}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{FindM()}{FindM()}}
{\footnotesize\ttfamily long helib\+::\+FindM (\begin{DoxyParamCaption}\item[{long}]{k,  }\item[{long}]{n\+Bits,  }\item[{long}]{c,  }\item[{long}]{p,  }\item[{long}]{d,  }\item[{long}]{s,  }\item[{long}]{chosen\+\_\+m,  }\item[{bool}]{verbose = {\ttfamily false} }\end{DoxyParamCaption})}



Returns smallest parameter m satisfying various constraints\+: 


\begin{DoxyParams}{Parameters}
{\em k} & security parameter \\
\hline
{\em L} & number of levels \\
\hline
{\em c} & number of columns in key switching matrices \\
\hline
{\em p} & characteristic of plaintext space \\
\hline
{\em d} & embedding degree (d ==0 or d==1 =$>$ no constraint) \\
\hline
{\em s} & at least that many plaintext slots \\
\hline
{\em chosen\+\_\+m} & preselected value of m (0 =$>$ not preselected) Fails with an error message if no suitable m is found prints an informative message if verbose == true \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a57538912bfe96e264dab8aac85f0be75}\label{namespacehelib_a57538912bfe96e264dab8aac85f0be75}} 
\index{helib@{helib}!findMinBitCapacity@{findMinBitCapacity}}
\index{findMinBitCapacity@{findMinBitCapacity}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{findMinBitCapacity()}{findMinBitCapacity()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily long helib\+::find\+Min\+Bit\+Capacity (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{Ct\+Ptr\+Mat}} \&}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a3f5129e7d3dfa1e3c31cf5df21ae581d}\label{namespacehelib_a3f5129e7d3dfa1e3c31cf5df21ae581d}} 
\index{helib@{helib}!findMinBitCapacity@{findMinBitCapacity}}
\index{findMinBitCapacity@{findMinBitCapacity}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{findMinBitCapacity()}{findMinBitCapacity()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily long helib\+::find\+Min\+Bit\+Capacity (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{v }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a544c38d5177ea1f1d47d3e204ac1eb77}\label{namespacehelib_a544c38d5177ea1f1d47d3e204ac1eb77}} 
\index{helib@{helib}!findMinBitCapacity@{findMinBitCapacity}}
\index{findMinBitCapacity@{findMinBitCapacity}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{findMinBitCapacity()}{findMinBitCapacity()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily long helib\+::find\+Min\+Bit\+Capacity (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} $\ast$ $>$}]{list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a9e1f9936cf8c582202702cbb65eaf2ce}\label{namespacehelib_a9e1f9936cf8c582202702cbb65eaf2ce}} 
\index{helib@{helib}!FindPrimitiveRoot@{FindPrimitiveRoot}}
\index{FindPrimitiveRoot@{FindPrimitiveRoot}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{FindPrimitiveRoot()}{FindPrimitiveRoot()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::\+Find\+Primitive\+Root (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+p \&}]{r,  }\item[{unsigned long}]{e }\end{DoxyParamCaption})}



Find e-\/th root of unity modulo the current modulus. 

\mbox{\Hypertarget{namespacehelib_ae3ed622332f1680e6384644d3c347e19}\label{namespacehelib_ae3ed622332f1680e6384644d3c347e19}} 
\index{helib@{helib}!FindPrimitiveRoot@{FindPrimitiveRoot}}
\index{FindPrimitiveRoot@{FindPrimitiveRoot}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{FindPrimitiveRoot()}{FindPrimitiveRoot()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::\+Find\+Primitive\+Root (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+Z\+\_\+p \&}]{r,  }\item[{unsigned long}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adcf094f13d09fba535a0ac173449843f}\label{namespacehelib_adcf094f13d09fba535a0ac173449843f}} 
\index{helib@{helib}!FindPrimRootT@{FindPrimRootT}}
\index{FindPrimRootT@{FindPrimRootT}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{FindPrimRootT()}{FindPrimRootT()}}
{\footnotesize\ttfamily template$<$typename zp , typename zz $>$ \\
void helib\+::\+Find\+Prim\+RootT (\begin{DoxyParamCaption}\item[{zp \&}]{root,  }\item[{unsigned long}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a291c0b1560a80e0cda02f89617fd16d5}\label{namespacehelib_a291c0b1560a80e0cda02f89617fd16d5}} 
\index{helib@{helib}!frobeniusAutomorph@{frobeniusAutomorph}}
\index{frobeniusAutomorph@{frobeniusAutomorph}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{frobeniusAutomorph()}{frobeniusAutomorph()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::frobenius\+Automorph (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab08d6e1c47a1f0b8ed57aff211929548}\label{namespacehelib_ab08d6e1c47a1f0b8ed57aff211929548}} 
\index{helib@{helib}!frobeniusAutomorph@{frobeniusAutomorph}}
\index{frobeniusAutomorph@{frobeniusAutomorph}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{frobeniusAutomorph()}{frobeniusAutomorph()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::frobenius\+Automorph (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{long}]{j }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad0741932e68cabac1a19a68d0a4810bf}\label{namespacehelib_ad0741932e68cabac1a19a68d0a4810bf}} 
\index{helib@{helib}!FrobeniusMap@{FrobeniusMap}}
\index{FrobeniusMap@{FrobeniusMap}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{FrobeniusMap()}{FrobeniusMap()}}
{\footnotesize\ttfamily N\+T\+L\+::zz\+\_\+p\+EX helib\+::\+Frobenius\+Map (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::zz\+\_\+p\+E\+X\+Modulus \&}]{F }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad92538fab792f75e009a2330c365637d}\label{namespacehelib_ad92538fab792f75e009a2330c365637d}} 
\index{helib@{helib}!fsquare@{fsquare}}
\index{fsquare@{fsquare}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fsquare()}{fsquare()}}
{\footnotesize\ttfamily double helib\+::fsquare (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return the square of a number as a double. 

\mbox{\Hypertarget{namespacehelib_ac78c4e23cc87c6109c26c3cf86fd1dd0}\label{namespacehelib_ac78c4e23cc87c6109c26c3cf86fd1dd0}} 
\index{helib@{helib}!GenBabySteps@{GenBabySteps}}
\index{GenBabySteps@{GenBabySteps}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{GenBabySteps()}{GenBabySteps()}}
{\footnotesize\ttfamily void helib\+::\+Gen\+Baby\+Steps (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$$>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{dim,  }\item[{bool}]{clean }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5711697a702a0f5c4351b3be5644591f}\label{namespacehelib_a5711697a702a0f5c4351b3be5644591f}} 
\index{helib@{helib}!getG@{getG}}
\index{getG@{getG}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{getG()}{getG()}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::getG (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad24ba24d435ed51afa0737dddfc01bb2}\label{namespacehelib_ad24ba24d435ed51afa0737dddfc01bb2}} 
\index{helib@{helib}!getHyperColumn@{getHyperColumn}}
\index{getHyperColumn@{getHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{getHyperColumn()}{getHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template void helib\+::get\+Hyper\+Column (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ long $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_const_cube_slice}{Const\+Cube\+Slice}}$<$ long $>$ \&}]{s,  }\item[{long}]{pos }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adb40b60558125630cb15e09a63906c2e}\label{namespacehelib_adb40b60558125630cb15e09a63906c2e}} 
\index{helib@{helib}!getHyperColumn@{getHyperColumn}}
\index{getHyperColumn@{getHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{getHyperColumn()}{getHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template void helib\+::get\+Hyper\+Column (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_const_cube_slice}{Const\+Cube\+Slice}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{s,  }\item[{long}]{pos }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab89bc5e58dddac6b2dc64435b98417e1}\label{namespacehelib_ab89bc5e58dddac6b2dc64435b98417e1}} 
\index{helib@{helib}!getHyperColumn@{getHyperColumn}}
\index{getHyperColumn@{getHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{getHyperColumn()}{getHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::get\+Hyper\+Column (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_const_cube_slice}{Const\+Cube\+Slice}}$<$ T $>$ \&}]{s,  }\item[{long}]{pos }\end{DoxyParamCaption})}

get\+Hyper\+Column reads out a (multi-\/dimensional) column from a slice. The parameter pos specifies the position of the column, which must be in the range 0 $<$= pos $<$ s.\+get\+Prod(1). The vector v is filled with values whose coordinate in the lower dimensional subcube is equal to pos. The length of v will be set to s.\+get\+Dim(0). \mbox{\Hypertarget{namespacehelib_ab0fdf54d28eb816a5a395b7e1e1efe51}\label{namespacehelib_ab0fdf54d28eb816a5a395b7e1e1efe51}} 
\index{helib@{helib}!getPhimXMod@{getPhimXMod}}
\index{getPhimXMod@{getPhimXMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{getPhimXMod()}{getPhimXMod()}}
{\footnotesize\ttfamily const N\+T\+L\+::zz\+\_\+p\+X\+Modulus \& helib\+::get\+Phim\+X\+Mod (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad19aadcc92555c2f4dbb3b3b34ae6633}\label{namespacehelib_ad19aadcc92555c2f4dbb3b3b34ae6633}} 
\index{helib@{helib}!getTimerByName@{getTimerByName}}
\index{getTimerByName@{getTimerByName}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{getTimerByName()}{getTimerByName()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$ helib\+::get\+Timer\+By\+Name (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a73d5dae8af9bd253bc591ea37db51a58}\label{namespacehelib_a73d5dae8af9bd253bc591ea37db51a58}} 
\index{helib@{helib}!GetTimerClock@{GetTimerClock}}
\index{GetTimerClock@{GetTimerClock}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{GetTimerClock()}{GetTimerClock()}}
{\footnotesize\ttfamily unsigned long helib\+::\+Get\+Timer\+Clock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a693b16168065219388722259c6a02c5d}\label{namespacehelib_a693b16168065219388722259c6a02c5d}} 
\index{helib@{helib}!incrementalProduct@{incrementalProduct}}
\index{incrementalProduct@{incrementalProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{incrementalProduct()}{incrementalProduct()}}
{\footnotesize\ttfamily void helib\+::incremental\+Product (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v }\end{DoxyParamCaption})}

For i=n-\/1...0, set v\mbox{[}i\mbox{]}=prod\+\_\+\{j$<$=i\} v\mbox{[}j\mbox{]} This implementation uses depth log n and (nlog n)/2 products \mbox{\Hypertarget{namespacehelib_ab42c58780be6927575c8548d842f47b9}\label{namespacehelib_ab42c58780be6927575c8548d842f47b9}} 
\index{helib@{helib}!incrementalZeroTest@{incrementalZeroTest}}
\index{incrementalZeroTest@{incrementalZeroTest}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{incrementalZeroTest()}{incrementalZeroTest()}}
{\footnotesize\ttfamily void helib\+::incremental\+Zero\+Test (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $\ast$}]{res\mbox{[}$\,$\mbox{]},  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{n }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa1e7877c8a04ea75594a2295518c70d8}\label{namespacehelib_aa1e7877c8a04ea75594a2295518c70d8}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [1/9]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{v1,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{v2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_aa738424e1ab49c4f39cbcb3e3e920591}\label{namespacehelib_aa738424e1ab49c4f39cbcb3e3e920591}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [2/9]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v1,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ad0d0484b1e2d0105b7a2b70a3c6dc182}\label{namespacehelib_ad0d0484b1e2d0105b7a2b70a3c6dc182}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [3/9]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v1,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \&}]{v2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a6d67040ef7ba12958be263a7a93dac9e}\label{namespacehelib_a6d67040ef7ba12958be263a7a93dac9e}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [4/9]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v1,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{v2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a391719dad458fcb9560406cb565f8cbe}\label{namespacehelib_a391719dad458fcb9560406cb565f8cbe}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [5/9]}}
{\footnotesize\ttfamily void helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{result,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{v1,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{v2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a8f851f7c167ee39bfc4ceb06d754dcf0}\label{namespacehelib_a8f851f7c167ee39bfc4ceb06d754dcf0}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [6/9]}}
{\footnotesize\ttfamily void helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{result,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v1,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_abb001c145ac75147f598002b33806849}\label{namespacehelib_abb001c145ac75147f598002b33806849}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [7/9]}}
{\footnotesize\ttfamily void helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{result,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v1,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} $>$ \&}]{v2 }\end{DoxyParamCaption})}



Compute the inner product of a vectors of ciphertexts and a constant vector. 

\mbox{\Hypertarget{namespacehelib_ab7a60dc124ede5f7baecc0d6c7ab6df6}\label{namespacehelib_ab7a60dc124ede5f7baecc0d6c7ab6df6}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [8/9]}}
{\footnotesize\ttfamily void helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{result,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v1,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{v2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a98d0e8b458fb8f75fa79ff7c7effe58e}\label{namespacehelib_a98d0e8b458fb8f75fa79ff7c7effe58e}} 
\index{helib@{helib}!innerProduct@{innerProduct}}
\index{innerProduct@{innerProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{innerProduct()}{innerProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [9/9]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
void helib\+::inner\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{result,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$$>$ \&}]{first\+\_\+vec,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$$>$ \&}]{second\+\_\+vec }\end{DoxyParamCaption})}



Free function that computes the inner product of two vectors of {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}}. 


\begin{DoxyParams}{Parameters}
{\em result} & The output {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} that will hold the result. \\
\hline
{\em first\+\_\+vec} & The first input vector of plaintexts. \\
\hline
{\em second\+\_\+vec} & The second input vector of plaintexts. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If the two vector sizes differ, the shorter vector will be padded with zeroes. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a9e7d6d68a0351702ae31c17eb4e72307}\label{namespacehelib_a9e7d6d68a0351702ae31c17eb4e72307}} 
\index{helib@{helib}!interpolateMod@{interpolateMod}}
\index{interpolateMod@{interpolateMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{interpolateMod()}{interpolateMod()}}
{\footnotesize\ttfamily void helib\+::interpolate\+Mod (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{const N\+T\+L\+::vec\+\_\+long \&}]{x,  }\item[{const N\+T\+L\+::vec\+\_\+long \&}]{y,  }\item[{long}]{p,  }\item[{long}]{e = {\ttfamily 1} }\end{DoxyParamCaption})}



Interpolate polynomial such that poly(x\mbox{[}i\mbox{]} mod p)=y\mbox{[}i\mbox{]} (mod p$^\wedge$e) It is assumed that the points x\mbox{[}i\mbox{]} are all distinct modulo p. 

\mbox{\Hypertarget{namespacehelib_a2c41ad906b8626fb07781c8927102b4f}\label{namespacehelib_a2c41ad906b8626fb07781c8927102b4f}} 
\index{helib@{helib}!intVecCRT@{intVecCRT}}
\index{intVecCRT@{intVecCRT}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{intVecCRT()}{intVecCRT()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template bool helib\+::int\+Vec\+C\+RT (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+\+ZZ \&}]{,  }\item[{const N\+T\+L\+::\+ZZ \&}]{,  }\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{,  }\item[{long}]{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae3781935233076f4d0110d4c7a358ccf}\label{namespacehelib_ae3781935233076f4d0110d4c7a358ccf}} 
\index{helib@{helib}!intVecCRT@{intVecCRT}}
\index{intVecCRT@{intVecCRT}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{intVecCRT()}{intVecCRT()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template bool helib\+::int\+Vec\+C\+RT (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+\+ZZ \&}]{,  }\item[{const N\+T\+L\+::\+ZZ \&}]{,  }\item[{const N\+T\+L\+::vec\+\_\+long \&}]{,  }\item[{long}]{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0dae2334b1ae6358865ee8fd0c6a8fc6}\label{namespacehelib_a0dae2334b1ae6358865ee8fd0c6a8fc6}} 
\index{helib@{helib}!intVecCRT@{intVecCRT}}
\index{intVecCRT@{intVecCRT}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{intVecCRT()}{intVecCRT()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template bool helib\+::int\+Vec\+C\+RT (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+\+ZZ \&}]{,  }\item[{const N\+T\+L\+::\+ZZ \&}]{,  }\item[{const N\+T\+L\+::vec\+\_\+\+ZZ \&}]{,  }\item[{long}]{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5165f6a4ea9a752c8c40d5790acfb4e0}\label{namespacehelib_a5165f6a4ea9a752c8c40d5790acfb4e0}} 
\index{helib@{helib}!intVecCRT@{intVecCRT}}
\index{intVecCRT@{intVecCRT}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{intVecCRT()}{intVecCRT()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class zzvec $>$ \\
bool helib\+::int\+Vec\+C\+RT (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+\+ZZ \&}]{vp,  }\item[{const N\+T\+L\+::\+ZZ \&}]{p,  }\item[{const zzvec \&}]{vq,  }\item[{long}]{q }\end{DoxyParamCaption})}



Incremental integer C\+RT for vectors. 

Expects co-\/primes p,q with q odd, and such that all the entries in v1 are in \mbox{[}-\/p/2,p/2). Returns in v1 the C\+RT of vp mod p and vq mod q, as integers in \mbox{[}-\/pq/2, pq/2). Uses the formula\+: \[ CRT(vp,p,vq,q) = vp + [(vq-vp) * p^{-1}]_q * p, \] where \mbox{[}...\mbox{]}\+\_\+q means reduction to the interval \mbox{[}-\/q/2,q/2). Notice that if q is odd then this is the same as reducing to \mbox{[}-\/(q-\/1)/2,(q-\/1)/2\mbox{]}, which means that \mbox{[}...\mbox{]}\+\_\+q $\ast$ p is in \mbox{[}-\/p(q-\/1)/2, p(q-\/1)/2\mbox{]}, and since vp is in \mbox{[}-\/p/2,p/2) then the sum is indeed in \mbox{[}-\/pq/2,pq/2).

Return true is both vectors are of the same length, false otherwise \mbox{\Hypertarget{namespacehelib_a7cac9469e49eec3d2bcd9db31e0122f1}\label{namespacehelib_a7cac9469e49eec3d2bcd9db31e0122f1}} 
\index{helib@{helib}!InvModpr@{InvModpr}}
\index{InvModpr@{InvModpr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{InvModpr()}{InvModpr()}}
{\footnotesize\ttfamily void helib\+::\+Inv\+Modpr (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+pX \&}]{S,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{F,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{G,  }\item[{long}]{p,  }\item[{long}]{r }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a57dbaa8bc9cf194a1e08fd5af3497a5e}\label{namespacehelib_a57dbaa8bc9cf194a1e08fd5af3497a5e}} 
\index{helib@{helib}!is2power@{is2power}}
\index{is2power@{is2power}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{is2power()}{is2power()}}
{\footnotesize\ttfamily bool helib\+::is2power (\begin{DoxyParamCaption}\item[{long}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a1249c9ddf12d285f6c06985342e52562}\label{namespacehelib_a1249c9ddf12d285f6c06985342e52562}} 
\index{helib@{helib}!is\_in@{is\_in}}
\index{is\_in@{is\_in}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{is\_in()}{is\_in()}}
{\footnotesize\ttfamily long helib\+::is\+\_\+in (\begin{DoxyParamCaption}\item[{long}]{x,  }\item[{int $\ast$}]{X,  }\item[{long}]{sz }\end{DoxyParamCaption})}



Finds whether x is an element of the set X of size sz, Returns -\/1 it not and the location if true. 

\mbox{\Hypertarget{namespacehelib_aa79a0a06add60a27a1a2198fcf948e01}\label{namespacehelib_aa79a0a06add60a27a1a2198fcf948e01}} 
\index{helib@{helib}!isDryRun@{isDryRun}}
\index{isDryRun@{isDryRun}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{isDryRun()}{isDryRun()}}
{\footnotesize\ttfamily bool helib\+::is\+Dry\+Run (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ac639ce6687180f2ac5e50e8706d79488}\label{namespacehelib_ac639ce6687180f2ac5e50e8706d79488}} 
\index{helib@{helib}!isSetAutomorphVals@{isSetAutomorphVals}}
\index{isSetAutomorphVals@{isSetAutomorphVals}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{isSetAutomorphVals()}{isSetAutomorphVals()}}
{\footnotesize\ttfamily bool helib\+::is\+Set\+Automorph\+Vals (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_aff7fd713547b09f8f18fbf95ccf83f95}\label{namespacehelib_aff7fd713547b09f8f18fbf95ccf83f95}} 
\index{helib@{helib}!isSetAutomorphVals2@{isSetAutomorphVals2}}
\index{isSetAutomorphVals2@{isSetAutomorphVals2}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{isSetAutomorphVals2()}{isSetAutomorphVals2()}}
{\footnotesize\ttfamily bool helib\+::is\+Set\+Automorph\+Vals2 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_adaf92545afe42e1f4810b40c9e455af2}\label{namespacehelib_adaf92545afe42e1f4810b40c9e455af2}} 
\index{helib@{helib}!IsZero@{IsZero}}
\index{IsZero@{IsZero}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{IsZero()}{IsZero()}}
{\footnotesize\ttfamily bool helib\+::\+Is\+Zero (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a002c386c997a1dfb9113bb7a7070d95e}\label{namespacehelib_a002c386c997a1dfb9113bb7a7070d95e}} 
\index{helib@{helib}!iterateInterestRegion@{iterateInterestRegion}}
\index{iterateInterestRegion@{iterateInterestRegion}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{iterateInterestRegion()}{iterateInterestRegion()}}
{\footnotesize\ttfamily bool helib\+::iterate\+Interest\+Region (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{int}]{begin\+\_\+char,  }\item[{int}]{separator,  }\item[{int}]{end\+\_\+char }\end{DoxyParamCaption})}



Advance the input stream {\ttfamily str} beyond white spaces and a single {\ttfamily separator} in the region-\/of-\/interest delimited by {\ttfamily begin\+\_\+char} and {\ttfamily end\+\_\+char}. 


\begin{DoxyParams}{Parameters}
{\em str} & The stream to be advanced. \\
\hline
{\em begin\+\_\+char} & The character determining the beginning of the region-\/of-\/interest (to advance beyond of). \\
\hline
{\em separator} & The separator character to advance beyond of. \\
\hline
{\em end\+\_\+char} & The character determining the end of the region-\/of-\/interest (to advance beyond of). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the region-\/of-\/interest is not completed (i.\+e.\+: {\ttfamily end\+\_\+char} is not reached). {\ttfamily false} otherwise. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Throws {\ttfamily \mbox{\hyperlink{classhelib_1_1_runtime_error}{helib\+::\+Runtime\+Error}}} if after spaces there is a character different from {\ttfamily begin\+\_\+char}, {\ttfamily beyond}, or {\ttfamily end\+\_\+char}. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a5d98d78d4a4dddc7c6859af409b17e07}\label{namespacehelib_a5d98d78d4a4dddc7c6859af409b17e07}} 
\index{helib@{helib}!killVec@{killVec}}
\index{killVec@{killVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{killVec()}{killVec()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::kill\+Vec (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3ca37f043534295ce82c13c09b48325f}\label{namespacehelib_a3ca37f043534295ce82c13c09b48325f}} 
\index{helib@{helib}!killVec@{killVec}}
\index{killVec@{killVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{killVec()}{killVec()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::kill\+Vec (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{vec }\end{DoxyParamCaption})}



N\+T\+L/std compatibility. 

\mbox{\Hypertarget{namespacehelib_a4fb58a793bef4befd9d75d8852d8fc55}\label{namespacehelib_a4fb58a793bef4befd9d75d8852d8fc55}} 
\index{helib@{helib}!KSGiantStepSize@{KSGiantStepSize}}
\index{KSGiantStepSize@{KSGiantStepSize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{KSGiantStepSize()}{KSGiantStepSize()}}
{\footnotesize\ttfamily long helib\+::\+K\+S\+Giant\+Step\+Size (\begin{DoxyParamCaption}\item[{long}]{D }\end{DoxyParamCaption})}



Function that returns number of baby steps. Used to keep this and matmul routines \char`\"{}in sync\char`\"{}. 

\mbox{\Hypertarget{namespacehelib_abe1a3a33c80ba67655fd3cf8e6e66831}\label{namespacehelib_abe1a3a33c80ba67655fd3cf8e6e66831}} 
\index{helib@{helib}!largestCoeff@{largestCoeff}}
\index{largestCoeff@{largestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{largestCoeff()}{largestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily N\+T\+L\+::\+ZZ helib\+::largest\+Coeff (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a46eaa10d04eed2ee69d9e2c0a52528a7}\label{namespacehelib_a46eaa10d04eed2ee69d9e2c0a52528a7}} 
\index{helib@{helib}!largestCoeff@{largestCoeff}}
\index{largestCoeff@{largestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{largestCoeff()}{largestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily N\+T\+L\+::\+ZZ helib\+::largest\+Coeff (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adb4453a3ae42dffc130876e783bea3fe}\label{namespacehelib_adb4453a3ae42dffc130876e783bea3fe}} 
\index{helib@{helib}!largestCoeff@{largestCoeff}}
\index{largestCoeff@{largestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{largestCoeff()}{largestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
double helib\+::largest\+Coeff (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ T $>$ \&}]{f }\end{DoxyParamCaption})}



The L-\/infinity norm of an element (in coefficient representation) 

\mbox{\Hypertarget{namespacehelib_a1a20a91635cf835f5d24ba9fc0431002}\label{namespacehelib_a1a20a91635cf835f5d24ba9fc0431002}} 
\index{helib@{helib}!largestCoeff@{largestCoeff}}
\index{largestCoeff@{largestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{largestCoeff()}{largestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily N\+T\+L\+::\+ZZ helib\+::largest\+Coeff (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a77f80e02dad1c557005618be367c28f8}\label{namespacehelib_a77f80e02dad1c557005618be367c28f8}} 
\index{helib@{helib}!largestCoeff@{largestCoeff}}
\index{largestCoeff@{largestCoeff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{largestCoeff()}{largestCoeff()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
double helib\+::largest\+Coeff (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac577a548455a706fa164247e3801e05a}\label{namespacehelib_ac577a548455a706fa164247e3801e05a}} 
\index{helib@{helib}!leftBitwiseShift@{leftBitwiseShift}}
\index{leftBitwiseShift@{leftBitwiseShift}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{leftBitwiseShift()}{leftBitwiseShift()}}
{\footnotesize\ttfamily void helib\+::left\+Bitwise\+Shift (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{output,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{input,  }\item[{const long}]{shamt }\end{DoxyParamCaption})}



Left shift {\ttfamily input} by {\ttfamily shamt}. 

Shift binary numbers to the left by {\ttfamily shamt}


\begin{DoxyParams}{Parameters}
{\em output} & Shifted result. \\
\hline
{\em input} & The number to be shifted. \\
\hline
{\em shamt} & The number to bits to shift by. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This is a left shift only, i.\+e. the bits are moved to the most-\/significant end. 

{\ttfamily shamt} must be positive. 

The size of {\ttfamily output} and {\ttfamily input} must be the same. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_ac5bd3c856c7b75630a3fee625848debf}\label{namespacehelib_ac5bd3c856c7b75630a3fee625848debf}} 
\index{helib@{helib}!length@{length}}
\index{length@{length}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{length()}{length()}}
{\footnotesize\ttfamily long helib\+::length (\begin{DoxyParamCaption}\item[{Gen\+Node\+Ptr}]{ptr }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a592d23357f47db9beb431daa00b1837b}\label{namespacehelib_a592d23357f47db9beb431daa00b1837b}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [1/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+G\+F2E \&}]{a,  }\item[{const N\+T\+L\+::\+G\+F2E \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3a95ea63e91091bd7cae299abf5b60e9}\label{namespacehelib_a3a95ea63e91091bd7cae299abf5b60e9}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [2/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+G\+F2\+EX \&}]{a,  }\item[{const N\+T\+L\+::\+G\+F2\+EX \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acba849e54a054c14527a708b0738735d}\label{namespacehelib_acba849e54a054c14527a708b0738735d}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [3/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+G\+F2X \&}]{a,  }\item[{const N\+T\+L\+::\+G\+F2X \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ade745be425656ca6550b68e91647df4d}\label{namespacehelib_ade745be425656ca6550b68e91647df4d}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [4/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::zz\+\_\+pE \&}]{a,  }\item[{const N\+T\+L\+::zz\+\_\+pE \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a58072d3099fe887b7de62dba4b16a337}\label{namespacehelib_a58072d3099fe887b7de62dba4b16a337}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [5/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::zz\+\_\+p\+EX \&}]{a,  }\item[{const N\+T\+L\+::zz\+\_\+p\+EX \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6da437fc5e5b62183567bd8885b5b086}\label{namespacehelib_a6da437fc5e5b62183567bd8885b5b086}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [6/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{a,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0780cab8a4fd2f230bfcc1822814cf06}\label{namespacehelib_a0780cab8a4fd2f230bfcc1822814cf06}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [7/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+G\+F2}]{a,  }\item[{N\+T\+L\+::\+G\+F2}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a507149d174b7d75b1db57d876791fa93}\label{namespacehelib_a507149d174b7d75b1db57d876791fa93}} 
\index{helib@{helib}!less\_than@{less\_than}}
\index{less\_than@{less\_than}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{less\_than()}{less\_than()}\hspace{0.1cm}{\footnotesize\ttfamily [8/8]}}
{\footnotesize\ttfamily bool helib\+::less\+\_\+than (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+p}]{a,  }\item[{N\+T\+L\+::zz\+\_\+p}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac1630d15e5b8352685afcf561db40323}\label{namespacehelib_ac1630d15e5b8352685afcf561db40323}} 
\index{helib@{helib}!log2@{log2}}
\index{log2@{log2}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{log2()}{log2()}}
{\footnotesize\ttfamily double helib\+::log2 (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::xdouble \&}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Base-\/2 logarithm. 

\mbox{\Hypertarget{namespacehelib_a07a78ea9ad3d9a0793325a14262965f5}\label{namespacehelib_a07a78ea9ad3d9a0793325a14262965f5}} 
\index{helib@{helib}!log2\_realToEstimatedNoise@{log2\_realToEstimatedNoise}}
\index{log2\_realToEstimatedNoise@{log2\_realToEstimatedNoise}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{log2\_realToEstimatedNoise()}{log2\_realToEstimatedNoise()}}
{\footnotesize\ttfamily double helib\+::log2\+\_\+real\+To\+Estimated\+Noise (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab0f609e8138ce597457cbf6168d27363}\label{namespacehelib_ab0f609e8138ce597457cbf6168d27363}} 
\index{helib@{helib}!longToBitVector@{longToBitVector}}
\index{longToBitVector@{longToBitVector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{longToBitVector()}{longToBitVector()}}
{\footnotesize\ttfamily std\+::vector$<$ long $>$ helib\+::long\+To\+Bit\+Vector (\begin{DoxyParamCaption}\item[{long}]{num,  }\item[{long}]{bit\+Size }\end{DoxyParamCaption})}



Returns a number as a vector of bits with L\+SB on the left. 


\begin{DoxyParams}{Parameters}
{\em num} & Number to be converted. \\
\hline
{\em bit\+Size} & Number of bits of the input and output. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Bit vector representation of num. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
{\ttfamily bit\+Size} must be non-\/negative. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a50cb104179094690467c87a1c09c8a05}\label{namespacehelib_a50cb104179094690467c87a1c09c8a05}} 
\index{helib@{helib}!lsize@{lsize}}
\index{lsize@{lsize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{lsize()}{lsize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
long helib\+::lsize (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a1d7c647ab302e0d9844b52884e086071}\label{namespacehelib_a1d7c647ab302e0d9844b52884e086071}} 
\index{helib@{helib}!lsize@{lsize}}
\index{lsize@{lsize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{lsize()}{lsize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
long helib\+::lsize (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a368a1406fcc81e32dce3caebda60477b}\label{namespacehelib_a368a1406fcc81e32dce3caebda60477b}} 
\index{helib@{helib}!lsize@{lsize}}
\index{lsize@{lsize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{lsize()}{lsize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
long helib\+::lsize (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae8f65ef133cee27ad846423d012d5487}\label{namespacehelib_ae8f65ef133cee27ad846423d012d5487}} 
\index{helib@{helib}!lsize@{lsize}}
\index{lsize@{lsize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{lsize()}{lsize()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
long helib\+::lsize (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Size of S\+TL vector as a long (rather than unsigned long) 

\mbox{\Hypertarget{namespacehelib_a454437c5c0e3415fe2a360fa48a3eb5f}\label{namespacehelib_a454437c5c0e3415fe2a360fa48a3eb5f}} 
\index{helib@{helib}!make\_lazy@{make\_lazy}}
\index{make\_lazy@{make\_lazy}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{make\_lazy()}{make\_lazy()}}
{\footnotesize\ttfamily template$<$typename T , typename P , typename... Args$>$ \\
void helib\+::make\+\_\+lazy (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Lazy$<$ T, P $>$ \&}]{obj,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})}

This should go in N\+TL some day... Just call as make\+\_\+lazy(obj, ...) to initialize a lazy object via a call to a constructor T(...) \mbox{\Hypertarget{namespacehelib_a05c7ab380349944791e571afd60e7a06}\label{namespacehelib_a05c7ab380349944791e571afd60e7a06}} 
\index{helib@{helib}!make\_lazy\_with\_fun@{make\_lazy\_with\_fun}}
\index{make\_lazy\_with\_fun@{make\_lazy\_with\_fun}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{make\_lazy\_with\_fun()}{make\_lazy\_with\_fun()}}
{\footnotesize\ttfamily template$<$typename T , typename P , typename F , typename... Args$>$ \\
void helib\+::make\+\_\+lazy\+\_\+with\+\_\+fun (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Lazy$<$ T, P $>$ \&}]{obj,  }\item[{F}]{f,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})}

This should go in N\+TL some day... Just call as make\+\_\+lazy(obj, f, ....) to initialize a lazy object via a call to f($\ast$obj, ...) \mbox{\Hypertarget{namespacehelib_adad7e0c1723b324e29278f21aa889143}\label{namespacehelib_adad7e0c1723b324e29278f21aa889143}} 
\index{helib@{helib}!makeIrredPoly@{makeIrredPoly}}
\index{makeIrredPoly@{makeIrredPoly}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{makeIrredPoly()}{makeIrredPoly()}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::make\+Irred\+Poly (\begin{DoxyParamCaption}\item[{long}]{p,  }\item[{long}]{d }\end{DoxyParamCaption})}



Return a degree-\/d irreducible polynomial mod p. 

\mbox{\Hypertarget{namespacehelib_a5b2e968f2faca98f693ac809962242ba}\label{namespacehelib_a5b2e968f2faca98f693ac809962242ba}} 
\index{helib@{helib}!makeQueryExpr@{makeQueryExpr}}
\index{makeQueryExpr@{makeQueryExpr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{makeQueryExpr()}{makeQueryExpr()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{classhelib_1_1_col_number}{Col\+Number}}$>$ helib\+::make\+Query\+Expr (\begin{DoxyParamCaption}\item[{int}]{cl }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Utility function for creating a shared pointer to a specified column in a query. 


\begin{DoxyParams}{Parameters}
{\em cl} & The index of the column to be used in the query. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the class {\ttfamily \mbox{\hyperlink{classhelib_1_1_col_number}{Col\+Number}}}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_a6ec750de20965b96fdc12370f8222f15}\label{namespacehelib_a6ec750de20965b96fdc12370f8222f15}} 
\index{helib@{helib}!mapTo01@{mapTo01}}
\index{mapTo01@{mapTo01}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mapTo01()}{mapTo01()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template void helib\+::map\+To01 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab7e150be3c72dc211544b82bd1250376}\label{namespacehelib_ab7e150be3c72dc211544b82bd1250376}} 
\index{helib@{helib}!mapTo01@{mapTo01}}
\index{mapTo01@{mapTo01}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mapTo01()}{mapTo01()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template void helib\+::map\+To01 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a80f9aef0e58c5e559789b25355c64717}\label{namespacehelib_a80f9aef0e58c5e559789b25355c64717}} 
\index{helib@{helib}!mapTo01@{mapTo01}}
\index{mapTo01@{mapTo01}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mapTo01()}{mapTo01()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
void helib\+::map\+To01 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a4d0fb010c5631535fe448caabc974860}\label{namespacehelib_a4d0fb010c5631535fe448caabc974860}} 
\index{helib@{helib}!mapTo01@{mapTo01}}
\index{mapTo01@{mapTo01}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mapTo01()}{mapTo01()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void helib\+::map\+To01 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a21a15540439b4c2c57e1e5eb129cd54a}\label{namespacehelib_a21a15540439b4c2c57e1e5eb129cd54a}} 
\index{helib@{helib}!max\_abs@{max\_abs}}
\index{max\_abs@{max\_abs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{max\_abs()}{max\_abs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double helib\+::max\+\_\+abs (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ double $>$ \&}]{vec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a113e6cbc8db288631df5f13330027dc3}\label{namespacehelib_a113e6cbc8db288631df5f13330027dc3}} 
\index{helib@{helib}!max\_abs@{max\_abs}}
\index{max\_abs@{max\_abs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{max\_abs()}{max\_abs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double helib\+::max\+\_\+abs (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::complex$<$ double $>$$>$ \&}]{vec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Simple routine for computing the max-\/abs of a vector of complex numbers and real numbers \mbox{\Hypertarget{namespacehelib_a5e9f98f558e2fcf0a90b77e74f54958f}\label{namespacehelib_a5e9f98f558e2fcf0a90b77e74f54958f}} 
\index{helib@{helib}!maximum\_flow@{maximum\_flow}}
\index{maximum\_flow@{maximum\_flow}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{maximum\_flow()}{maximum\_flow()}}
{\footnotesize\ttfamily long helib\+::maximum\+\_\+flow (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_af547f7016fc73b7174a2018ea28ef298}{Flow\+Graph}} \&}]{fg,  }\item[{long}]{src,  }\item[{long}]{sink }\end{DoxyParamCaption})}

Remove from the graph all the flow-\/zero edges for (long i=0; i$<$(long)fg.\+size(); i++) \{ F\+Neighbor\+List\+::iterator it1=fg\mbox{[}i\mbox{]}.begin(); do \{ F\+Neighbor\+List\+::iterator it2 = it1; it1++; // increment the iterator before potentially erasing the edge if (it2-\/$>$second.\+flow == 0) fg\mbox{[}i\mbox{]}.erase(it2); \} while (it1 != fg\mbox{[}i\mbox{]}.end()); \}

Remove from the graph all the flow-\/zero edges for (long i=0; i$<$(long)fg.\+size(); i++) \{ F\+Neighbor\+List\+::iterator it1=fg\mbox{[}i\mbox{]}.begin(); do \{ F\+Neighbor\+List\+::iterator it2 = it1; it1++; // increment the iterator before potentially erasing the edge if (it2-\/$>$second.\+flow == 0) fg\mbox{[}i\mbox{]}.erase(it2); \} while (it1 != fg\mbox{[}i\mbox{]}.end()); \}\mbox{\Hypertarget{namespacehelib_a51f60e27cb24d575d4b10a522dbb4279}\label{namespacehelib_a51f60e27cb24d575d4b10a522dbb4279}} 
\index{helib@{helib}!mcDiv@{mcDiv}}
\index{mcDiv@{mcDiv}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mcDiv()}{mcDiv()}}
{\footnotesize\ttfamily long helib\+::mc\+Div (\begin{DoxyParamCaption}\item[{long}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3f2638750d81a618d59217f3e9b3218a}\label{namespacehelib_a3f2638750d81a618d59217f3e9b3218a}} 
\index{helib@{helib}!mcMod@{mcMod}}
\index{mcMod@{mcMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mcMod()}{mcMod()}}
{\footnotesize\ttfamily long helib\+::mc\+Mod (\begin{DoxyParamCaption}\item[{long}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})}



Routines for computing mathematically correct mod and div. 

mc\+Div(a, b) = floor(a / b), mc\+Mod(a, b) = a -\/ b$\ast$mc\+Div(a, b); in particular, mc\+Mod(a, b) is 0 or has the same sign as b \mbox{\Hypertarget{namespacehelib_ad4d98c1a6634ea3827fafd456ea56a5e}\label{namespacehelib_ad4d98c1a6634ea3827fafd456ea56a5e}} 
\index{helib@{helib}!mobius@{mobius}}
\index{mobius@{mobius}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mobius()}{mobius()}}
{\footnotesize\ttfamily long helib\+::mobius (\begin{DoxyParamCaption}\item[{long}]{n }\end{DoxyParamCaption})}



Compute mobius function (naive method as n is small). 

\mbox{\Hypertarget{namespacehelib_ad7d7a435e482d03e39e3b592765adc85}\label{namespacehelib_ad7d7a435e482d03e39e3b592765adc85}} 
\index{helib@{helib}!ModComp@{ModComp}}
\index{ModComp@{ModComp}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ModComp()}{ModComp()}}
{\footnotesize\ttfamily void helib\+::\+Mod\+Comp (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{res,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{g,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{h,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f }\end{DoxyParamCaption})}



Modular composition of polynomials\+: res = g(h) mod f. 

\mbox{\Hypertarget{namespacehelib_a0cfe07d1b0c2f0e6385f2b6525e0a69b}\label{namespacehelib_a0cfe07d1b0c2f0e6385f2b6525e0a69b}} 
\index{helib@{helib}!mul@{mul}}
\index{mul@{mul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily void helib\+::mul (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa8141de7917e8d05d1a056a45a500615}\label{namespacehelib_aa8141de7917e8d05d1a056a45a500615}} 
\index{helib@{helib}!mul@{mul}}
\index{mul@{mul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily void helib\+::mul (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_block_mat_mul1_d}{Block\+Mat\+Mul1D}} \&}]{mat }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac82ecaab9292facff3375eaf73ba6196}\label{namespacehelib_ac82ecaab9292facff3375eaf73ba6196}} 
\index{helib@{helib}!mul@{mul}}
\index{mul@{mul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily void helib\+::mul (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_block_mat_mul_full}{Block\+Mat\+Mul\+Full}} \&}]{mat }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3c4bb86fb8d5306854596862d66e440e}\label{namespacehelib_a3c4bb86fb8d5306854596862d66e440e}} 
\index{helib@{helib}!mul@{mul}}
\index{mul@{mul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily void helib\+::mul (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_mat_mul1_d}{Mat\+Mul1D}} \&}]{mat }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a22728992014e959480483be6cad9c86f}\label{namespacehelib_a22728992014e959480483be6cad9c86f}} 
\index{helib@{helib}!mul@{mul}}
\index{mul@{mul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily void helib\+::mul (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_mat_mul_full}{Mat\+Mul\+Full}} \&}]{mat }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a50c25069289464e0a2fb8398199fd5ef}\label{namespacehelib_a50c25069289464e0a2fb8398199fd5ef}} 
\index{helib@{helib}!mul@{mul}}
\index{mul@{mul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily void helib\+::mul (\begin{DoxyParamCaption}\item[{std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{x,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac8f88c1ce38bfe194b79c6fff9842e3a}\label{namespacehelib_ac8f88c1ce38bfe194b79c6fff9842e3a}} 
\index{helib@{helib}!mul@{mul}}
\index{mul@{mul}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily void helib\+::mul (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{res,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a408eff115fb052630554303601257388}\label{namespacehelib_a408eff115fb052630554303601257388}} 
\index{helib@{helib}!MulAdd@{MulAdd}}
\index{MulAdd@{MulAdd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{MulAdd()}{MulAdd()}}
{\footnotesize\ttfamily void helib\+::\+Mul\+Add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{x,  }\item[{const std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structhelib_1_1_const_multiplier}{Const\+Multiplier}} $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a16376b83d0b9ac08d1cc631756741220}\label{namespacehelib_a16376b83d0b9ac08d1cc631756741220}} 
\index{helib@{helib}!MulMod@{MulMod}}
\index{MulMod@{MulMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{MulMod()}{MulMod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::\+Mul\+Mod (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f,  }\item[{long}]{a,  }\item[{long}]{q }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a44a8cf8d3d1da74a8060a177e3e49028}\label{namespacehelib_a44a8cf8d3d1da74a8060a177e3e49028}} 
\index{helib@{helib}!MulMod@{MulMod}}
\index{MulMod@{MulMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{MulMod()}{MulMod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::\+Mul\+Mod (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f,  }\item[{long}]{a,  }\item[{long}]{q,  }\item[{bool}]{abs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ab7f0968146827a1378c640d201604a02}\label{namespacehelib_ab7f0968146827a1378c640d201604a02}} 
\index{helib@{helib}!MulMod@{MulMod}}
\index{MulMod@{MulMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{MulMod()}{MulMod()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} helib\+::\+Mul\+Mod (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{b,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_af73b2f08337ba65b54609e7bfca96cda}\label{namespacehelib_af73b2f08337ba65b54609e7bfca96cda}} 
\index{helib@{helib}!MulMod@{MulMod}}
\index{MulMod@{MulMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{MulMod()}{MulMod()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void helib\+::\+Mul\+Mod (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{out,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f,  }\item[{long}]{a,  }\item[{long}]{q }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a8fc507c5ea1850c348a7c2d743b59a57}\label{namespacehelib_a8fc507c5ea1850c348a7c2d743b59a57}} 
\index{helib@{helib}!MulMod@{MulMod}}
\index{MulMod@{MulMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{MulMod()}{MulMod()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void helib\+::\+Mul\+Mod (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{out,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f,  }\item[{long}]{a,  }\item[{long}]{q,  }\item[{bool}]{abs }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af65e2fcd58de0be9a17f875701fec9e3}\label{namespacehelib_af65e2fcd58de0be9a17f875701fec9e3}} 
\index{helib@{helib}!MulMod@{MulMod}}
\index{MulMod@{MulMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{MulMod()}{MulMod()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily void helib\+::\+Mul\+Mod (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{res,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{b,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a96fc760be384a17313e24f5383ceabd1}\label{namespacehelib_a96fc760be384a17313e24f5383ceabd1}} 
\index{helib@{helib}!multOrd@{multOrd}}
\index{multOrd@{multOrd}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{multOrd()}{multOrd()}}
{\footnotesize\ttfamily long helib\+::mult\+Ord (\begin{DoxyParamCaption}\item[{long}]{p,  }\item[{long}]{m }\end{DoxyParamCaption})}



Return multiplicative order of p modulo m, or 0 if G\+C\+D(p, m) != 1. 

\mbox{\Hypertarget{namespacehelib_aa9936528f7b1f6865e4a496047caba21}\label{namespacehelib_aa9936528f7b1f6865e4a496047caba21}} 
\index{helib@{helib}!multTwoNumbers@{multTwoNumbers}}
\index{multTwoNumbers@{multTwoNumbers}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{multTwoNumbers()}{multTwoNumbers()}}
{\footnotesize\ttfamily void helib\+::mult\+Two\+Numbers (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{product,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{rhs,  }\item[{bool}]{rhs\+Twos\+Complement = {\ttfamily false},  }\item[{long}]{size\+Limit = {\ttfamily 0},  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Multiply two numbers in binary representation where each ciphertext of the input vector contains a bit. 


\begin{DoxyParams}{Parameters}
{\em product} & result of the multiplication operation. \\
\hline
{\em lhs} & left hand side of the multiplication. \\
\hline
{\em rhs} & right hand side of the multiplication. \\
\hline
{\em rhs\+Twos\+Complement} & flag to state the multiplier is potentially negative. \\
\hline
{\em size\+Limit} & number of bits to compute on, taken from the least significant end. \\
\hline
{\em unpack\+Slot\+Encoding} & vector of constants for unpacking, as used in bootstrapping. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a2f6016d5e65b16abb1feba5a82067b14}\label{namespacehelib_a2f6016d5e65b16abb1feba5a82067b14}} 
\index{helib@{helib}!negate@{negate}}
\index{negate@{negate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{negate()}{negate()}}
{\footnotesize\ttfamily void helib\+::negate (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aaff515cbc7e22db14c0b22c910f4cee2}\label{namespacehelib_aaff515cbc7e22db14c0b22c910f4cee2}} 
\index{helib@{helib}!negateBinary@{negateBinary}}
\index{negateBinary@{negateBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{negateBinary()}{negateBinary()}}
{\footnotesize\ttfamily void helib\+::negate\+Binary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{negation,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{input }\end{DoxyParamCaption})}



Negates a number in binary 2\textquotesingle{}s complement representation. 


\begin{DoxyParams}{Parameters}
{\em negation} & Reference to the negated number that will be populated. \\
\hline
{\em input} & Number to be negated. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\ttfamily input} will be treated as a number in 2\textquotesingle{}s complement. 

{\ttfamily input} must not alias negation. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_ac285b2405b33a6bf1d27953c5bb89e61}\label{namespacehelib_ac285b2405b33a6bf1d27953c5bb89e61}} 
\index{helib@{helib}!normalize@{normalize}}
\index{normalize@{normalize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{normalize()}{normalize()}}
{\footnotesize\ttfamily void helib\+::normalize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adcd34bfd104a104754a69b08d12882a4}\label{namespacehelib_adcd34bfd104a104754a69b08d12882a4}} 
\index{helib@{helib}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool helib\+::operator!= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&}]{map1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&}]{map2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acf1a512fb48fe7d9cfc27c26a727ed6f}\label{namespacehelib_acf1a512fb48fe7d9cfc27c26a727ed6f}} 
\index{helib@{helib}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator\&()}{operator\&()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} helib\+::operator\& (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{t }\end{DoxyParamCaption})}



intersection 

\mbox{\Hypertarget{namespacehelib_ad1e3d7533fd36aed14028db8a0aec5c2}\label{namespacehelib_ad1e3d7533fd36aed14028db8a0aec5c2}} 
\index{helib@{helib}!operator\&\&@{operator\&\&}}
\index{operator\&\&@{operator\&\&}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator\&\&()}{operator\&\&()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{classhelib_1_1_and}{And}}$>$ helib\+::operator\&\& (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Overloaded operator for creating a shared pointer to an A\+ND expression. 


\begin{DoxyParams}{Parameters}
{\em lhs} & Left operand of the A\+ND expression. \\
\hline
{\em rhs} & Right operand of the A\+ND expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the class {\ttfamily \mbox{\hyperlink{classhelib_1_1_and}{And}}}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_a741ff01e6d83fef924789f35d31af24b}\label{namespacehelib_a741ff01e6d83fef924789f35d31af24b}} 
\index{helib@{helib}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , typename T2 , typename std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ T, std\+::size\+\_\+t $>$\+::value $>$ $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T, 2 $>$ helib\+::operator$\ast$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T, 2 $>$ \&}]{M1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_tensor}{Tensor}}$<$ T2, 2 $>$ \&}]{M2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a426440bf36745c2e46ae9826ca70724c}\label{namespacehelib_a426440bf36745c2e46ae9826ca70724c}} 
\index{helib@{helib}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} helib\+::operator$\ast$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a2526335487a72bde255cc7a916f9736f}\label{namespacehelib_a2526335487a72bde255cc7a916f9736f}} 
\index{helib@{helib}!operator$\ast$=@{operator$\ast$=}}
\index{operator$\ast$=@{operator$\ast$=}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$\ast$=()}{operator*=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}}\& helib\+::operator$\ast$= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a0efa98b2b2f5303eee2c106240c17b11}\label{namespacehelib_a0efa98b2b2f5303eee2c106240c17b11}} 
\index{helib@{helib}!operator+@{operator+}}
\index{operator+@{operator+}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} helib\+::operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ac1a8de3a0f340ce6a600fa1da2233191}\label{namespacehelib_ac1a8de3a0f340ce6a600fa1da2233191}} 
\index{helib@{helib}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator+=()}{operator+=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}}\& helib\+::operator+= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a32e627abcebb74bf780514be8d6c744c}\label{namespacehelib_a32e627abcebb74bf780514be8d6c744c}} 
\index{helib@{helib}!operator/@{operator/}}
\index{operator/@{operator/}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator/()}{operator/()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} helib\+::operator/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{t }\end{DoxyParamCaption})}



set minus 

\mbox{\Hypertarget{namespacehelib_a70e5cb71e5ab89ad99c81b175ed126cd}\label{namespacehelib_a70e5cb71e5ab89ad99c81b175ed126cd}} 
\index{helib@{helib}!operator/@{operator/}}
\index{operator/@{operator/}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator/()}{operator/()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} helib\+::operator/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a7dbb01a7d1b26b95c0abff58d28bdb0e}\label{namespacehelib_a7dbb01a7d1b26b95c0abff58d28bdb0e}} 
\index{helib@{helib}!operator/=@{operator/=}}
\index{operator/=@{operator/=}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator/=()}{operator/=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}}\& helib\+::operator/= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{long}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_abd46fc7a6f4b03ce4a28aea9e7c0a451}\label{namespacehelib_abd46fc7a6f4b03ce4a28aea9e7c0a451}} 
\index{helib@{helib}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$()}{operator<()}}
{\footnotesize\ttfamily bool helib\+::operator$<$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s2 }\end{DoxyParamCaption})}



Is s1 strict subset of s2. 

\mbox{\Hypertarget{namespacehelib_af8df733be35482f6834a083a9de5e4a6}\label{namespacehelib_af8df733be35482f6834a083a9de5e4a6}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [1/24]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
std\+::ostream \& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{is,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{ptxt }\end{DoxyParamCaption})}



Output shift operator. Uses the {\ttfamily serialize} function internally. 


\begin{DoxyParams}{Parameters}
{\em os} & Output {\ttfamily std\+::ostream}. \\
\hline
{\em ptxt} & {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object to be written. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Input {\ttfamily std\+::ostream} post writing. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
{\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} {\ttfamily context} is not serialized, see note of {\ttfamily operator$>$$>$}.
\end{DoxyNote}
The output stream will be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each slot of {\ttfamily ptxt} will be serialized in an element of such list by the {\ttfamily serialize} function determined by the scheme.~\newline
For example if we have a plaintext {\ttfamily ptxt} such that {\ttfamily ptxt\mbox{[}0\mbox{]}=slot0}, {\ttfamily ptxt\mbox{[}1\mbox{]}=slot1}, {\ttfamily ptxt\mbox{[}2\mbox{]}=slot2}, and {\ttfamily ptxt\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}, it will be serialized as \textquotesingle{}\mbox{[}\textquotesingle{}slot0\textquotesingle{}, \textquotesingle{}slot1\textquotesingle{}, \textquotesingle{}slot2\textquotesingle{}, {\ttfamily 0}, {\ttfamily 0} ...\mbox{]}\textquotesingle{}. \mbox{\Hypertarget{namespacehelib_a8e75bdb938a5f96094db55ea323250d2}\label{namespacehelib_a8e75bdb938a5f96094db55ea323250d2}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [2/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&}]{poly }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em os} & Output {\ttfamily std\+::ostream}. \\
\hline
{\em poly} & {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object to be written. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Input {\ttfamily std\+::ostream} post writing. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
p2r and G are not serialized, see note of {\ttfamily operator$>$$>$}.
\end{DoxyNote}
The output stream will be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each coefficient of {\ttfamily poly} will be serialized in an element of such list by the {\ttfamily $>$$>$} operator.~\newline
For example if we have a {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object {\ttfamily poly} such that {\ttfamily poly\mbox{[}0\mbox{]}=coef0}, {\ttfamily poly\mbox{[}1\mbox{]}=coef1}, {\ttfamily poly\mbox{[}2\mbox{]}=coef2}, and {\ttfamily poly\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}, it will be serialized as \textquotesingle{}\mbox{[}\textquotesingle{}coef0\textquotesingle{}, \textquotesingle{}coef1\textquotesingle{}, \textquotesingle{}coef2\textquotesingle{}\mbox{]}\textquotesingle{}. \mbox{\Hypertarget{namespacehelib_a56cf6e939823e9a136817850ea93c1cb}\label{namespacehelib_a56cf6e939823e9a136817850ea93c1cb}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [3/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{structhelib_1_1_poly_mod_ring}{Poly\+Mod\+Ring}} \&}]{ring }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em os} & Output {\ttfamily std\+::ostream}. \\
\hline
{\em ring} & {\ttfamily \mbox{\hyperlink{structhelib_1_1_poly_mod_ring}{Poly\+Mod\+Ring}}} object to be written. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Input {\ttfamily std\+::ostream} post writing. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_ac6b38e2bdf2734a792b5f11fe5f293be}\label{namespacehelib_ac6b38e2bdf2734a792b5f11fe5f293be}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [4/24]}}
{\footnotesize\ttfamily std\+::ostream \& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_col_perm}{Col\+Perm}} \&}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2d941f20d5c3e55e3b36b36dd5164d6b}\label{namespacehelib_a2d941f20d5c3e55e3b36b36dd5164d6b}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [5/24]}}
{\footnotesize\ttfamily std\+::ostream \& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt_part}{Ctxt\+Part}} \&}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a55a30d40b8861180c13416755e880749}\label{namespacehelib_a55a30d40b8861180c13416755e880749}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [6/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_signature}{Cube\+Signature}} \&}]{sig }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a548b26739f763a0bb78c6ca1eec1a3d4}\label{namespacehelib_a548b26739f763a0bb78c6ca1eec1a3d4}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [7/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_generator_trees}{Generator\+Trees}} \&}]{trees }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aba72e7396d96094a33df27ad8d11d5d0}\label{namespacehelib_aba72e7396d96094a33df27ad8d11d5d0}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [8/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_moduli_sizes}{Moduli\+Sizes}} \&}]{szs }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a546b744efbb3ba1575148bcb9e2ba724}\label{namespacehelib_a546b744efbb3ba1575148bcb9e2ba724}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [9/24]}}
{\footnotesize\ttfamily std\+::ostream \& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a16380874c94bf4781b228d986d9882ca}\label{namespacehelib_a16380874c94bf4781b228d986d9882ca}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [10/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_perm_network}{Perm\+Network}} \&}]{net }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae5cdfe4d2a5d750a2f2ae0f2d0addabc}\label{namespacehelib_ae5cdfe4d2a5d750a2f2ae0f2d0addabc}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [11/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_addc58993c7093dd07d98335bab200e82}\label{namespacehelib_addc58993c7093dd07d98335bab200e82}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [12/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} \&}]{handle }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a8794be0244c26078eabc3c5343c86897}\label{namespacehelib_a8794be0244c26078eabc3c5343c86897}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [13/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sub_dimension}{Sub\+Dimension}} \&}]{sd }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_acd38c901ef879aa74f5070cdd2b38790}\label{namespacehelib_acd38c901ef879aa74f5070cdd2b38790}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [14/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{Gen\+Node\+Ptr}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1924de36f81ef4338bb2526dd03bfe97}\label{namespacehelib_a1924de36f81ef4338bb2526dd03bfe97}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [15/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{Long\+Node\+Ptr}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a8407900faf89358e471aef0bdb902da8}\label{namespacehelib_a8407900faf89358e471aef0bdb902da8}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [16/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{Split\+Node\+Ptr}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a91bd0e83a2e59c7de3a489b5d3fb3aa8}\label{namespacehelib_a91bd0e83a2e59c7de3a489b5d3fb3aa8}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [17/24]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{std\+::vector$<$ T $>$}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6c8dd31cc08df15a8e5925a06eae00de}\label{namespacehelib_a6c8dd31cc08df15a8e5925a06eae00de}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [18/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac6e1a9de8dac4a717ec046b76d4d9381}\label{namespacehelib_ac6e1a9de8dac4a717ec046b76d4d9381}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [19/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad05fd6e657aa88416b97a48fb5112d8a}\label{namespacehelib_ad05fd6e657aa88416b97a48fb5112d8a}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [20/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5c345e01afae95eff45dd95f58fab624}\label{namespacehelib_a5c345e01afae95eff45dd95f58fab624}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [21/24]}}
{\footnotesize\ttfamily std\+::ostream \& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{set }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae5b3ba4659fee95212891f530d1a88c1}\label{namespacehelib_ae5b3ba4659fee95212891f530d1a88c1}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [22/24]}}
{\footnotesize\ttfamily std\+::ostream \& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_key_switch}{Key\+Switch}} \&}]{matrix }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a794976b9b52689a77c7895c58ffd65da}\label{namespacehelib_a794976b9b52689a77c7895c58ffd65da}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [23/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&}]{pk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1777b65a3298c49a20e8554bc70a2cd1}\label{namespacehelib_a1777b65a3298c49a20e8554bc70a2cd1}} 
\index{helib@{helib}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [24/24]}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aeb431149ad4752359e90a9559196b71b}\label{namespacehelib_aeb431149ad4752359e90a9559196b71b}} 
\index{helib@{helib}!operator$<$$<$$<$BGV $>$@{operator$<$$<$$<$BGV $>$}}
\index{operator$<$$<$$<$BGV $>$@{operator$<$$<$$<$BGV $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$$<$BGV $>$()}{operator<<<BGV >()}}
{\footnotesize\ttfamily template std\+::ostream\& helib\+::operator$<$$<$$<$\mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af69b9423e994641a90a8401f74631180}\label{namespacehelib_af69b9423e994641a90a8401f74631180}} 
\index{helib@{helib}!operator$<$$<$$<$CKKS $>$@{operator$<$$<$$<$CKKS $>$}}
\index{operator$<$$<$$<$CKKS $>$@{operator$<$$<$$<$CKKS $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$$<$CKKS $>$()}{operator<<<CKKS >()}}
{\footnotesize\ttfamily template std\+::ostream\& helib\+::operator$<$$<$$<$\mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa13e586e5a2a1ea2fd8fe9e3c45b4c98}\label{namespacehelib_aa13e586e5a2a1ea2fd8fe9e3c45b4c98}} 
\index{helib@{helib}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$<$=()}{operator<=()}}
{\footnotesize\ttfamily bool helib\+::operator$<$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s2 }\end{DoxyParamCaption})}



Is s1 subset or equal to s2. 

\mbox{\Hypertarget{namespacehelib_ad5f68b7e6b0ff2bbf68b999655480fac}\label{namespacehelib_ad5f68b7e6b0ff2bbf68b999655480fac}} 
\index{helib@{helib}!operator==@{operator==}}
\index{operator==@{operator==}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool helib\+::operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&}]{map1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_map}{Index\+Map}}$<$ T $>$ \&}]{map2 }\end{DoxyParamCaption})}



Comparing maps, by comparing all the elements. 

\mbox{\Hypertarget{namespacehelib_ab7d409fa53b729e5d370d032f643f321}\label{namespacehelib_ab7d409fa53b729e5d370d032f643f321}} 
\index{helib@{helib}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$()}{operator>()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool helib\+::operator$>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s2 }\end{DoxyParamCaption})}



Is s2 strict subset of s1. 

\mbox{\Hypertarget{namespacehelib_abf366cbdad4242e525976c1f8664a3fc}\label{namespacehelib_abf366cbdad4242e525976c1f8664a3fc}} 
\index{helib@{helib}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$()}{operator>()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool helib\+::operator$>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&}]{a,  }\item[{const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a4807b29449792c9a8456921063d03c91}\label{namespacehelib_a4807b29449792c9a8456921063d03c91}} 
\index{helib@{helib}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$=()}{operator>=()}}
{\footnotesize\ttfamily bool helib\+::operator$>$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s2 }\end{DoxyParamCaption})}



Is s2 subset or equal to s2. 

\mbox{\Hypertarget{namespacehelib_a3a5af20ad95e41b4f1d072aef127abe8}\label{namespacehelib_a3a5af20ad95e41b4f1d072aef127abe8}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [1/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&}]{poly }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em is} & Input {\ttfamily std\+::istream}. \\
\hline
{\em poly} & Destination {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Input {\ttfamily std\+::istream} post reading. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
{\ttfamily poly} must be constructed with an appropriate p2r and G {\bfseries{B\+E\+F\+O\+RE}} calling this function. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{PolyMod my\_poly(p2r, G);}
\DoxyCodeLine{std::cin >> my\_poly;}
\end{DoxyCode}

\end{DoxyNote}
The input stream has to be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each element of the list will be deserialized as a coefficient of the polynomial.~\newline
If the number of tokens in the list is less than the number of coefficients, the higher-\/degree coefficients will be padded by 0.~\newline
For example \textquotesingle{}\mbox{[}\textquotesingle{}coef0\textquotesingle{}, \textquotesingle{}coef1\textquotesingle{}, \textquotesingle{}coef2\textquotesingle{}\mbox{]}\textquotesingle{} will be deserialized as a {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object {\ttfamily poly} where {\ttfamily poly\mbox{[}0\mbox{]}=coef0}, {\ttfamily poly\mbox{[}1\mbox{]}=coef1}, {\ttfamily poly\mbox{[}2\mbox{]}=coef2} and {\ttfamily poly\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}. \mbox{\Hypertarget{namespacehelib_abc2e5c3ec63886e4fbb71a7ed16f4a9b}\label{namespacehelib_abc2e5c3ec63886e4fbb71a7ed16f4a9b}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [2/13]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
std\+::istream \& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{ptxt }\end{DoxyParamCaption})}



Input shift operator. Uses the {\ttfamily deserialize} function internally. 


\begin{DoxyParams}{Parameters}
{\em is} & Input {\ttfamily std\+::istream}. \\
\hline
{\em ptxt} & Destination {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Input {\ttfamily std\+::istream} post reading. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
{\ttfamily ptxt} must be constructed with an appropriate context {\bfseries{B\+E\+F\+O\+RE}} calling this function. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{Ptxt my\_ptxt(context);}
\DoxyCodeLine{std::cin >> my\_ptxt;}
\end{DoxyCode}

\end{DoxyNote}
The input stream has to be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each element of the list will be deserialized as a slot of the type determined by the scheme.~\newline
If the number of tokens in the list is less than the number of slots, the remaining slots will be padded by 0.~\newline
For example \textquotesingle{}\mbox{[}\textquotesingle{}slot0\textquotesingle{}, \textquotesingle{}slot1\textquotesingle{}, \textquotesingle{}slot2\textquotesingle{}\mbox{]}\textquotesingle{} will be deserialized as a plaintext {\ttfamily ptxt} where {\ttfamily ptxt\mbox{[}0\mbox{]}=slot0}, {\ttfamily ptxt\mbox{[}1\mbox{]}=slot1}, {\ttfamily ptxt\mbox{[}2\mbox{]}=slot2} and {\ttfamily ptxt\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}. \mbox{\Hypertarget{namespacehelib_a84b37f68c4bdc42558ad0360b00984fb}\label{namespacehelib_a84b37f68c4bdc42558ad0360b00984fb}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [3/13]}}
{\footnotesize\ttfamily std\+::istream \& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{s,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt_part}{Ctxt\+Part}} \&}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2d6655763e3378a03fc07dca9178ec44}\label{namespacehelib_a2d6655763e3378a03fc07dca9178ec44}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [4/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{s,  }\item[{\mbox{\hyperlink{classhelib_1_1_moduli_sizes}{Moduli\+Sizes}} \&}]{szs }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa6bfd95691bb88ca7ee135b5ad074f4d}\label{namespacehelib_aa6bfd95691bb88ca7ee135b5ad074f4d}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [5/13]}}
{\footnotesize\ttfamily std\+::istream \& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{s,  }\item[{\mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2b06418a6494e921dec0c5d086cf46ce}\label{namespacehelib_a2b06418a6494e921dec0c5d086cf46ce}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [6/13]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{s,  }\item[{std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2051c31f2618de7d4cd905020cba5ad4}\label{namespacehelib_a2051c31f2618de7d4cd905020cba5ad4}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [7/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ade316a04cccc9355774eff8e6c013278}\label{namespacehelib_ade316a04cccc9355774eff8e6c013278}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [8/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab5ebb5536c5ee682d8490d2eac03f6ef}\label{namespacehelib_ab5ebb5536c5ee682d8490d2eac03f6ef}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [9/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a83df2fff1dfafef1f94191d2eb7d17e4}\label{namespacehelib_a83df2fff1dfafef1f94191d2eb7d17e4}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [10/13]}}
{\footnotesize\ttfamily std\+::istream \& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{set }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a97c53db90234d3f191cf4887f2bb8c2c}\label{namespacehelib_a97c53db90234d3f191cf4887f2bb8c2c}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [11/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&}]{pk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a658c0331d08e78e757984e06107f75f0}\label{namespacehelib_a658c0331d08e78e757984e06107f75f0}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [12/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae22055624d2a4b9a21d1ff101f7eac03}\label{namespacehelib_ae22055624d2a4b9a21d1ff101f7eac03}} 
\index{helib@{helib}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [13/13]}}
{\footnotesize\ttfamily std\+::istream\& helib\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_s_k_handle}{S\+K\+Handle}} \&}]{handle }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a12538d07e5bfd87d5705821d3a6fd72d}\label{namespacehelib_a12538d07e5bfd87d5705821d3a6fd72d}} 
\index{helib@{helib}!operator$>$$>$$<$BGV $>$@{operator$>$$>$$<$BGV $>$}}
\index{operator$>$$>$$<$BGV $>$@{operator$>$$>$$<$BGV $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$$<$BGV $>$()}{operator>><BGV >()}}
{\footnotesize\ttfamily template std\+::istream\& helib\+::operator$>$$>$$<$\mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a26590bae1e4d74412c28dd3abbb24b72}\label{namespacehelib_a26590bae1e4d74412c28dd3abbb24b72}} 
\index{helib@{helib}!operator$>$$>$$<$CKKS $>$@{operator$>$$>$$<$CKKS $>$}}
\index{operator$>$$>$$<$CKKS $>$@{operator$>$$>$$<$CKKS $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$>$$>$$<$CKKS $>$()}{operator>><CKKS >()}}
{\footnotesize\ttfamily template std\+::istream\& helib\+::operator$>$$>$$<$\mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{is,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af6f7e4e0b2339b3ac2e3b7a761357d0c}\label{namespacehelib_af6f7e4e0b2339b3ac2e3b7a761357d0c}} 
\index{helib@{helib}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator$^\wedge$()}{operator^()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} helib\+::operator$^\wedge$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{t }\end{DoxyParamCaption})}



exclusive-\/or 

\mbox{\Hypertarget{namespacehelib_a8172413911da7a2c6f38d9eb34899140}\label{namespacehelib_a8172413911da7a2c6f38d9eb34899140}} 
\index{helib@{helib}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator\texttt{"|}()}{operator|()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} helib\+::operator$\vert$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_index_set}{Index\+Set}} \&}]{t }\end{DoxyParamCaption})}



union 

\mbox{\Hypertarget{namespacehelib_a52eacb5c692c3fbf563e88a7ee693fcf}\label{namespacehelib_a52eacb5c692c3fbf563e88a7ee693fcf}} 
\index{helib@{helib}!operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}}
\index{operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{operator\texttt{"|}\texttt{"|}()}{operator||()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{classhelib_1_1_or}{Or}}$>$ helib\+::operator$\vert$$\vert$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_a72bfe799ca2748e0f67e80e799bbcebb}{Query\+Expr}} \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Overloaded operator for creating a shared pointer to an OR expression. 


\begin{DoxyParams}{Parameters}
{\em lhs} & Left operand of the OR expression. \\
\hline
{\em rhs} & Right operand of the OR expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the class {\ttfamily \mbox{\hyperlink{classhelib_1_1_or}{Or}}}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_ab80751b68918a0cba13cb9bab3da12ed}\label{namespacehelib_ab80751b68918a0cba13cb9bab3da12ed}} 
\index{helib@{helib}!optimalBenes@{optimalBenes}}
\index{optimalBenes@{optimalBenes}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{optimalBenes()}{optimalBenes()}}
{\footnotesize\ttfamily void helib\+::optimal\+Benes (\begin{DoxyParamCaption}\item[{long}]{n,  }\item[{long}]{budget,  }\item[{bool}]{good,  }\item[{long \&}]{cost,  }\item[{Long\+Node\+Ptr \&}]{solution }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a188c595f95739f28a8eaffd5fcc55ffd}\label{namespacehelib_a188c595f95739f28a8eaffd5fcc55ffd}} 
\index{helib@{helib}!optimalBenesAux@{optimalBenesAux}}
\index{optimalBenesAux@{optimalBenesAux}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{optimalBenesAux()}{optimalBenesAux()}}
{\footnotesize\ttfamily Benes\+Memo\+Entry helib\+::optimal\+Benes\+Aux (\begin{DoxyParamCaption}\item[{long}]{i,  }\item[{long}]{budget,  }\item[{long}]{nlev,  }\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+Vec$<$ long $>$$>$ \&}]{cost\+Tab,  }\item[{Benes\+Memo\+Table \&}]{memo\+Tab }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a05a4b7e9cb04f6760740db3d4dc3186d}\label{namespacehelib_a05a4b7e9cb04f6760740db3d4dc3186d}} 
\index{helib@{helib}!optimalLower@{optimalLower}}
\index{optimalLower@{optimalLower}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{optimalLower()}{optimalLower()}}
{\footnotesize\ttfamily Lower\+Memo\+Entry helib\+::optimal\+Lower (\begin{DoxyParamCaption}\item[{long}]{order,  }\item[{bool}]{good,  }\item[{long}]{budget,  }\item[{long}]{mid,  }\item[{Lower\+Memo\+Table \&}]{lower\+Memo\+Table }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6b9b2fbc501abb90f6400679ee15f9aa}\label{namespacehelib_a6b9b2fbc501abb90f6400679ee15f9aa}} 
\index{helib@{helib}!optimalUpperAux@{optimalUpperAux}}
\index{optimalUpperAux@{optimalUpperAux}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{optimalUpperAux()}{optimalUpperAux()}}
{\footnotesize\ttfamily Upper\+Memo\+Entry helib\+::optimal\+Upper\+Aux (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ \mbox{\hyperlink{classhelib_1_1_gen_descriptor}{Gen\+Descriptor}} $>$ \&}]{vec,  }\item[{long}]{i,  }\item[{long}]{budget,  }\item[{long}]{mid,  }\item[{Upper\+Memo\+Table \&}]{upper\+Memo\+Table,  }\item[{Lower\+Memo\+Table \&}]{lower\+Memo\+Table }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a8693a4a2d91babebc9b8887bbcd1f0ea}\label{namespacehelib_a8693a4a2d91babebc9b8887bbcd1f0ea}} 
\index{helib@{helib}!ord@{ord}}
\index{ord@{ord}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ord()}{ord()}}
{\footnotesize\ttfamily long helib\+::ord (\begin{DoxyParamCaption}\item[{long}]{N,  }\item[{long}]{p }\end{DoxyParamCaption})}



Compute the highest power of p that divides N. 

\mbox{\Hypertarget{namespacehelib_a72ce2f6953045411b111ff7ee6f9c2d1}\label{namespacehelib_a72ce2f6953045411b111ff7ee6f9c2d1}} 
\index{helib@{helib}!packConstant@{packConstant}}
\index{packConstant@{packConstant}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{packConstant()}{packConstant()}}
{\footnotesize\ttfamily void helib\+::pack\+Constant (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{result,  }\item[{unsigned long}]{data,  }\item[{long}]{nbits,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae46ff7d24d107f5d26d907d52aea5264}\label{namespacehelib_ae46ff7d24d107f5d26d907d52aea5264}} 
\index{helib@{helib}!packConstants@{packConstants}}
\index{packConstants@{packConstants}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{packConstants()}{packConstants()}}
{\footnotesize\ttfamily void helib\+::pack\+Constants (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{result,  }\item[{const std\+::vector$<$ std\+::size\+\_\+t $>$ \&}]{data,  }\item[{long}]{nbits,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7653c8cc828041d87ed9805c35bf0b6f}\label{namespacehelib_a7653c8cc828041d87ed9805c35bf0b6f}} 
\index{helib@{helib}!packedRecrypt@{packedRecrypt}}
\index{packedRecrypt@{packedRecrypt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{packedRecrypt()}{packedRecrypt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void helib\+::packed\+Recrypt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_ac54132076174cf5388da4f1121f4d417}{Ct\+Ptr\+Mat}} \&}]{m,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{unpack\+Consts,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{long}]{below\+Lvl = {\ttfamily LONG\+\_\+MAX} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aea4d00f74735017eb674bc25cca0d47d}\label{namespacehelib_aea4d00f74735017eb674bc25cca0d47d}} 
\index{helib@{helib}!packedRecrypt@{packedRecrypt}}
\index{packedRecrypt@{packedRecrypt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{packedRecrypt()}{packedRecrypt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void helib\+::packed\+Recrypt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{a,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{b,  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding }\end{DoxyParamCaption})}



Function for packed recryption to recrypt multiple numbers. 


\begin{DoxyParams}{Parameters}
{\em a} & first input of which to recrypt. \\
\hline
{\em b} & second input of which to recrypt. \\
\hline
{\em unpack\+Slot\+Encoding} & vector of constants for unpacking, as used in bootstrapping. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a2903cc43702e2dccc9006f6af1da249f}\label{namespacehelib_a2903cc43702e2dccc9006f6af1da249f}} 
\index{helib@{helib}!packedRecrypt@{packedRecrypt}}
\index{packedRecrypt@{packedRecrypt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{packedRecrypt()}{packedRecrypt()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void helib\+::packed\+Recrypt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{array,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{unpack\+Consts,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{long}]{below\+Lvl }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6abd6bae5306a86a4f95fb62fad44c14}\label{namespacehelib_a6abd6bae5306a86a4f95fb62fad44c14}} 
\index{helib@{helib}!packedRecrypt@{packedRecrypt}}
\index{packedRecrypt@{packedRecrypt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{packedRecrypt()}{packedRecrypt()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void helib\+::packed\+Recrypt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{c\+Ptrs,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{unpack\+Consts,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa4c4516b395810588dc11afabdd11b62}\label{namespacehelib_aa4c4516b395810588dc11afabdd11b62}} 
\index{helib@{helib}!PAlgebraLift@{PAlgebraLift}}
\index{PAlgebraLift@{PAlgebraLift}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PAlgebraLift()}{PAlgebraLift()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$$>$ \\
void helib\+::\+P\+Algebra\+Lift (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{phimx,  }\item[{const N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&}]{lfactors,  }\item[{N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&}]{factors,  }\item[{N\+T\+L\+::vec\+\_\+zz\+\_\+pX \&}]{crtc,  }\item[{long}]{r }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac531d997cd86bd46ac62c3f7cd5665de}\label{namespacehelib_ac531d997cd86bd46ac62c3f7cd5665de}} 
\index{helib@{helib}!PAlgebraLift@{PAlgebraLift}}
\index{PAlgebraLift@{PAlgebraLift}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PAlgebraLift()}{PAlgebraLift()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::\+P\+Algebra\+Lift (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{phimx,  }\item[{const T \&}]{lfactors,  }\item[{T \&}]{factors,  }\item[{T \&}]{crtc,  }\item[{long}]{r }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a527dbcddde6c00dcf8ba8117b9290043}\label{namespacehelib_a527dbcddde6c00dcf8ba8117b9290043}} 
\index{helib@{helib}!partialMatchEncode@{partialMatchEncode}}
\index{partialMatchEncode@{partialMatchEncode}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{partialMatchEncode()}{partialMatchEncode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} helib\+::partial\+Match\+Encode (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{input,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given a value, encode the value across the coefficients of a polynomial. 


\begin{DoxyParams}{Parameters}
{\em input} & The value of which to encode. \\
\hline
{\em context} & The context object holding information on how to encode the value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A polynomial representing the encoded value. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_a93e575c4502d7606d86b46af66600ce0}\label{namespacehelib_a93e575c4502d7606d86b46af66600ce0}} 
\index{helib@{helib}!phi\_N@{phi\_N}}
\index{phi\_N@{phi\_N}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{phi\_N()}{phi\_N()}}
{\footnotesize\ttfamily long helib\+::phi\+\_\+N (\begin{DoxyParamCaption}\item[{long}]{N }\end{DoxyParamCaption})}



Compute Phi(\+N). 

\mbox{\Hypertarget{namespacehelib_add32ec15c61473a42b7136dee8360b8b}\label{namespacehelib_add32ec15c61473a42b7136dee8360b8b}} 
\index{helib@{helib}!phiN@{phiN}}
\index{phiN@{phiN}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{phiN()}{phiN()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::phiN (\begin{DoxyParamCaption}\item[{long \&}]{phiN,  }\item[{std\+::vector$<$ long $>$ \&}]{facts,  }\item[{long}]{N }\end{DoxyParamCaption})}



Compute Phi(\+N) and also factorize N. 

\mbox{\Hypertarget{namespacehelib_a62dc0ba06446370515708c0229fa046e}\label{namespacehelib_a62dc0ba06446370515708c0229fa046e}} 
\index{helib@{helib}!phiN@{phiN}}
\index{phiN@{phiN}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{phiN()}{phiN()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::phiN (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+ZZ \&}]{phiN,  }\item[{std\+::vector$<$ N\+T\+L\+::\+ZZ $>$ \&}]{facts,  }\item[{const N\+T\+L\+::\+ZZ \&}]{N }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9f36286a4ff72a05ddf16c2e5bfaeba5}\label{namespacehelib_a9f36286a4ff72a05ddf16c2e5bfaeba5}} 
\index{helib@{helib}!plaintextAutomorph@{plaintextAutomorph}}
\index{plaintextAutomorph@{plaintextAutomorph}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{plaintextAutomorph()}{plaintextAutomorph()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename RX , typename type $>$ \\
void helib\+::plaintext\+Automorph (\begin{DoxyParamCaption}\item[{RX \&}]{b,  }\item[{const RX \&}]{a,  }\item[{long}]{i,  }\item[{long}]{j,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array_derived}{Encrypted\+Array\+Derived}}$<$ type $>$ \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aefd5d1a56f7036cae390706fe49e8fcb}\label{namespacehelib_aefd5d1a56f7036cae390706fe49e8fcb}} 
\index{helib@{helib}!plaintextAutomorph@{plaintextAutomorph}}
\index{plaintextAutomorph@{plaintextAutomorph}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{plaintextAutomorph()}{plaintextAutomorph()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename RX , typename R\+X\+Modulus $>$ \\
void helib\+::plaintext\+Automorph (\begin{DoxyParamCaption}\item[{RX \&}]{bb,  }\item[{const RX \&}]{a,  }\item[{long}]{k,  }\item[{long}]{m,  }\item[{const R\+X\+Modulus \&}]{PhimX }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac405b201e920430c5995a7408e08e99d}\label{namespacehelib_ac405b201e920430c5995a7408e08e99d}} 
\index{helib@{helib}!plaintextAutomorph\_CKKS@{plaintextAutomorph\_CKKS}}
\index{plaintextAutomorph\_CKKS@{plaintextAutomorph\_CKKS}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{plaintextAutomorph\_CKKS()}{plaintextAutomorph\_CKKS()}}
{\footnotesize\ttfamily void helib\+::plaintext\+Automorph\+\_\+\+C\+K\+KS (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{b,  }\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{a,  }\item[{long}]{j,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array_cx}{Encrypted\+Array\+Cx}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab77a93b123ead6eef9e6c899afab897c}\label{namespacehelib_ab77a93b123ead6eef9e6c899afab897c}} 
\index{helib@{helib}!poly\_comp@{poly\_comp}}
\index{poly\_comp@{poly\_comp}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{poly\_comp()}{poly\_comp()}}
{\footnotesize\ttfamily template$<$typename RX $>$ \\
bool helib\+::poly\+\_\+comp (\begin{DoxyParamCaption}\item[{const RX \&}]{a,  }\item[{const RX \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad15c89ffe2770b53c9484aa56555bc3f}\label{namespacehelib_ad15c89ffe2770b53c9484aa56555bc3f}} 
\index{helib@{helib}!polyEval@{polyEval}}
\index{polyEval@{polyEval}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{polyEval()}{polyEval()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::poly\+Eval (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ret,  }\item[{const N\+T\+L\+::\+Vec$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{x }\end{DoxyParamCaption})}



Evaluate an encrypted polynomial on an encrypted input. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em res} & to hold the return value \\
\hline
\mbox{\texttt{ in}}  & {\em poly} & the degree-\/d polynomial to evaluate \\
\hline
\mbox{\texttt{ in}}  & {\em x} & the point on which to evaluate \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a342c01cce2724537976f9ce808e6b8ec}\label{namespacehelib_a342c01cce2724537976f9ce808e6b8ec}} 
\index{helib@{helib}!polyEval@{polyEval}}
\index{polyEval@{polyEval}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{polyEval()}{polyEval()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::poly\+Eval (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ret,  }\item[{N\+T\+L\+::\+Z\+ZX}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{x,  }\item[{long}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}



Evaluate a cleartext polynomial on an encrypted input. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em res} & to hold the return value \\
\hline
\mbox{\texttt{ in}}  & {\em poly} & the degree-\/d polynomial to evaluate \\
\hline
\mbox{\texttt{ in}}  & {\em x} & the point on which to evaluate \\
\hline
\mbox{\texttt{ in}}  & {\em k} & optional optimization parameter, defaults to sqrt(d/2) rounded up or down to a power of two \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a11db92e970f97ed66aebb1702dc5a0df}\label{namespacehelib_a11db92e970f97ed66aebb1702dc5a0df}} 
\index{helib@{helib}!polyEvalMod@{polyEvalMod}}
\index{polyEvalMod@{polyEvalMod}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{polyEvalMod()}{polyEvalMod()}}
{\footnotesize\ttfamily long helib\+::poly\+Eval\+Mod (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{long}]{x,  }\item[{long}]{p }\end{DoxyParamCaption})}



Evaluates a modular integer polynomial, returns poly(x) mod p. 

\mbox{\Hypertarget{namespacehelib_a7ada257cf26f3f2074300fddf5381f11}\label{namespacehelib_a7ada257cf26f3f2074300fddf5381f11}} 
\index{helib@{helib}!PolyRed@{PolyRed}}
\index{PolyRed@{PolyRed}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PolyRed()}{PolyRed()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void helib\+::\+Poly\+Red (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{F,  }\item[{const N\+T\+L\+::\+ZZ \&}]{q,  }\item[{bool}]{abs = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_aec8847d93fff429651833026b9553e1b}\label{namespacehelib_aec8847d93fff429651833026b9553e1b}} 
\index{helib@{helib}!PolyRed@{PolyRed}}
\index{PolyRed@{PolyRed}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PolyRed()}{PolyRed()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void helib\+::\+Poly\+Red (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{F,  }\item[{long}]{q,  }\item[{bool}]{abs = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_acd2078641e9787af3d6acbee6d557dad}\label{namespacehelib_acd2078641e9787af3d6acbee6d557dad}} 
\index{helib@{helib}!PolyRed@{PolyRed}}
\index{PolyRed@{PolyRed}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PolyRed()}{PolyRed()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void helib\+::\+Poly\+Red (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{out,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{in,  }\item[{const N\+T\+L\+::\+ZZ \&}]{q,  }\item[{bool}]{abs = {\ttfamily false} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae977d2527a20cd02ae18841eea99aa2e}\label{namespacehelib_ae977d2527a20cd02ae18841eea99aa2e}} 
\index{helib@{helib}!PolyRed@{PolyRed}}
\index{PolyRed@{PolyRed}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PolyRed()}{PolyRed()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void helib\+::\+Poly\+Red (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{out,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{in,  }\item[{long}]{q,  }\item[{bool}]{abs = {\ttfamily false} }\end{DoxyParamCaption})}



Reduce all the coefficients of a polynomial modulo q. 

When abs=false reduce to interval (-\/q/2,...,q/2), when abs=true reduce to \mbox{[}0,q). When abs=false and q=2, maintains the same sign as the input. \mbox{\Hypertarget{namespacehelib_a83b1a8080de040baddd971b44488ca51}\label{namespacehelib_a83b1a8080de040baddd971b44488ca51}} 
\index{helib@{helib}!power@{power}}
\index{power@{power}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{power()}{power()}}
{\footnotesize\ttfamily void helib\+::power (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{long}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a407ad6533d4dd3820cc35b07ad41988b}\label{namespacehelib_a407ad6533d4dd3820cc35b07ad41988b}} 
\index{helib@{helib}!pp\_factorize@{pp\_factorize}}
\index{pp\_factorize@{pp\_factorize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{pp\_factorize()}{pp\_factorize()}}
{\footnotesize\ttfamily void helib\+::pp\+\_\+factorize (\begin{DoxyParamCaption}\item[{std\+::vector$<$ long $>$ \&}]{factors,  }\item[{long}]{N }\end{DoxyParamCaption})}



Prime-\/power factorization. 

\mbox{\Hypertarget{namespacehelib_af35b575565f163995c6abd08972bddf2}\label{namespacehelib_af35b575565f163995c6abd08972bddf2}} 
\index{helib@{helib}!ppInvert@{ppInvert}}
\index{ppInvert@{ppInvert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ppInvert()}{ppInvert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void helib\+::pp\+Invert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::mat\+\_\+\+G\+F2 \&}]{X,  }\item[{const N\+T\+L\+::mat\+\_\+\+G\+F2 \&}]{A,  }\item[{U\+N\+U\+S\+ED long}]{p,  }\item[{U\+N\+U\+S\+ED long}]{r }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ac46606ccee8c1fe481e3b5a1f90291c5}\label{namespacehelib_ac46606ccee8c1fe481e3b5a1f90291c5}} 
\index{helib@{helib}!ppInvert@{ppInvert}}
\index{ppInvert@{ppInvert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ppInvert()}{ppInvert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void helib\+::pp\+Invert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::mat\+\_\+\+G\+F2E \&}]{X,  }\item[{const N\+T\+L\+::mat\+\_\+\+G\+F2E \&}]{A,  }\item[{U\+N\+U\+S\+ED long}]{p,  }\item[{U\+N\+U\+S\+ED long}]{r }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a784e87216f278000cfa935b61657da58}\label{namespacehelib_a784e87216f278000cfa935b61657da58}} 
\index{helib@{helib}!ppInvert@{ppInvert}}
\index{ppInvert@{ppInvert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ppInvert()}{ppInvert()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void helib\+::pp\+Invert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::mat\+\_\+zz\+\_\+p \&}]{X,  }\item[{const N\+T\+L\+::mat\+\_\+zz\+\_\+p \&}]{A,  }\item[{long}]{p,  }\item[{long}]{r }\end{DoxyParamCaption})}



Compute the inverse mod p$^\wedge$r of an n x n matrix. 

N\+TL\textquotesingle{}s current smallint modulus zz\+\_\+p\+::modulus() is assumed to be p$^\wedge$r for p prime, r $>$= 1 integer. For the zz\+\_\+pE variant also zz\+\_\+p\+E\+::modulus() must be initialized. An error is raised if A is not invertible mod p. \mbox{\Hypertarget{namespacehelib_a73a34ea89aec17e40d20d534e210a14f}\label{namespacehelib_a73a34ea89aec17e40d20d534e210a14f}} 
\index{helib@{helib}!ppInvert@{ppInvert}}
\index{ppInvert@{ppInvert}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ppInvert()}{ppInvert()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void helib\+::pp\+Invert (\begin{DoxyParamCaption}\item[{N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&}]{X,  }\item[{const N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&}]{A,  }\item[{long}]{p,  }\item[{long}]{r }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0faaee69d7f687471cb483dfa78e6701}\label{namespacehelib_a0faaee69d7f687471cb483dfa78e6701}} 
\index{helib@{helib}!ppsolve@{ppsolve}}
\index{ppsolve@{ppsolve}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ppsolve()}{ppsolve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::ppsolve (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+\+G\+F2E \&}]{x,  }\item[{const N\+T\+L\+::mat\+\_\+\+G\+F2E \&}]{A,  }\item[{const N\+T\+L\+::vec\+\_\+\+G\+F2E \&}]{b,  }\item[{long}]{p,  }\item[{long}]{r }\end{DoxyParamCaption})}



A version for G\+F2\+: must have p == 2 and r == 1. 

\mbox{\Hypertarget{namespacehelib_acdb8f2124f5f56970fe7f88802c976b1}\label{namespacehelib_acdb8f2124f5f56970fe7f88802c976b1}} 
\index{helib@{helib}!ppsolve@{ppsolve}}
\index{ppsolve@{ppsolve}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ppsolve()}{ppsolve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::ppsolve (\begin{DoxyParamCaption}\item[{N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&}]{x,  }\item[{const N\+T\+L\+::mat\+\_\+zz\+\_\+pE \&}]{A,  }\item[{const N\+T\+L\+::vec\+\_\+zz\+\_\+pE \&}]{b,  }\item[{long}]{p,  }\item[{long}]{r }\end{DoxyParamCaption})}



Prime power solver. 

A is an n x n matrix, b is a length n (row) vector, this function finds a solution for the matrix-\/vector equation x A = b. An error is raised if A is not invertible mod p.

N\+TL\textquotesingle{}s current smallint modulus, zz\+\_\+p\+::modulus(), is assumed to be p$^\wedge$r, for p prime, r $>$= 1 integer. \mbox{\Hypertarget{namespacehelib_a9b5c3e6a25c84bcec39b646e10598378}\label{namespacehelib_a9b5c3e6a25c84bcec39b646e10598378}} 
\index{helib@{helib}!primroot@{primroot}}
\index{primroot@{primroot}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{primroot()}{primroot()}}
{\footnotesize\ttfamily long helib\+::primroot (\begin{DoxyParamCaption}\item[{long}]{N,  }\item[{long}]{phiN }\end{DoxyParamCaption})}



Find a primitive root modulo N. 

\mbox{\Hypertarget{namespacehelib_a8bdc2438d837bb24ddb0dc0ba0a859cc}\label{namespacehelib_a8bdc2438d837bb24ddb0dc0ba0a859cc}} 
\index{helib@{helib}!print@{print}}
\index{print@{print}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{print()}{print()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::print (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7b924cfad7a9d34755b6175d88a6a207}\label{namespacehelib_a7b924cfad7a9d34755b6175d88a6a207}} 
\index{helib@{helib}!print@{print}}
\index{print@{print}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{print()}{print()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::print (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{Split\+Node\+Ptr}]{p,  }\item[{bool}]{first }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a90f4cdaad8d1b3eba56f013ad96e0d49}\label{namespacehelib_a90f4cdaad8d1b3eba56f013ad96e0d49}} 
\index{helib@{helib}!print3D@{print3D}}
\index{print3D@{print3D}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{print3D()}{print3D()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template void helib\+::print3D (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ long $>$ \&}]{c }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a518fab30f484391dbbc23fa0ddfdc2bf}\label{namespacehelib_a518fab30f484391dbbc23fa0ddfdc2bf}} 
\index{helib@{helib}!print3D@{print3D}}
\index{print3D@{print3D}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{print3D()}{print3D()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template void helib\+::print3D (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{c }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5d24bda05c48a744ffffd08de68736ed}\label{namespacehelib_a5d24bda05c48a744ffffd08de68736ed}} 
\index{helib@{helib}!print3D@{print3D}}
\index{print3D@{print3D}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{print3D()}{print3D()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::print3D (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_hyper_cube}{Hyper\+Cube}}$<$ T $>$ \&}]{c }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a14bd686a2e209597f3acecd89f1a3520}\label{namespacehelib_a14bd686a2e209597f3acecd89f1a3520}} 
\index{helib@{helib}!print\_stats@{print\_stats}}
\index{print\_stats@{print\_stats}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{print\_stats()}{print\_stats()}}
{\footnotesize\ttfamily void helib\+::print\+\_\+stats (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2a544a973c30afed0df368cda6e0ad9e}\label{namespacehelib_a2a544a973c30afed0df368cda6e0ad9e}} 
\index{helib@{helib}!printAllTimers@{printAllTimers}}
\index{printAllTimers@{printAllTimers}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{printAllTimers()}{printAllTimers()}}
{\footnotesize\ttfamily void helib\+::print\+All\+Timers (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str = {\ttfamily std\+:\+:cerr} }\end{DoxyParamCaption})}



Print the value of all timers to stream. 

\mbox{\Hypertarget{namespacehelib_a8da295dc142953405e0a3e30509df973}\label{namespacehelib_a8da295dc142953405e0a3e30509df973}} 
\index{helib@{helib}!printFlow@{printFlow}}
\index{printFlow@{printFlow}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{printFlow()}{printFlow()}}
{\footnotesize\ttfamily void helib\+::print\+Flow (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_af547f7016fc73b7174a2018ea28ef298}{Flow\+Graph}} \&}]{fg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a4ffb94ff808c50cb557b7ab67d925453}\label{namespacehelib_a4ffb94ff808c50cb557b7ab67d925453}} 
\index{helib@{helib}!printMatrix@{printMatrix}}
\index{printMatrix@{printMatrix}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{printMatrix()}{printMatrix()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::print\+Matrix (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a9af476860763122a38ad2ae71ad5b9bc}{Matrix}}$<$ T $>$ \&}]{M,  }\item[{std\+::ostream \&}]{out = {\ttfamily std\+:\+:cout} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a0def7d8004a69413ec72c12f1b2bdfe2}\label{namespacehelib_a0def7d8004a69413ec72c12f1b2bdfe2}} 
\index{helib@{helib}!printNamedTimer@{printNamedTimer}}
\index{printNamedTimer@{printNamedTimer}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{printNamedTimer()}{printNamedTimer()}}
{\footnotesize\ttfamily bool helib\+::print\+Named\+Timer (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af7844ba559695a1952e4d6309d21b354}\label{namespacehelib_af7844ba559695a1952e4d6309d21b354}} 
\index{helib@{helib}!printVec@{printVec}}
\index{printVec@{printVec}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{printVec()}{printVec()}}
{\footnotesize\ttfamily template$<$typename V\+EC $>$ \\
std\+::ostream\& helib\+::print\+Vec (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const V\+EC \&}]{v,  }\item[{long}]{n\+Coeffs = {\ttfamily 40} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a742bf72a76d5b9389251abfee9223303}\label{namespacehelib_a742bf72a76d5b9389251abfee9223303}} 
\index{helib@{helib}!printZZX@{printZZX}}
\index{printZZX@{printZZX}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{printZZX()}{printZZX()}}
{\footnotesize\ttfamily std\+::ostream\& helib\+::print\+Z\+ZX (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{long}]{n\+Coeffs = {\ttfamily 40} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ab33a07f0cc97da66e279f71195515763}\label{namespacehelib_ab33a07f0cc97da66e279f71195515763}} 
\index{helib@{helib}!ptr2nonNull@{ptr2nonNull}}
\index{ptr2nonNull@{ptr2nonNull}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{ptr2nonNull()}{ptr2nonNull()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
const T$\ast$ helib\+::ptr2non\+Null (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ $\ast$ $>$}]{list }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a38c7c1b517a8ec41eacfc5c2dba6e293}\label{namespacehelib_a38c7c1b517a8ec41eacfc5c2dba6e293}} 
\index{helib@{helib}!random@{random}}
\index{random@{random}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{random()}{random()}}
{\footnotesize\ttfamily void helib\+::random (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa74c29f86e466570325f829fe4ea74b0}\label{namespacehelib_aa74c29f86e466570325f829fe4ea74b0}} 
\index{helib@{helib}!randomPerm@{randomPerm}}
\index{randomPerm@{randomPerm}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{randomPerm()}{randomPerm()}}
{\footnotesize\ttfamily void helib\+::random\+Perm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_ae0769a209e14d5e1bfd8579072397867}{Permut}} \&}]{perm,  }\item[{long}]{n }\end{DoxyParamCaption})}



A random size-\/n permutation. 

\mbox{\Hypertarget{namespacehelib_afcac17a647635226217c42d858bc155d}\label{namespacehelib_afcac17a647635226217c42d858bc155d}} 
\index{helib@{helib}!randomSlot@{randomSlot}}
\index{randomSlot@{randomSlot}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{randomSlot()}{randomSlot()}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
Scheme\+::\+Slot\+Type helib\+::random\+Slot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aebcaec251bd8b00a025d3868342fbe85}\label{namespacehelib_aebcaec251bd8b00a025d3868342fbe85}} 
\index{helib@{helib}!randomSlot$<$ BGV $>$@{randomSlot$<$ BGV $>$}}
\index{randomSlot$<$ BGV $>$@{randomSlot$<$ BGV $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{randomSlot$<$ BGV $>$()}{randomSlot< BGV >()}}
{\footnotesize\ttfamily template$<$$>$ \\
\mbox{\hyperlink{structhelib_1_1_b_g_v_a09c79ac9a958d2d2b93c34d89c3ca65b}{B\+G\+V\+::\+Slot\+Type}} \mbox{\hyperlink{namespacehelib_afcac17a647635226217c42d858bc155d}{helib\+::random\+Slot}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a48baf3cc1410cb87bf86a9065dee38a9}\label{namespacehelib_a48baf3cc1410cb87bf86a9065dee38a9}} 
\index{helib@{helib}!randomSlot$<$ CKKS $>$@{randomSlot$<$ CKKS $>$}}
\index{randomSlot$<$ CKKS $>$@{randomSlot$<$ CKKS $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{randomSlot$<$ CKKS $>$()}{randomSlot< CKKS >()}}
{\footnotesize\ttfamily template$<$$>$ \\
\mbox{\hyperlink{structhelib_1_1_c_k_k_s_a7c8b6e96117c89f9395b2f1ccdc1e0a0}{C\+K\+K\+S\+::\+Slot\+Type}} \mbox{\hyperlink{namespacehelib_afcac17a647635226217c42d858bc155d}{helib\+::random\+Slot}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ (\begin{DoxyParamCaption}\item[{U\+N\+U\+S\+ED const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad0bcd83ef1650a094f9ba12551a2e9e4}\label{namespacehelib_ad0bcd83ef1650a094f9ba12551a2e9e4}} 
\index{helib@{helib}!RandPoly@{RandPoly}}
\index{RandPoly@{RandPoly}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{RandPoly()}{RandPoly()}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::\+Rand\+Poly (\begin{DoxyParamCaption}\item[{long}]{n,  }\item[{const N\+T\+L\+::\+ZZ \&}]{p }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae4c6fd54cca700ce3a8beca19bf0ceaa}\label{namespacehelib_ae4c6fd54cca700ce3a8beca19bf0ceaa}} 
\index{helib@{helib}!range@{range}}
\index{range@{range}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{range()}{range()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1general__range}{general\+\_\+range}}$<$long$>$ helib\+::range (\begin{DoxyParamCaption}\item[{long}]{m,  }\item[{long}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a5dcff6470686ad80a2319fa1652ac1e3}\label{namespacehelib_a5dcff6470686ad80a2319fa1652ac1e3}} 
\index{helib@{helib}!range@{range}}
\index{range@{range}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{range()}{range()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1general__range}{general\+\_\+range}}$<$long$>$ helib\+::range (\begin{DoxyParamCaption}\item[{long}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a03f697f7ff3bbb3d9d17f75d35946991}\label{namespacehelib_a03f697f7ff3bbb3d9d17f75d35946991}} 
\index{helib@{helib}!rationalApprox@{rationalApprox}}
\index{rationalApprox@{rationalApprox}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{rationalApprox()}{rationalApprox()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::pair$<$ long, long $>$ helib\+::rational\+Approx (\begin{DoxyParamCaption}\item[{double}]{x,  }\item[{long}]{denom\+Bound = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a564d4348157a8775888f09a680313ba6}\label{namespacehelib_a564d4348157a8775888f09a680313ba6}} 
\index{helib@{helib}!rationalApprox@{rationalApprox}}
\index{rationalApprox@{rationalApprox}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{rationalApprox()}{rationalApprox()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::pair$<$ N\+T\+L\+::\+ZZ, N\+T\+L\+::\+ZZ $>$ helib\+::rational\+Approx (\begin{DoxyParamCaption}\item[{N\+T\+L\+::xdouble}]{x,  }\item[{N\+T\+L\+::xdouble}]{denom\+Bound = {\ttfamily NTL\+:\+:xdouble(0.0)} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a50b26a9740fbaba1c3b7b5c7e89ee55c}\label{namespacehelib_a50b26a9740fbaba1c3b7b5c7e89ee55c}} 
\index{helib@{helib}!rawDecrypt@{rawDecrypt}}
\index{rawDecrypt@{rawDecrypt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{rawDecrypt()}{rawDecrypt()}}
{\footnotesize\ttfamily void helib\+::raw\+Decrypt (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{plaintxt,  }\item[{const std\+::vector$<$ N\+T\+L\+::\+Z\+ZX $>$ \&}]{zz\+Parts,  }\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{s\+Key,  }\item[{long}]{q = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac5197bb5b6cad37f9d4a4a7c7e7bf8d0}\label{namespacehelib_ac5197bb5b6cad37f9d4a4a7c7e7bf8d0}} 
\index{helib@{helib}!read@{read}}
\index{read@{read}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read()}{read()}}
{\footnotesize\ttfamily void helib\+::read (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{s,  }\item[{\mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af5ff4e18ef29f688fc071601becaafef}\label{namespacehelib_af5ff4e18ef29f688fc071601becaafef}} 
\index{helib@{helib}!read\_ntl\_vec\_long@{read\_ntl\_vec\_long}}
\index{read\_ntl\_vec\_long@{read\_ntl\_vec\_long}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_ntl\_vec\_long()}{read\_ntl\_vec\_long()}}
{\footnotesize\ttfamily void helib\+::read\+\_\+ntl\+\_\+vec\+\_\+long (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{N\+T\+L\+::vec\+\_\+long \&}]{vl }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa1c396577dc7ac07293effb9e8e20364}\label{namespacehelib_aa1c396577dc7ac07293effb9e8e20364}} 
\index{helib@{helib}!read\_raw\_double@{read\_raw\_double}}
\index{read\_raw\_double@{read\_raw\_double}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_double()}{read\_raw\_double()}}
{\footnotesize\ttfamily double helib\+::read\+\_\+raw\+\_\+double (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab66308212a98df1821b9bf48c5713bd2}\label{namespacehelib_ab66308212a98df1821b9bf48c5713bd2}} 
\index{helib@{helib}!read\_raw\_int@{read\_raw\_int}}
\index{read\_raw\_int@{read\_raw\_int}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_int()}{read\_raw\_int()}}
{\footnotesize\ttfamily long helib\+::read\+\_\+raw\+\_\+int (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a529e6135abd723e5eeb63a156224e39a}\label{namespacehelib_a529e6135abd723e5eeb63a156224e39a}} 
\index{helib@{helib}!read\_raw\_int32@{read\_raw\_int32}}
\index{read\_raw\_int32@{read\_raw\_int32}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_int32()}{read\_raw\_int32()}}
{\footnotesize\ttfamily int helib\+::read\+\_\+raw\+\_\+int32 (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aaa0e61f1c81f568bd942e3f50b4c5301}\label{namespacehelib_aaa0e61f1c81f568bd942e3f50b4c5301}} 
\index{helib@{helib}!read\_raw\_vector@{read\_raw\_vector}}
\index{read\_raw\_vector@{read\_raw\_vector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_vector()}{read\_raw\_vector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::read\+\_\+raw\+\_\+vector (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a03a42dc495a369c587d7bfe577a1fc29}\label{namespacehelib_a03a42dc495a369c587d7bfe577a1fc29}} 
\index{helib@{helib}!read\_raw\_vector@{read\_raw\_vector}}
\index{read\_raw\_vector@{read\_raw\_vector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_vector()}{read\_raw\_vector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::read\+\_\+raw\+\_\+vector (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{std\+::vector$<$ T $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9e907022dc0cd7bdf40f457b786ab924}\label{namespacehelib_a9e907022dc0cd7bdf40f457b786ab924}} 
\index{helib@{helib}!read\_raw\_vector@{read\_raw\_vector}}
\index{read\_raw\_vector@{read\_raw\_vector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_vector()}{read\_raw\_vector()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::read\+\_\+raw\+\_\+vector (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{std\+::vector$<$ T $>$ \&}]{v,  }\item[{T \&}]{init }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a591c5643829af4b3738d1e6cc807518e}\label{namespacehelib_a591c5643829af4b3738d1e6cc807518e}} 
\index{helib@{helib}!read\_raw\_vector$<$ double $>$@{read\_raw\_vector$<$ double $>$}}
\index{read\_raw\_vector$<$ double $>$@{read\_raw\_vector$<$ double $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_vector$<$ double $>$()}{read\_raw\_vector< double >()}}
{\footnotesize\ttfamily template$<$$>$ \\
void \mbox{\hyperlink{namespacehelib_a9e907022dc0cd7bdf40f457b786ab924}{helib\+::read\+\_\+raw\+\_\+vector}}$<$ double $>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{std\+::vector$<$ double $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6f201a18aa3be048c7935a97c1bd4e82}\label{namespacehelib_a6f201a18aa3be048c7935a97c1bd4e82}} 
\index{helib@{helib}!read\_raw\_vector$<$ long $>$@{read\_raw\_vector$<$ long $>$}}
\index{read\_raw\_vector$<$ long $>$@{read\_raw\_vector$<$ long $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_vector$<$ long $>$()}{read\_raw\_vector< long >()}}
{\footnotesize\ttfamily template$<$$>$ \\
void \mbox{\hyperlink{namespacehelib_a9e907022dc0cd7bdf40f457b786ab924}{helib\+::read\+\_\+raw\+\_\+vector}}$<$ long $>$ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{std\+::vector$<$ long $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aad981561d84bb94d22a6c5c3e1619806}\label{namespacehelib_aad981561d84bb94d22a6c5c3e1619806}} 
\index{helib@{helib}!read\_raw\_xdouble@{read\_raw\_xdouble}}
\index{read\_raw\_xdouble@{read\_raw\_xdouble}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_xdouble()}{read\_raw\_xdouble()}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::read\+\_\+raw\+\_\+xdouble (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adfd83ed995cf19419ab46fa84b2711a7}\label{namespacehelib_adfd83ed995cf19419ab46fa84b2711a7}} 
\index{helib@{helib}!read\_raw\_ZZ@{read\_raw\_ZZ}}
\index{read\_raw\_ZZ@{read\_raw\_ZZ}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{read\_raw\_ZZ()}{read\_raw\_ZZ()}}
{\footnotesize\ttfamily void helib\+::read\+\_\+raw\+\_\+\+ZZ (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{N\+T\+L\+::\+ZZ \&}]{zz }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab7b88eb3fd0aa4821cb6700fa65ecee2}\label{namespacehelib_ab7b88eb3fd0aa4821cb6700fa65ecee2}} 
\index{helib@{helib}!readContextBase@{readContextBase}}
\index{readContextBase@{readContextBase}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{readContextBase()}{readContextBase()}}
{\footnotesize\ttfamily void helib\+::read\+Context\+Base (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{s,  }\item[{unsigned long \&}]{m,  }\item[{unsigned long \&}]{p,  }\item[{unsigned long \&}]{r,  }\item[{std\+::vector$<$ long $>$ \&}]{gens,  }\item[{std\+::vector$<$ long $>$ \&}]{ords }\end{DoxyParamCaption})}



read \mbox{[}m p r gens ords\mbox{]} data, needed to construct context 

read \mbox{[}m p r\mbox{]} data, needed to construct context \mbox{\Hypertarget{namespacehelib_acb88b203e4e9aeaf5fe329e7cc276aad}\label{namespacehelib_acb88b203e4e9aeaf5fe329e7cc276aad}} 
\index{helib@{helib}!readContextBaseBinary@{readContextBaseBinary}}
\index{readContextBaseBinary@{readContextBaseBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{readContextBaseBinary()}{readContextBaseBinary()}}
{\footnotesize\ttfamily void helib\+::read\+Context\+Base\+Binary (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{s,  }\item[{unsigned long \&}]{m,  }\item[{unsigned long \&}]{p,  }\item[{unsigned long \&}]{r,  }\item[{std\+::vector$<$ long $>$ \&}]{gens,  }\item[{std\+::vector$<$ long $>$ \&}]{ords }\end{DoxyParamCaption})}



read \mbox{[}m p r gens ords\mbox{]} data, needed to construct context 

\mbox{\Hypertarget{namespacehelib_a4a07fadbe58c0bf5c4be26d9bb245755}\label{namespacehelib_a4a07fadbe58c0bf5c4be26d9bb245755}} 
\index{helib@{helib}!readContextBinary@{readContextBinary}}
\index{readContextBinary@{readContextBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{readContextBinary()}{readContextBinary()}}
{\footnotesize\ttfamily void helib\+::read\+Context\+Binary (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3e0de63e6a004056417fc6532985ce6f}\label{namespacehelib_a3e0de63e6a004056417fc6532985ce6f}} 
\index{helib@{helib}!readEyeCatcher@{readEyeCatcher}}
\index{readEyeCatcher@{readEyeCatcher}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{readEyeCatcher()}{readEyeCatcher()}}
{\footnotesize\ttfamily int helib\+::read\+Eye\+Catcher (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{const char $\ast$}]{expect }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adc9656603a03fba1b8720db0d2e5cee9}\label{namespacehelib_adc9656603a03fba1b8720db0d2e5cee9}} 
\index{helib@{helib}!readPubKeyBinary@{readPubKeyBinary}}
\index{readPubKeyBinary@{readPubKeyBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{readPubKeyBinary()}{readPubKeyBinary()}}
{\footnotesize\ttfamily void helib\+::read\+Pub\+Key\+Binary (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&}]{pk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a69b0297bb0e296d5dc39bb328d735007}\label{namespacehelib_a69b0297bb0e296d5dc39bb328d735007}} 
\index{helib@{helib}!readSecKeyBinary@{readSecKeyBinary}}
\index{readSecKeyBinary@{readSecKeyBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{readSecKeyBinary()}{readSecKeyBinary()}}
{\footnotesize\ttfamily void helib\+::read\+Sec\+Key\+Binary (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aeb2f4d4c24b1b5926fc02206f9b5db6a}\label{namespacehelib_aeb2f4d4c24b1b5926fc02206f9b5db6a}} 
\index{helib@{helib}!realToEstimatedNoise@{realToEstimatedNoise}}
\index{realToEstimatedNoise@{realToEstimatedNoise}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{realToEstimatedNoise()}{realToEstimatedNoise()}}
{\footnotesize\ttfamily double helib\+::real\+To\+Estimated\+Noise (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7b0cf6b325974c5fb87c29686d82e414}\label{namespacehelib_a7b0cf6b325974c5fb87c29686d82e414}} 
\index{helib@{helib}!recordAutomorphVal@{recordAutomorphVal}}
\index{recordAutomorphVal@{recordAutomorphVal}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{recordAutomorphVal()}{recordAutomorphVal()}}
{\footnotesize\ttfamily void helib\+::record\+Automorph\+Val (\begin{DoxyParamCaption}\item[{long}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a479ecb7208f177739fa83913e8515192}\label{namespacehelib_a479ecb7208f177739fa83913e8515192}} 
\index{helib@{helib}!recordAutomorphVal2@{recordAutomorphVal2}}
\index{recordAutomorphVal2@{recordAutomorphVal2}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{recordAutomorphVal2()}{recordAutomorphVal2()}}
{\footnotesize\ttfamily void helib\+::record\+Automorph\+Val2 (\begin{DoxyParamCaption}\item[{long}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a8e4662264ee1fcd34eb7ff13d6bbf008}\label{namespacehelib_a8e4662264ee1fcd34eb7ff13d6bbf008}} 
\index{helib@{helib}!reducedCount@{reducedCount}}
\index{reducedCount@{reducedCount}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{reducedCount()}{reducedCount()}}
{\footnotesize\ttfamily long helib\+::reduced\+Count (\begin{DoxyParamCaption}\item[{const std\+::list$<$ long $>$ \&}]{x,  }\item[{long}]{n,  }\item[{bool $\ast$}]{aux }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7afc81441c478d7cd4749a69cbccc984}\label{namespacehelib_a7afc81441c478d7cd4749a69cbccc984}} 
\index{helib@{helib}!reduceModPhimX@{reduceModPhimX}}
\index{reduceModPhimX@{reduceModPhimX}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{reduceModPhimX()}{reduceModPhimX()}}
{\footnotesize\ttfamily void helib\+::reduce\+Mod\+PhimX (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_p_algebra}{P\+Algebra}} \&}]{palg }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7957fca02eb250ab71f07ae1e03f4f5c}\label{namespacehelib_a7957fca02eb250ab71f07ae1e03f4f5c}} 
\index{helib@{helib}!registerTimer@{registerTimer}}
\index{registerTimer@{registerTimer}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{registerTimer()}{registerTimer()}}
{\footnotesize\ttfamily void helib\+::register\+Timer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$}]{timer }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a99839e8493aba44c6de4085217a4edc6}\label{namespacehelib_a99839e8493aba44c6de4085217a4edc6}} 
\index{helib@{helib}!RelaxedInv@{RelaxedInv}}
\index{RelaxedInv@{RelaxedInv}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{RelaxedInv()}{RelaxedInv()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::\+Relaxed\+Inv (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Mat$<$ N\+T\+L\+::\+G\+F2 $>$ \&}]{x,  }\item[{const N\+T\+L\+::\+Mat$<$ N\+T\+L\+::\+G\+F2 $>$ \&}]{a }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9d5bff694c1cfdb4a55a02f01aa27ce7}\label{namespacehelib_a9d5bff694c1cfdb4a55a02f01aa27ce7}} 
\index{helib@{helib}!RelaxedInv@{RelaxedInv}}
\index{RelaxedInv@{RelaxedInv}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{RelaxedInv()}{RelaxedInv()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::\+Relaxed\+Inv (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Mat$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{x,  }\item[{const N\+T\+L\+::\+Mat$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{a }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af7b15d5fbf553550437df6ca02d5a282}\label{namespacehelib_af7b15d5fbf553550437df6ca02d5a282}} 
\index{helib@{helib}!rem@{rem}}
\index{rem@{rem}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{rem()}{rem()}}
{\footnotesize\ttfamily void helib\+::rem (\begin{DoxyParamCaption}\item[{N\+T\+L\+::zz\+\_\+pX \&}]{r,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{a,  }\item[{const \mbox{\hyperlink{classhelib_1_1zz__p_x_modulus1}{zz\+\_\+p\+X\+Modulus1}} \&}]{ff }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a048eb699c3e26a99ac2198bcc984ac75}\label{namespacehelib_a048eb699c3e26a99ac2198bcc984ac75}} 
\index{helib@{helib}!removeDups@{removeDups}}
\index{removeDups@{removeDups}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{removeDups()}{removeDups()}}
{\footnotesize\ttfamily void helib\+::remove\+Dups (\begin{DoxyParamCaption}\item[{std\+::list$<$ long $>$ \&}]{x,  }\item[{bool $\ast$}]{aux }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa43f61b11865cfa98e7999d1027cdd37}\label{namespacehelib_aa43f61b11865cfa98e7999d1027cdd37}} 
\index{helib@{helib}!repack@{repack}}
\index{repack@{repack}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{repack()}{repack()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily long helib\+::repack (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{packed,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{unpacked,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a52373565df70e730f9b11263a5c4434f}\label{namespacehelib_a52373565df70e730f9b11263a5c4434f}} 
\index{helib@{helib}!repack@{repack}}
\index{repack@{repack}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{repack()}{repack()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::repack (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{packed,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{unpacked,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae14f023af8c881464a3dbaf01b18d7da}\label{namespacehelib_ae14f023af8c881464a3dbaf01b18d7da}} 
\index{helib@{helib}!replicate@{replicate}}
\index{replicate@{replicate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicate()}{replicate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
void helib\+::replicate (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{,  }\item[{\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{ptxt,  }\item[{long}]{i }\end{DoxyParamCaption})}



Replicate single slot of a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object across all of its slots. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scheme} & Encryption scheme used (must be {\ttfamily \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}} or {\ttfamily \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}}). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ptxt} & Plaintext on which to do the replication. \\
\hline
{\em i} & Position of the slot to replicate. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to {\ttfamily $\ast$this} post replication. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_a28bebe2d214c86938103f34adecb7ff3}\label{namespacehelib_a28bebe2d214c86938103f34adecb7ff3}} 
\index{helib@{helib}!replicate@{replicate}}
\index{replicate@{replicate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicate()}{replicate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void helib\+::replicate (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctx,  }\item[{long}]{pos }\end{DoxyParamCaption})}



The value in slot \#pos is replicated in all other slots. On an n-\/slot ciphertext, this algorithm performs O(log n) 1D rotations. 

\mbox{\Hypertarget{namespacehelib_a2c6d6a64a8c538bb0189ac908896ac6c}\label{namespacehelib_a2c6d6a64a8c538bb0189ac908896ac6c}} 
\index{helib@{helib}!replicate@{replicate}}
\index{replicate@{replicate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicate()}{replicate()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::replicate (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{long}]{i }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adb07910b30bab32f4ebf91af705e3c6d}\label{namespacehelib_adb07910b30bab32f4ebf91af705e3c6d}} 
\index{helib@{helib}!replicate0@{replicate0}}
\index{replicate0@{replicate0}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicate0()}{replicate0()}}
{\footnotesize\ttfamily void helib\+::replicate0 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{pos }\end{DoxyParamCaption})}



A lower-\/level routine. Same as replicate, but assumes all slots are zero except slot \#pos. 

\mbox{\Hypertarget{namespacehelib_a55f84fcea62365a27445739f444d81db}\label{namespacehelib_a55f84fcea62365a27445739f444d81db}} 
\index{helib@{helib}!replicateAll@{replicateAll}}
\index{replicateAll@{replicateAll}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicateAll()}{replicateAll()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::replicate\+All (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{\mbox{\hyperlink{classhelib_1_1_replicate_handler}{Replicate\+Handler}} $\ast$}]{handler,  }\item[{long}]{rec\+Bound = {\ttfamily 64},  }\item[{Rep\+Aux\+Dim $\ast$}]{rep\+Aux\+Ptr = {\ttfamily nullptr} }\end{DoxyParamCaption})}

replicate\+All uses a hybrid strategy, combining the O(log n) strategy of the replicate method, with an O(1) strategy, which is faster but introduces more noise. This tradeoff is controlled by the parameter rec\+Bound\+:

\begin{DoxyItemize}
\item rec\+Bound $<$ 0\+: recursion to depth $\vert$rec\+Bound$\vert$ (faster, noisier) \item rec\+Bound ==0\+: no recursion (slower, less noise) \item rec\+Bound $>$ 0\+: the recursion depth is chosen heuristically, but is capped at rec\+Bound\end{DoxyItemize}
The default value for rec\+Bound is 64, this ensures that the choice is based only on the heuristic, which will introduce noise corresponding to O(log log n) levels of recursion, but still gives an algorithm that theoretically runs in time O(n). \mbox{\Hypertarget{namespacehelib_ab0a2f3a3e50d07abc0a16161003fc0b5}\label{namespacehelib_ab0a2f3a3e50d07abc0a16161003fc0b5}} 
\index{helib@{helib}!replicateAll@{replicateAll}}
\index{replicateAll@{replicateAll}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicateAll()}{replicateAll()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void helib\+::replicate\+All (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{long}]{rec\+Bound = {\ttfamily 64},  }\item[{Rep\+Aux\+Dim $\ast$}]{rep\+Aux\+Ptr = {\ttfamily nullptr} }\end{DoxyParamCaption})}

return the result as a std\+::vector of ciphertexts, mostly useful for debugging purposes (for real parameters would take a lot of memory) \mbox{\Hypertarget{namespacehelib_a80787c8857d1d8b8b4fad63f11201626}\label{namespacehelib_a80787c8857d1d8b8b4fad63f11201626}} 
\index{helib@{helib}!replicateAll@{replicateAll}}
\index{replicateAll@{replicateAll}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicateAll()}{replicateAll()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
void helib\+::replicate\+All (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$$>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{ptxt }\end{DoxyParamCaption})}



Generate a vector of plaintexts with each slot replicated in each plaintext. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scheme} & Encryption scheme used (must be {\ttfamily \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}} or {\ttfamily \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}}). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em v} & Vector of replicated plaintext slots. \\
\hline
{\em ptxt} & Plaintext whose slots will be replicated.\\
\hline
\end{DoxyParams}
The order of the return vector agrees with the order of the slots. i.\+e. the {\ttfamily i}th plaintext in the return value is a replication of {\ttfamily $\ast$this\mbox{[}i\mbox{]}}. \mbox{\Hypertarget{namespacehelib_ae12fb4b6143d8e2cb6a5dbf36922fbe7}\label{namespacehelib_ae12fb4b6143d8e2cb6a5dbf36922fbe7}} 
\index{helib@{helib}!replicateAllOrig@{replicateAllOrig}}
\index{replicateAllOrig@{replicateAllOrig}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicateAllOrig()}{replicateAllOrig()}}
{\footnotesize\ttfamily void helib\+::replicate\+All\+Orig (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt,  }\item[{\mbox{\hyperlink{classhelib_1_1_replicate_handler}{Replicate\+Handler}} $\ast$}]{handler,  }\item[{Rep\+Aux $\ast$}]{rep\+Aux\+Ptr = {\ttfamily nullptr} }\end{DoxyParamCaption})}

This function is obsolete, and is kept for historical purposes only. It was a first attempt at implementing the O(1)-\/amortized algorithm, but is less efficient than the function above. \mbox{\Hypertarget{namespacehelib_a3203575203906fc8b66bef7fe7a577cd}\label{namespacehelib_a3203575203906fc8b66bef7fe7a577cd}} 
\index{helib@{helib}!resetAllTimers@{resetAllTimers}}
\index{resetAllTimers@{resetAllTimers}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resetAllTimers()}{resetAllTimers()}}
{\footnotesize\ttfamily void helib\+::reset\+All\+Timers (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a49b481e5ebaa9bc469124e7c2d5eae38}\label{namespacehelib_a49b481e5ebaa9bc469124e7c2d5eae38}} 
\index{helib@{helib}!resize@{resize}}
\index{resize@{resize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::resize (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v,  }\item[{long}]{sz }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad61eac49543dd3559b386f94ca7112c9}\label{namespacehelib_ad61eac49543dd3559b386f94ca7112c9}} 
\index{helib@{helib}!resize@{resize}}
\index{resize@{resize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::resize (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v,  }\item[{long}]{sz,  }\item[{const T \&}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a65519409bc5c0f7c328147d8664ce5fb}\label{namespacehelib_a65519409bc5c0f7c328147d8664ce5fb}} 
\index{helib@{helib}!resize@{resize}}
\index{resize@{resize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$ T $>$ \&}]{v,  }\item[{long}]{new\+Size }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a810f01874466a0f57b41f96b8cb7a96c}\label{namespacehelib_a810f01874466a0f57b41f96b8cb7a96c}} 
\index{helib@{helib}!resize@{resize}}
\index{resize@{resize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v,  }\item[{long}]{new\+Size,  }\item[{const T \&}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6a1574e2c95b30b1eb204d669f029368}\label{namespacehelib_a6a1574e2c95b30b1eb204d669f029368}} 
\index{helib@{helib}!resize@{resize}}
\index{resize@{resize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v,  }\item[{long}]{new\+Size,  }\item[{const T $\ast$}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a91e17a6dd739205036bdc410372608cc}\label{namespacehelib_a91e17a6dd739205036bdc410372608cc}} 
\index{helib@{helib}!resize@{resize}}
\index{resize@{resize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::resize (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v,  }\item[{long}]{sz }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae8aea4186c17622aa24763219ba2e39c}\label{namespacehelib_ae8aea4186c17622aa24763219ba2e39c}} 
\index{helib@{helib}!resize@{resize}}
\index{resize@{resize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::resize (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v,  }\item[{long}]{sz,  }\item[{const T \&}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a8dfd59b19280a7a98989bbc0dd6a8c2c}\label{namespacehelib_a8dfd59b19280a7a98989bbc0dd6a8c2c}} 
\index{helib@{helib}!reverse@{reverse}}
\index{reverse@{reverse}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{reverse()}{reverse()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::reverse (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v,  }\item[{long}]{lo,  }\item[{long}]{hi }\end{DoxyParamCaption})}



Reverse a vector in place. 

\mbox{\Hypertarget{namespacehelib_a1f74d875dc046b81eef94c8f091e5c09}\label{namespacehelib_a1f74d875dc046b81eef94c8f091e5c09}} 
\index{helib@{helib}!RLWE@{RLWE}}
\index{RLWE@{RLWE}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{RLWE()}{RLWE()}}
{\footnotesize\ttfamily double helib\+::\+R\+L\+WE (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{c0,  }\item[{\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{c1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{s,  }\item[{long}]{p,  }\item[{N\+T\+L\+::\+ZZ $\ast$}]{prg\+Seed = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Choose random c0,c1 such that c0+s$\ast$c1 = p$\ast$e for a short e Returns a high-\/probability bound on the L-\/infty norm of the canonical embedding \mbox{\Hypertarget{namespacehelib_a4349e62cf946950025929996328abf7c}\label{namespacehelib_a4349e62cf946950025929996328abf7c}} 
\index{helib@{helib}!RLWE1@{RLWE1}}
\index{RLWE1@{RLWE1}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{RLWE1()}{RLWE1()}}
{\footnotesize\ttfamily double helib\+::\+R\+L\+W\+E1 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{c0,  }\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{c1,  }\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{s,  }\item[{long}]{p }\end{DoxyParamCaption})}



Same as R\+L\+WE, but assumes that c1 is already chosen by the caller. 

\mbox{\Hypertarget{namespacehelib_a34783d4707b52b8cb0341187d50f8265}\label{namespacehelib_a34783d4707b52b8cb0341187d50f8265}} 
\index{helib@{helib}!rotate@{rotate}}
\index{rotate@{rotate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{rotate()}{rotate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::rotate (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{long}]{k }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1688528ff1a377be38502ae7c048336c}\label{namespacehelib_a1688528ff1a377be38502ae7c048336c}} 
\index{helib@{helib}!rotate@{rotate}}
\index{rotate@{rotate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{rotate()}{rotate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::rotate (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v,  }\item[{long}]{k }\end{DoxyParamCaption})}



Rotate a vector in place using swaps. 

\mbox{\Hypertarget{namespacehelib_a55aba5934157b9d7517101534a0053a2}\label{namespacehelib_a55aba5934157b9d7517101534a0053a2}} 
\index{helib@{helib}!runningSums@{runningSums}}
\index{runningSums@{runningSums}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{runningSums()}{runningSums()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::running\+Sums (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt }\end{DoxyParamCaption})}



A ctxt that encrypts $(x_1, ..., x_n)$ is replaced by an encryption of $(y_1, ..., y_n)$, where $y_i = sum_{j\le i} x_j$. 

\mbox{\Hypertarget{namespacehelib_a3ec4c5776cc1a48bb6d6a3ae4e64a4b7}\label{namespacehelib_a3ec4c5776cc1a48bb6d6a3ae4e64a4b7}} 
\index{helib@{helib}!runningSums@{runningSums}}
\index{runningSums@{runningSums}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{runningSums()}{runningSums()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::running\+Sums (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1dac9d465c144cdd7f736730704c38e6}\label{namespacehelib_a1dac9d465c144cdd7f736730704c38e6}} 
\index{helib@{helib}!sameObject@{sameObject}}
\index{sameObject@{sameObject}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sameObject()}{sameObject()}}
{\footnotesize\ttfamily template$<$typename T1 , typename T2 $>$ \\
bool helib\+::same\+Object (\begin{DoxyParamCaption}\item[{const T1 $\ast$}]{p1,  }\item[{const T2 $\ast$}]{p2 }\end{DoxyParamCaption})}



Testing if two vectors point to the same object. 

\mbox{\Hypertarget{namespacehelib_a6d1e9c8e38d8a8f73b315b2cf874cebe}\label{namespacehelib_a6d1e9c8e38d8a8f73b315b2cf874cebe}} 
\index{helib@{helib}!sampleGaussian@{sampleGaussian}}
\index{sampleGaussian@{sampleGaussian}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleGaussian()}{sampleGaussian()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void helib\+::sample\+Gaussian (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{long}]{n,  }\item[{double}]{stdev }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adccfccbd4c008360cc40afa2fa8bc3ad}\label{namespacehelib_adccfccbd4c008360cc40afa2fa8bc3ad}} 
\index{helib@{helib}!sampleGaussian@{sampleGaussian}}
\index{sampleGaussian@{sampleGaussian}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleGaussian()}{sampleGaussian()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void helib\+::sample\+Gaussian (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{dvec,  }\item[{long}]{n,  }\item[{double}]{stdev }\end{DoxyParamCaption})}



Choose a vector of continuous Gaussians. 

\mbox{\Hypertarget{namespacehelib_a1d8ea79ceef3847786a1f9422fc011e7}\label{namespacehelib_a1d8ea79ceef3847786a1f9422fc011e7}} 
\index{helib@{helib}!sampleGaussian@{sampleGaussian}}
\index{sampleGaussian@{sampleGaussian}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleGaussian()}{sampleGaussian()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily double helib\+::sample\+Gaussian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{double}]{stdev }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9ca8304d01fccbbac9264eee5d5a24cb}\label{namespacehelib_a9ca8304d01fccbbac9264eee5d5a24cb}} 
\index{helib@{helib}!sampleGaussian@{sampleGaussian}}
\index{sampleGaussian@{sampleGaussian}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleGaussian()}{sampleGaussian()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void helib\+::sample\+Gaussian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{long}]{n,  }\item[{double}]{stdev }\end{DoxyParamCaption})}



Sample polynomials with Gaussian coefficients. 

\mbox{\Hypertarget{namespacehelib_abc2cb417d4cb136fe2f25fea08aaff16}\label{namespacehelib_abc2cb417d4cb136fe2f25fea08aaff16}} 
\index{helib@{helib}!sampleGaussianBounded@{sampleGaussianBounded}}
\index{sampleGaussianBounded@{sampleGaussianBounded}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleGaussianBounded()}{sampleGaussianBounded()}}
{\footnotesize\ttfamily double helib\+::sample\+Gaussian\+Bounded (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{double}]{stdev }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa510a5dd7033e859ab4e6759a1b1b207}\label{namespacehelib_aa510a5dd7033e859ab4e6759a1b1b207}} 
\index{helib@{helib}!sampleHWt@{sampleHWt}}
\index{sampleHWt@{sampleHWt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleHWt()}{sampleHWt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::sample\+H\+Wt (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{long}]{n,  }\item[{long}]{Hwt = {\ttfamily 100} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af97518f36b0358f1f178ce85e51c5d82}\label{namespacehelib_af97518f36b0358f1f178ce85e51c5d82}} 
\index{helib@{helib}!sampleHWt@{sampleHWt}}
\index{sampleHWt@{sampleHWt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleHWt()}{sampleHWt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily double helib\+::sample\+H\+Wt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{long}]{Hwt = {\ttfamily 100} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3cebf12977a97396ba96bdc5fe8162e7}\label{namespacehelib_a3cebf12977a97396ba96bdc5fe8162e7}} 
\index{helib@{helib}!sampleHWt@{sampleHWt}}
\index{sampleHWt@{sampleHWt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleHWt()}{sampleHWt()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::sample\+H\+Wt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{long}]{n,  }\item[{long}]{Hwt = {\ttfamily 100} }\end{DoxyParamCaption})}



Sample a degree-\/(n-\/1) poly as above, with only Hwt nonzero coefficients. 

\mbox{\Hypertarget{namespacehelib_ae703021ed961c9a45e32d09c4b965781}\label{namespacehelib_ae703021ed961c9a45e32d09c4b965781}} 
\index{helib@{helib}!sampleHWtBounded@{sampleHWtBounded}}
\index{sampleHWtBounded@{sampleHWtBounded}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleHWtBounded()}{sampleHWtBounded()}}
{\footnotesize\ttfamily double helib\+::sample\+H\+Wt\+Bounded (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{long}]{Hwt = {\ttfamily 100} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a8e75ae20952ceae0b4e92034d7128457}\label{namespacehelib_a8e75ae20952ceae0b4e92034d7128457}} 
\index{helib@{helib}!sampleHWtBoundedEffectiveBound@{sampleHWtBoundedEffectiveBound}}
\index{sampleHWtBoundedEffectiveBound@{sampleHWtBoundedEffectiveBound}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleHWtBoundedEffectiveBound()}{sampleHWtBoundedEffectiveBound()}}
{\footnotesize\ttfamily double helib\+::sample\+H\+Wt\+Bounded\+Effective\+Bound (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{long}]{Hwt = {\ttfamily 100} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7aab1a9871644fc36223b8009290ef66}\label{namespacehelib_a7aab1a9871644fc36223b8009290ef66}} 
\index{helib@{helib}!sampleSmall@{sampleSmall}}
\index{sampleSmall@{sampleSmall}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleSmall()}{sampleSmall()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::sample\+Small (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{long}]{n,  }\item[{double}]{prob = {\ttfamily 0.5} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa20a241c380919c47e8375ac01d61187}\label{namespacehelib_aa20a241c380919c47e8375ac01d61187}} 
\index{helib@{helib}!sampleSmall@{sampleSmall}}
\index{sampleSmall@{sampleSmall}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleSmall()}{sampleSmall()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily double helib\+::sample\+Small (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_abc5ec6f6ac945f2c5bcdf04fb7bcf0a9}\label{namespacehelib_abc5ec6f6ac945f2c5bcdf04fb7bcf0a9}} 
\index{helib@{helib}!sampleSmall@{sampleSmall}}
\index{sampleSmall@{sampleSmall}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleSmall()}{sampleSmall()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::sample\+Small (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{long}]{n,  }\item[{double}]{prob = {\ttfamily 0.5} }\end{DoxyParamCaption})}

Sample a degree-\/(n-\/1) poly, with -\/1/0/+1 coefficients. Each coefficients is +-\/1 with probability prob/2 each, and 0 with probability 1-\/prob. By default, pr\mbox{[}nonzero\mbox{]}=1/2. \mbox{\Hypertarget{namespacehelib_a50866077cb1daad6200cd8b374613539}\label{namespacehelib_a50866077cb1daad6200cd8b374613539}} 
\index{helib@{helib}!sampleSmallBounded@{sampleSmallBounded}}
\index{sampleSmallBounded@{sampleSmallBounded}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleSmallBounded()}{sampleSmallBounded()}}
{\footnotesize\ttfamily double helib\+::sample\+Small\+Bounded (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5c90da3ab82439eb3574afc268f88050}\label{namespacehelib_a5c90da3ab82439eb3574afc268f88050}} 
\index{helib@{helib}!sampleUniform@{sampleUniform}}
\index{sampleUniform@{sampleUniform}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleUniform()}{sampleUniform()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily N\+T\+L\+::xdouble helib\+::sample\+Uniform (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{const N\+T\+L\+::\+ZZ \&}]{B = {\ttfamily NTL\+:\+:ZZ(100L)} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2882109801afa606ee6ec39f6fd48348}\label{namespacehelib_a2882109801afa606ee6ec39f6fd48348}} 
\index{helib@{helib}!sampleUniform@{sampleUniform}}
\index{sampleUniform@{sampleUniform}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleUniform()}{sampleUniform()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void helib\+::sample\+Uniform (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Z\+ZX \&}]{poly,  }\item[{long}]{n,  }\item[{const N\+T\+L\+::\+ZZ \&}]{B = {\ttfamily NTL\+:\+:ZZ(100L)} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa21875fc9b1d3c8dad59e1c3f66f0718}\label{namespacehelib_aa21875fc9b1d3c8dad59e1c3f66f0718}} 
\index{helib@{helib}!sampleUniform@{sampleUniform}}
\index{sampleUniform@{sampleUniform}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleUniform()}{sampleUniform()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily double helib\+::sample\+Uniform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context,  }\item[{long}]{B = {\ttfamily 100} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7b922617fd57c98218c1eada9ffb9cb5}\label{namespacehelib_a7b922617fd57c98218c1eada9ffb9cb5}} 
\index{helib@{helib}!sampleUniform@{sampleUniform}}
\index{sampleUniform@{sampleUniform}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sampleUniform()}{sampleUniform()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void helib\+::sample\+Uniform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{poly,  }\item[{long}]{n,  }\item[{long}]{B = {\ttfamily 100} }\end{DoxyParamCaption})}



Sample a degree-\/(n-\/1) Z\+ZX, with coefficients uniform in \mbox{[}-\/B,B\mbox{]}. 

\mbox{\Hypertarget{namespacehelib_a0df3789de0744e7c90d5a5d6cf54a5ed}\label{namespacehelib_a0df3789de0744e7c90d5a5d6cf54a5ed}} 
\index{helib@{helib}!seekPastChar@{seekPastChar}}
\index{seekPastChar@{seekPastChar}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{seekPastChar()}{seekPastChar()}}
{\footnotesize\ttfamily void helib\+::seek\+Past\+Char (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{str,  }\item[{int}]{cc }\end{DoxyParamCaption})}



Advance the input stream beyond white spaces and a single instance of the char cc. 

\mbox{\Hypertarget{namespacehelib_a1784c6548249c484976efcf52a0416d7}\label{namespacehelib_a1784c6548249c484976efcf52a0416d7}} 
\index{helib@{helib}!serialize@{serialize}}
\index{serialize@{serialize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void helib\+::serialize (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}} \&}]{poly }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em os} & Output {\ttfamily std\+::ostream}. \\
\hline
{\em poly} & {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object to be written. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Input {\ttfamily std\+::ostream} post writing. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
p2r and G are not serialized, see note of {\ttfamily deserialize}.
\end{DoxyNote}
The output stream will be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each coefficient of {\ttfamily poly} will be serialized in an element of such list by the {\ttfamily $>$$>$} operator.~\newline
For example if we have a {\ttfamily \mbox{\hyperlink{classhelib_1_1_poly_mod}{Poly\+Mod}}} object {\ttfamily poly} such that {\ttfamily poly\mbox{[}0\mbox{]}=coef0}, {\ttfamily poly\mbox{[}1\mbox{]}=coef1}, {\ttfamily poly\mbox{[}2\mbox{]}=coef2}, and {\ttfamily poly\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}, it will be serialized as \textquotesingle{}\mbox{[}\textquotesingle{}coef0\textquotesingle{}, \textquotesingle{}coef1\textquotesingle{}, \textquotesingle{}coef2\textquotesingle{}\mbox{]}\textquotesingle{}. \mbox{\Hypertarget{namespacehelib_ab41ed1eb42cb018a129e7cb2fbbb29ff}\label{namespacehelib_ab41ed1eb42cb018a129e7cb2fbbb29ff}} 
\index{helib@{helib}!serialize@{serialize}}
\index{serialize@{serialize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Scheme $>$ \\
void helib\+::serialize (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ Scheme $>$ \&}]{ptxt }\end{DoxyParamCaption})}



Function to serialize a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$Scheme$>$}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scheme} & The {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object scheme. Can be only be {\ttfamily \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}} or {\ttfamily \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em os} & Output {\ttfamily std\+::ostream}. \\
\hline
{\em ptxt} & {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} object to be written. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Input {\ttfamily std\+::ostream} post serializing. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
{\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}} {\ttfamily context} is not serialized, see note of {\ttfamily deserialize}.
\end{DoxyNote}
The output stream will be formatted as a comma-\/separated list surrounded by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{}.~\newline
Each slot of {\ttfamily ptxt} will be serialized in an element of such list by the {\ttfamily serialize} function determined by the scheme.~\newline
For example if we have a plaintext {\ttfamily ptxt} such that {\ttfamily ptxt\mbox{[}0\mbox{]}=slot0}, {\ttfamily ptxt\mbox{[}1\mbox{]}=slot1}, {\ttfamily ptxt\mbox{[}2\mbox{]}=slot2}, and {\ttfamily ptxt\mbox{[}i\mbox{]}=0} for {\ttfamily i$>$2}, it will be serialized as \textquotesingle{}\mbox{[}\textquotesingle{}slot0\textquotesingle{}, \textquotesingle{}slot1\textquotesingle{}, \textquotesingle{}slot2\textquotesingle{}, {\ttfamily 0}, {\ttfamily 0} ...\mbox{]}\textquotesingle{}. \mbox{\Hypertarget{namespacehelib_adcb4ae8ef54886b93b4639999a620630}\label{namespacehelib_adcb4ae8ef54886b93b4639999a620630}} 
\index{helib@{helib}!serialize@{serialize}}
\index{serialize@{serialize}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void helib\+::serialize (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const std\+::complex$<$ double $>$ \&}]{num }\end{DoxyParamCaption})}



Serialize a {\ttfamily std\+::complex$<$double$>$} to the output stream {\ttfamily os} delimited by \textquotesingle{}\mbox{[}\textquotesingle{} and \textquotesingle{}\mbox{]}\textquotesingle{} (instead of the default \textquotesingle{}(\textquotesingle{}, \textquotesingle{})\textquotesingle{}). 


\begin{DoxyParams}{Parameters}
{\em os} & The output stream reference. \\
\hline
{\em num} & The complex number to serialize.\\
\hline
\end{DoxyParams}
The output will be formatted as \textquotesingle{}\mbox{[}\textquotesingle{}{\ttfamily num.\+real()}\textquotesingle{}, \textquotesingle{}{\ttfamily num.\+imag()}\textquotesingle{}\mbox{]}\textquotesingle{}. \mbox{\Hypertarget{namespacehelib_ad6f0ba91399ca673009e2d72a2c5db8f}\label{namespacehelib_ad6f0ba91399ca673009e2d72a2c5db8f}} 
\index{helib@{helib}!serialize$<$ BGV $>$@{serialize$<$ BGV $>$}}
\index{serialize$<$ BGV $>$@{serialize$<$ BGV $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{serialize$<$ BGV $>$()}{serialize< BGV >()}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_adcb4ae8ef54886b93b4639999a620630}{helib\+::serialize}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3acb5806f04e3ec63ebef2f1b64fac03}\label{namespacehelib_a3acb5806f04e3ec63ebef2f1b64fac03}} 
\index{helib@{helib}!serialize$<$ CKKS $>$@{serialize$<$ CKKS $>$}}
\index{serialize$<$ CKKS $>$@{serialize$<$ CKKS $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{serialize$<$ CKKS $>$()}{serialize< CKKS >()}}
{\footnotesize\ttfamily template void \mbox{\hyperlink{namespacehelib_adcb4ae8ef54886b93b4639999a620630}{helib\+::serialize}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&}]{ptxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a1ce92a7a0f311e90d9022ea931a671ec}\label{namespacehelib_a1ce92a7a0f311e90d9022ea931a671ec}} 
\index{helib@{helib}!setAutomorphVals@{setAutomorphVals}}
\index{setAutomorphVals@{setAutomorphVals}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setAutomorphVals()}{setAutomorphVals()}}
{\footnotesize\ttfamily void helib\+::set\+Automorph\+Vals (\begin{DoxyParamCaption}\item[{std\+::set$<$ long $>$ $\ast$}]{a\+Vals }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a8fab1809e50aa6fc8c0f80e66943f490}\label{namespacehelib_a8fab1809e50aa6fc8c0f80e66943f490}} 
\index{helib@{helib}!setAutomorphVals2@{setAutomorphVals2}}
\index{setAutomorphVals2@{setAutomorphVals2}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setAutomorphVals2()}{setAutomorphVals2()}}
{\footnotesize\ttfamily void helib\+::set\+Automorph\+Vals2 (\begin{DoxyParamCaption}\item[{std\+::set$<$ long $>$ $\ast$}]{a\+Vals }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_af8f51eef1d124d7e046b6a276d857fdb}\label{namespacehelib_af8f51eef1d124d7e046b6a276d857fdb}} 
\index{helib@{helib}!setDryRun@{setDryRun}}
\index{setDryRun@{setDryRun}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setDryRun()}{setDryRun()}}
{\footnotesize\ttfamily bool helib\+::set\+Dry\+Run (\begin{DoxyParamCaption}\item[{bool}]{to\+What = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_adcd8aedd768d6294cf41cd0c32b48b7d}\label{namespacehelib_adcd8aedd768d6294cf41cd0c32b48b7d}} 
\index{helib@{helib}!setHyperColumn@{setHyperColumn}}
\index{setHyperColumn@{setHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setHyperColumn()}{setHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template void helib\+::set\+Hyper\+Column (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ long $>$ \&}]{s,  }\item[{long}]{pos }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5926b1368764799c58fbbedb10704593}\label{namespacehelib_a5926b1368764799c58fbbedb10704593}} 
\index{helib@{helib}!setHyperColumn@{setHyperColumn}}
\index{setHyperColumn@{setHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setHyperColumn()}{setHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template void helib\+::set\+Hyper\+Column (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ long $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ long $>$ \&}]{s,  }\item[{long}]{pos,  }\item[{const long \&}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ada3f2a2d4e46f0069338139732ca4113}\label{namespacehelib_ada3f2a2d4e46f0069338139732ca4113}} 
\index{helib@{helib}!setHyperColumn@{setHyperColumn}}
\index{setHyperColumn@{setHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setHyperColumn()}{setHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template void helib\+::set\+Hyper\+Column (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{s,  }\item[{long}]{pos }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ab90fa0fa3007a94813b26131c7ae3a1d}\label{namespacehelib_ab90fa0fa3007a94813b26131c7ae3a1d}} 
\index{helib@{helib}!setHyperColumn@{setHyperColumn}}
\index{setHyperColumn@{setHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setHyperColumn()}{setHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template void helib\+::set\+Hyper\+Column (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ N\+T\+L\+::zz\+\_\+p $>$ \&}]{s,  }\item[{long}]{pos,  }\item[{const N\+T\+L\+::zz\+\_\+p \&}]{val }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa12cedff32fc67534e469690637bee2d}\label{namespacehelib_aa12cedff32fc67534e469690637bee2d}} 
\index{helib@{helib}!setHyperColumn@{setHyperColumn}}
\index{setHyperColumn@{setHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setHyperColumn()}{setHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::set\+Hyper\+Column (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ T $>$ \&}]{s,  }\item[{long}]{pos }\end{DoxyParamCaption})}

set\+Hyper\+Column does the reverse of get\+Hyper\+Column, setting the column to the given vector \mbox{\Hypertarget{namespacehelib_abfbaf86183c619b1eef87517dcaeacd3}\label{namespacehelib_abfbaf86183c619b1eef87517dcaeacd3}} 
\index{helib@{helib}!setHyperColumn@{setHyperColumn}}
\index{setHyperColumn@{setHyperColumn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setHyperColumn()}{setHyperColumn()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::set\+Hyper\+Column (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Vec$<$ T $>$ \&}]{v,  }\item[{const \mbox{\hyperlink{classhelib_1_1_cube_slice}{Cube\+Slice}}$<$ T $>$ \&}]{s,  }\item[{long}]{pos,  }\item[{const T \&}]{val }\end{DoxyParamCaption})}

this version of set\+Hyper\+Column implicitly pads v with a default value, if v is too short \mbox{\Hypertarget{namespacehelib_a07b53294ce70bc1a04b741ef3ac4512d}\label{namespacehelib_a07b53294ce70bc1a04b741ef3ac4512d}} 
\index{helib@{helib}!setLengthZero@{setLengthZero}}
\index{setLengthZero@{setLengthZero}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setLengthZero()}{setLengthZero()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::set\+Length\+Zero (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ T $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5c0a4656214afc3e52fa83408be3ff6a}\label{namespacehelib_a5c0a4656214afc3e52fa83408be3ff6a}} 
\index{helib@{helib}!setLengthZero@{setLengthZero}}
\index{setLengthZero@{setLengthZero}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setLengthZero()}{setLengthZero()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::set\+Length\+Zero (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhelib_1_1_ptr_matrix}{Ptr\+Matrix}}$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a030064c52dceba94106ffbd8afb564ef}\label{namespacehelib_a030064c52dceba94106ffbd8afb564ef}} 
\index{helib@{helib}!setLengthZero@{setLengthZero}}
\index{setLengthZero@{setLengthZero}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setLengthZero()}{setLengthZero()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::set\+Length\+Zero (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae2de6d470f49ed882f0bde7b67f5c456}\label{namespacehelib_ae2de6d470f49ed882f0bde7b67f5c456}} 
\index{helib@{helib}!setLengthZero@{setLengthZero}}
\index{setLengthZero@{setLengthZero}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setLengthZero()}{setLengthZero()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::set\+Length\+Zero (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a4672b8f7cb141fc61055c0ccf5f09e56}\label{namespacehelib_a4672b8f7cb141fc61055c0ccf5f09e56}} 
\index{helib@{helib}!setTimersOff@{setTimersOff}}
\index{setTimersOff@{setTimersOff}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setTimersOff()}{setTimersOff()}}
{\footnotesize\ttfamily void helib\+::set\+Timers\+Off (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a84fe94a9675113ebaf52d87806572cf8}\label{namespacehelib_a84fe94a9675113ebaf52d87806572cf8}} 
\index{helib@{helib}!setTimersOn@{setTimersOn}}
\index{setTimersOn@{setTimersOn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setTimersOn()}{setTimersOn()}}
{\footnotesize\ttfamily void helib\+::set\+Timers\+On (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_aad44440822118a09af899ff2798464d3}\label{namespacehelib_aad44440822118a09af899ff2798464d3}} 
\index{helib@{helib}!setupDebugGlobals@{setupDebugGlobals}}
\index{setupDebugGlobals@{setupDebugGlobals}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{setupDebugGlobals()}{setupDebugGlobals()}}
{\footnotesize\ttfamily void helib\+::setup\+Debug\+Globals (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} $\ast$}]{debug\+\_\+key,  }\item[{const std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} $>$ \&}]{debug\+\_\+ea,  }\item[{N\+T\+L\+::\+Z\+ZX}]{debug\+\_\+ptxt = {\ttfamily NTL\+:\+:ZZX\{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Setup function for setting up the global debug variables. 

\begin{DoxyNote}{Note}
Works only if {\ttfamily H\+E\+L\+I\+B\+\_\+\+D\+E\+B\+UG} is defined. It does not do anything otherwise 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_ae2250fb1a88c915ce004837c63aa5ad7}\label{namespacehelib_ae2250fb1a88c915ce004837c63aa5ad7}} 
\index{helib@{helib}!shift@{shift}}
\index{shift@{shift}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{shift()}{shift()}}
{\footnotesize\ttfamily void helib\+::shift (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{long}]{k }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5442620f8d9b1e48c79e6d0c30eb9cec}\label{namespacehelib_a5442620f8d9b1e48c79e6d0c30eb9cec}} 
\index{helib@{helib}!splitBinaryNums@{splitBinaryNums}}
\index{splitBinaryNums@{splitBinaryNums}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{splitBinaryNums()}{splitBinaryNums()}}
{\footnotesize\ttfamily void helib\+::split\+Binary\+Nums (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{left\+Split,  }\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{right\+Split,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{input }\end{DoxyParamCaption})}



Splits a single binary number into two binary numbers {\ttfamily left\+Split} and {\ttfamily right\+Split}. 

Split a binary number into two separate binary numbers.


\begin{DoxyParams}{Parameters}
{\em left\+Split} & Left hand side of the split. \\
\hline
{\em right\+Split} & Right hand side of the split. \\
\hline
{\em input} & Binary number to be split. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The size of {\ttfamily left\+Split} and {\ttfamily right\+Split} must sum to the size of {\ttfamily input}. 

The location of the split is defined by the sizes of {\ttfamily left\+Split} and {\ttfamily right\+Split}. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a305064dc4866c160a571bd653556c113}\label{namespacehelib_a305064dc4866c160a571bd653556c113}} 
\index{helib@{helib}!sub@{sub}}
\index{sub@{sub}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sub()}{sub()}}
{\footnotesize\ttfamily void helib\+::sub (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3828f8e07ee92999ebe6163fb96c5fd5}\label{namespacehelib_a3828f8e07ee92999ebe6163fb96c5fd5}} 
\index{helib@{helib}!subtractBinary@{subtractBinary}}
\index{subtractBinary@{subtractBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{subtractBinary()}{subtractBinary()}}
{\footnotesize\ttfamily void helib\+::subtract\+Binary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{difference,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{lhs,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{rhs,  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Subtracts {\ttfamily rhs} from {\ttfamily lhs} where {\ttfamily lhs}, {\ttfamily rhs} are in 2\textquotesingle{}s complement. 


\begin{DoxyParams}{Parameters}
{\em difference} & Reference to the difference post subtraction. \\
\hline
{\em lhs} & Left hand side of subtraction. \\
\hline
{\em rhs} & Right hand side of subtraction. \\
\hline
{\em unpack\+Slot\+Encoding} & vector of constants for unpacking, as used in bootstrapping. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\ttfamily lhs} and {\ttfamily rhs} must have the same size. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacehelib_a31dcd6fc8861bd6ead98d082fba87214}\label{namespacehelib_a31dcd6fc8861bd6ead98d082fba87214}} 
\index{helib@{helib}!sumOfCoeffs@{sumOfCoeffs}}
\index{sumOfCoeffs@{sumOfCoeffs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sumOfCoeffs()}{sumOfCoeffs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily N\+T\+L\+::\+ZZ helib\+::sum\+Of\+Coeffs (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_adcbfc533a08e770ed13e226150f57298}\label{namespacehelib_adcbfc533a08e770ed13e226150f57298}} 
\index{helib@{helib}!sumOfCoeffs@{sumOfCoeffs}}
\index{sumOfCoeffs@{sumOfCoeffs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sumOfCoeffs()}{sumOfCoeffs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily N\+T\+L\+::\+ZZ helib\+::sum\+Of\+Coeffs (\begin{DoxyParamCaption}\item[{const N\+T\+L\+::\+Z\+ZX \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_afb375497516b4f80ee52cca6bbdf07fa}\label{namespacehelib_afb375497516b4f80ee52cca6bbdf07fa}} 
\index{helib@{helib}!sumOfCoeffs@{sumOfCoeffs}}
\index{sumOfCoeffs@{sumOfCoeffs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{sumOfCoeffs()}{sumOfCoeffs()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily long helib\+::sum\+Of\+Coeffs (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} \&}]{f }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a16a28125fbbf867ea3394513923a6abb}\label{namespacehelib_a16a28125fbbf867ea3394513923a6abb}} 
\index{helib@{helib}!swap@{swap}}
\index{swap@{swap}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename X , typename Cloner $>$ \\
void helib\+::swap (\begin{DoxyParamCaption}\item[{cloned\+\_\+ptr$<$ X, Cloner $>$ \&}]{x,  }\item[{cloned\+\_\+ptr$<$ X, Cloner $>$ \&}]{y }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ad420c276576021ed7278823e82771b6b}\label{namespacehelib_ad420c276576021ed7278823e82771b6b}} 
\index{helib@{helib}!swap@{swap}}
\index{swap@{swap}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename X , typename Cloner $>$ \\
void helib\+::swap (\begin{DoxyParamCaption}\item[{copied\+\_\+ptr$<$ X, Cloner $>$ \&}]{x,  }\item[{copied\+\_\+ptr$<$ X, Cloner $>$ \&}]{y }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a57a5ec00207d3ca4206aaa810e04dc5f}\label{namespacehelib_a57a5ec00207d3ca4206aaa810e04dc5f}} 
\index{helib@{helib}!tableLookup@{tableLookup}}
\index{tableLookup@{tableLookup}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{tableLookup()}{tableLookup()}}
{\footnotesize\ttfamily void helib\+::table\+Lookup (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{out,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{table,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{idx,  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}

The input is a plaintext table T\mbox{[}\mbox{]} and an array of encrypted bits I\mbox{[}\mbox{]}, holding the binary representation of an index i into T. The output is the encrypted value T\mbox{[}i\mbox{]}. \mbox{\Hypertarget{namespacehelib_a5c931bc04df2c12ffb4e48ae6eb7b404}\label{namespacehelib_a5c931bc04df2c12ffb4e48ae6eb7b404}} 
\index{helib@{helib}!tableWriteIn@{tableWriteIn}}
\index{tableWriteIn@{tableWriteIn}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{tableWriteIn()}{tableWriteIn()}}
{\footnotesize\ttfamily void helib\+::table\+Write\+In (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{table,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{idx,  }\item[{std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ $\ast$}]{unpack\+Slot\+Encoding = {\ttfamily nullptr} }\end{DoxyParamCaption})}

The input is an encrypted table T\mbox{[}\mbox{]} and an array of encrypted bits I\mbox{[}\mbox{]}, holding the binary representation of an index i into T. This function increments by one the entry T\mbox{[}i\mbox{]}. \mbox{\Hypertarget{namespacehelib_aa50b24ebf9fb1d59089cf974eee2ac90}\label{namespacehelib_aa50b24ebf9fb1d59089cf974eee2ac90}} 
\index{helib@{helib}!timer\_compare@{timer\_compare}}
\index{timer\_compare@{timer\_compare}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{timer\_compare()}{timer\_compare()}}
{\footnotesize\ttfamily bool helib\+::timer\+\_\+compare (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$}]{a,  }\item[{const \mbox{\hyperlink{classhelib_1_1_f_h_etimer}{F\+H\+Etimer}} $\ast$}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ac584b135744603cdff25e2db01b9463a}\label{namespacehelib_ac584b135744603cdff25e2db01b9463a}} 
\index{helib@{helib}!to\_ZZX@{to\_ZZX}}
\index{to\_ZZX@{to\_ZZX}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{to\_ZZX()}{to\_ZZX()}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::to\+\_\+\+Z\+ZX (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_double_c_r_t}{Double\+C\+RT}} \&}]{d }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a3259e4f89f7c305b12bd13bab812ef72}\label{namespacehelib_a3259e4f89f7c305b12bd13bab812ef72}} 
\index{helib@{helib}!TofftRep\_trunc@{TofftRep\_trunc}}
\index{TofftRep\_trunc@{TofftRep\_trunc}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{TofftRep\_trunc()}{TofftRep\_trunc()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::\+Tofft\+Rep\+\_\+trunc (\begin{DoxyParamCaption}\item[{N\+T\+L\+::fft\+Rep \&}]{y,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{x,  }\item[{long}]{k,  }\item[{long}]{len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_ab19a0354bdc3a0ef4ba47d01c8a4aaaf}\label{namespacehelib_ab19a0354bdc3a0ef4ba47d01c8a4aaaf}} 
\index{helib@{helib}!TofftRep\_trunc@{TofftRep\_trunc}}
\index{TofftRep\_trunc@{TofftRep\_trunc}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{TofftRep\_trunc()}{TofftRep\_trunc()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::\+Tofft\+Rep\+\_\+trunc (\begin{DoxyParamCaption}\item[{N\+T\+L\+::fft\+Rep \&}]{y,  }\item[{const N\+T\+L\+::zz\+\_\+pX \&}]{x,  }\item[{long}]{k,  }\item[{U\+N\+U\+S\+ED long}]{len,  }\item[{long}]{lo,  }\item[{long}]{hi }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_a8d9530775923f034eadc4f3e80f355ff}\label{namespacehelib_a8d9530775923f034eadc4f3e80f355ff}} 
\index{helib@{helib}!totalProduct@{totalProduct}}
\index{totalProduct@{totalProduct}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{totalProduct()}{totalProduct()}}
{\footnotesize\ttfamily void helib\+::total\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{out,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_af72790276847439369c96063c3cdc803}\label{namespacehelib_af72790276847439369c96063c3cdc803}} 
\index{helib@{helib}!totalSums@{totalSums}}
\index{totalSums@{totalSums}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{totalSums()}{totalSums()}}
{\footnotesize\ttfamily void helib\+::total\+Sums (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_afc63b124cf6bc1dc82f4b599d373066c}\label{namespacehelib_afc63b124cf6bc1dc82f4b599d373066c}} 
\index{helib@{helib}!traceMap@{traceMap}}
\index{traceMap@{traceMap}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{traceMap()}{traceMap()}}
{\footnotesize\ttfamily void helib\+::trace\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{ctxt }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a445beffa0d612929f2237315b80d494b}\label{namespacehelib_a445beffa0d612929f2237315b80d494b}} 
\index{helib@{helib}!TraceMap@{TraceMap}}
\index{TraceMap@{TraceMap}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{TraceMap()}{TraceMap()}}
{\footnotesize\ttfamily void helib\+::\+Trace\+Map (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+G\+F2X \&}]{w,  }\item[{const N\+T\+L\+::\+G\+F2X \&}]{a,  }\item[{long}]{d,  }\item[{const N\+T\+L\+::\+G\+F2\+X\+Modulus \&}]{F,  }\item[{const N\+T\+L\+::\+G\+F2X \&}]{b }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a02352b1415d1c647d5b8468cd479647b}\label{namespacehelib_a02352b1415d1c647d5b8468cd479647b}} 
\index{helib@{helib}!unpack@{unpack}}
\index{unpack@{unpack}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{unpack()}{unpack()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily long helib\+::unpack (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{unpacked,  }\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{packed,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{unpack\+Slot\+Encoding }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a610ab903802e50b91b45788be635dfc1}\label{namespacehelib_a610ab903802e50b91b45788be635dfc1}} 
\index{helib@{helib}!unpack@{unpack}}
\index{unpack@{unpack}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{unpack()}{unpack()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::unpack (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacehelib_afac4e5ae4b272f9ffd07daee26285dad}{Ct\+Ptrs}} \&}]{unpacked,  }\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{packed,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacehelib_a4d6002f36f1a61982fded09adf1331ca}{zzX}} $>$ \&}]{unpack\+Slot\+Encoding }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a611d3a80278b6196f62385f0d4d0efe9}\label{namespacehelib_a611d3a80278b6196f62385f0d4d0efe9}} 
\index{helib@{helib}!unpackSlots@{unpackSlots}}
\index{unpackSlots@{unpackSlots}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{unpackSlots()}{unpackSlots()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::unpack\+Slots (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::size\+\_\+t $>$ \&}]{value,  }\item[{N\+T\+L\+::\+Z\+ZX \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacehelib_aa135454e9085fe5e1f4b9f9dbc8eb55c}\label{namespacehelib_aa135454e9085fe5e1f4b9f9dbc8eb55c}} 
\index{helib@{helib}!unpackSlots@{unpackSlots}}
\index{unpackSlots@{unpackSlots}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{unpackSlots()}{unpackSlots()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::unpack\+Slots (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::size\+\_\+t $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classhelib_1_1_plaintext_array}{Plaintext\+Array}} \&}]{pa,  }\item[{const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} \&}]{ea }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a29ccc2648ee5736fe519c1c884bf1b68}\label{namespacehelib_a29ccc2648ee5736fe519c1c884bf1b68}} 
\index{helib@{helib}!Vec\_replicate@{Vec\_replicate}}
\index{Vec\_replicate@{Vec\_replicate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{Vec\_replicate()}{Vec\_replicate()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$T$>$ helib\+::\+Vec\+\_\+replicate (\begin{DoxyParamCaption}\item[{const T \&}]{a,  }\item[{long}]{n }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a2b1de5f6a3cb9f9da27cd496659cc899}\label{namespacehelib_a2b1de5f6a3cb9f9da27cd496659cc899}} 
\index{helib@{helib}!vecCopy@{vecCopy}}
\index{vecCopy@{vecCopy}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vecCopy()}{vecCopy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::vec\+Copy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v1,  }\item[{const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v2,  }\item[{long}]{size\+Limit = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7dd2ecf9ca1ddd7c2e7372fb8999030d}\label{namespacehelib_a7dd2ecf9ca1ddd7c2e7372fb8999030d}} 
\index{helib@{helib}!vecCopy@{vecCopy}}
\index{vecCopy@{vecCopy}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vecCopy()}{vecCopy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename V , typename T $>$ \\
void helib\+::vec\+Copy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v1,  }\item[{const V \&}]{v2,  }\item[{long}]{size\+Limit = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aa4d8218e2c0fee25ebec6d40d2a6036d}\label{namespacehelib_aa4d8218e2c0fee25ebec6d40d2a6036d}} 
\index{helib@{helib}!vecCopy@{vecCopy}}
\index{vecCopy@{vecCopy}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vecCopy()}{vecCopy()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename V , typename T $>$ \\
void helib\+::vec\+Copy (\begin{DoxyParamCaption}\item[{V \&}]{v1,  }\item[{const \mbox{\hyperlink{structhelib_1_1_ptr_vector}{Ptr\+Vector}}$<$ T $>$ \&}]{v2,  }\item[{long}]{size\+Limit = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a03ca08051d06a786cf812e238a0cad15}\label{namespacehelib_a03ca08051d06a786cf812e238a0cad15}} 
\index{helib@{helib}!vecCopy@{vecCopy}}
\index{vecCopy@{vecCopy}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vecCopy()}{vecCopy()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename V1 , typename V2 $>$ \\
void helib\+::vec\+Copy (\begin{DoxyParamCaption}\item[{V1 \&}]{v1,  }\item[{const V2 \&}]{v2,  }\item[{long}]{size\+Limit = {\ttfamily 0} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_ae30e7633ce81720d2e73bb8225f82923}\label{namespacehelib_ae30e7633ce81720d2e73bb8225f82923}} 
\index{helib@{helib}!vecRed@{vecRed}}
\index{vecRed@{vecRed}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vecRed()}{vecRed()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::vec\+Red (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&}]{in,  }\item[{const N\+T\+L\+::\+ZZ \&}]{q,  }\item[{bool}]{abs }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a9bc3d452674c06b19349e1bfc47cd6bb}\label{namespacehelib_a9bc3d452674c06b19349e1bfc47cd6bb}} 
\index{helib@{helib}!vecRed@{vecRed}}
\index{vecRed@{vecRed}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vecRed()}{vecRed()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::vec\+Red (\begin{DoxyParamCaption}\item[{N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&}]{out,  }\item[{const N\+T\+L\+::\+Vec$<$ N\+T\+L\+::\+ZZ $>$ \&}]{in,  }\item[{long}]{q,  }\item[{bool}]{abs }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3f11bbe3deab00c9a1dc525d23958a6c}\label{namespacehelib_a3f11bbe3deab00c9a1dc525d23958a6c}} 
\index{helib@{helib}!vector\_replicate@{vector\_replicate}}
\index{vector\_replicate@{vector\_replicate}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vector\_replicate()}{vector\_replicate()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$T$>$ helib\+::vector\+\_\+replicate (\begin{DoxyParamCaption}\item[{const T \&}]{a,  }\item[{long}]{n }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aaa86d423a862384884b7bed74e573e8f}\label{namespacehelib_aaa86d423a862384884b7bed74e573e8f}} 
\index{helib@{helib}!vecToStr@{vecToStr}}
\index{vecToStr@{vecToStr}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{vecToStr()}{vecToStr()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::string helib\+::vec\+To\+Str (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a6eafbe78be51b304a8b359f7f6142ef5}\label{namespacehelib_a6eafbe78be51b304a8b359f7f6142ef5}} 
\index{helib@{helib}!Warning@{Warning}}
\index{Warning@{Warning}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{Warning()}{Warning()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void helib\+::\+Warning (\begin{DoxyParamCaption}\item[{const char $\ast$}]{msg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function for logging a warning message. 


\begin{DoxyParams}{Parameters}
{\em msg} & The warning message. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a9582d8b75aec10d74a0a89b48678be1b}\label{namespacehelib_a9582d8b75aec10d74a0a89b48678be1b}} 
\index{helib@{helib}!Warning@{Warning}}
\index{Warning@{Warning}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{Warning()}{Warning()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void helib\+::\+Warning (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{msg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function for logging a warning message. 


\begin{DoxyParams}{Parameters}
{\em msg} & The warning message. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacehelib_a39d92caff425c0086a87a667c88003d4}\label{namespacehelib_a39d92caff425c0086a87a667c88003d4}} 
\index{helib@{helib}!write@{write}}
\index{write@{write}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write()}{write()}}
{\footnotesize\ttfamily void helib\+::write (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_moduli_sizes_a498f82c06da7dc977f99d215a35481c7}{Moduli\+Sizes\+::\+Entry}} \&}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3e05ac58f674ea9b53de6804949dea21}\label{namespacehelib_a3e05ac58f674ea9b53de6804949dea21}} 
\index{helib@{helib}!write\_ntl\_vec\_long@{write\_ntl\_vec\_long}}
\index{write\_ntl\_vec\_long@{write\_ntl\_vec\_long}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_ntl\_vec\_long()}{write\_ntl\_vec\_long()}}
{\footnotesize\ttfamily void helib\+::write\+\_\+ntl\+\_\+vec\+\_\+long (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const N\+T\+L\+::vec\+\_\+long \&}]{vl,  }\item[{long}]{int\+Size = {\ttfamily BINIO\+\_\+64BIT} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aafadc64ab3b1c319e37160cd619f3bf5}\label{namespacehelib_aafadc64ab3b1c319e37160cd619f3bf5}} 
\index{helib@{helib}!write\_raw\_double@{write\_raw\_double}}
\index{write\_raw\_double@{write\_raw\_double}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_double()}{write\_raw\_double()}}
{\footnotesize\ttfamily void helib\+::write\+\_\+raw\+\_\+double (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const double}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aab7bbf963ee93061e4bb1204438721b1}\label{namespacehelib_aab7bbf963ee93061e4bb1204438721b1}} 
\index{helib@{helib}!write\_raw\_int@{write\_raw\_int}}
\index{write\_raw\_int@{write\_raw\_int}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_int()}{write\_raw\_int()}}
{\footnotesize\ttfamily void helib\+::write\+\_\+raw\+\_\+int (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{long}]{num }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a86af3712f18a5b1fca62330b37dbb9de}\label{namespacehelib_a86af3712f18a5b1fca62330b37dbb9de}} 
\index{helib@{helib}!write\_raw\_int32@{write\_raw\_int32}}
\index{write\_raw\_int32@{write\_raw\_int32}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_int32()}{write\_raw\_int32()}}
{\footnotesize\ttfamily void helib\+::write\+\_\+raw\+\_\+int32 (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{int}]{num }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aaeff8e262314e10ad618189976b9ef93}\label{namespacehelib_aaeff8e262314e10ad618189976b9ef93}} 
\index{helib@{helib}!write\_raw\_vector@{write\_raw\_vector}}
\index{write\_raw\_vector@{write\_raw\_vector}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_vector()}{write\_raw\_vector()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void helib\+::write\+\_\+raw\+\_\+vector (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const std\+::vector$<$ T $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a374f958d521a444ec5686722c2dfad8b}\label{namespacehelib_a374f958d521a444ec5686722c2dfad8b}} 
\index{helib@{helib}!write\_raw\_vector$<$ double $>$@{write\_raw\_vector$<$ double $>$}}
\index{write\_raw\_vector$<$ double $>$@{write\_raw\_vector$<$ double $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_vector$<$ double $>$()}{write\_raw\_vector< double >()}}
{\footnotesize\ttfamily template$<$$>$ \\
void \mbox{\hyperlink{namespacehelib_aaeff8e262314e10ad618189976b9ef93}{helib\+::write\+\_\+raw\+\_\+vector}}$<$ double $>$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const std\+::vector$<$ double $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a718430742226b3f7c2b81073ea10cc64}\label{namespacehelib_a718430742226b3f7c2b81073ea10cc64}} 
\index{helib@{helib}!write\_raw\_vector$<$ long $>$@{write\_raw\_vector$<$ long $>$}}
\index{write\_raw\_vector$<$ long $>$@{write\_raw\_vector$<$ long $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_vector$<$ long $>$()}{write\_raw\_vector< long >()}}
{\footnotesize\ttfamily template$<$$>$ \\
void \mbox{\hyperlink{namespacehelib_aaeff8e262314e10ad618189976b9ef93}{helib\+::write\+\_\+raw\+\_\+vector}}$<$ long $>$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const std\+::vector$<$ long $>$ \&}]{v }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_aedb770c4cb5c37da9184d5820a000758}\label{namespacehelib_aedb770c4cb5c37da9184d5820a000758}} 
\index{helib@{helib}!write\_raw\_xdouble@{write\_raw\_xdouble}}
\index{write\_raw\_xdouble@{write\_raw\_xdouble}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_xdouble()}{write\_raw\_xdouble()}}
{\footnotesize\ttfamily void helib\+::write\+\_\+raw\+\_\+xdouble (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const N\+T\+L\+::xdouble}]{xd }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a7f1521af0f4ab251d30fc4f96531dc1d}\label{namespacehelib_a7f1521af0f4ab251d30fc4f96531dc1d}} 
\index{helib@{helib}!write\_raw\_ZZ@{write\_raw\_ZZ}}
\index{write\_raw\_ZZ@{write\_raw\_ZZ}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{write\_raw\_ZZ()}{write\_raw\_ZZ()}}
{\footnotesize\ttfamily void helib\+::write\+\_\+raw\+\_\+\+ZZ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const N\+T\+L\+::\+ZZ \&}]{zz }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a8425881cdaaef9fade4dd57cc3cf5e8b}\label{namespacehelib_a8425881cdaaef9fade4dd57cc3cf5e8b}} 
\index{helib@{helib}!writeContextBase@{writeContextBase}}
\index{writeContextBase@{writeContextBase}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{writeContextBase()}{writeContextBase()}}
{\footnotesize\ttfamily void helib\+::write\+Context\+Base (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{s,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}



write \mbox{[}m p r gens ords\mbox{]} data 

write \mbox{[}m p r\mbox{]} data \mbox{\Hypertarget{namespacehelib_a3167b996c8b02f9f390d1d9957693b9f}\label{namespacehelib_a3167b996c8b02f9f390d1d9957693b9f}} 
\index{helib@{helib}!writeContextBaseBinary@{writeContextBaseBinary}}
\index{writeContextBaseBinary@{writeContextBaseBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{writeContextBaseBinary()}{writeContextBaseBinary()}}
{\footnotesize\ttfamily void helib\+::write\+Context\+Base\+Binary (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}



write \mbox{[}m p r gens ords\mbox{]} data 

\mbox{\Hypertarget{namespacehelib_a1f9bc09cb4de5422bb79e9c4d67db80a}\label{namespacehelib_a1f9bc09cb4de5422bb79e9c4d67db80a}} 
\index{helib@{helib}!writeContextBinary@{writeContextBinary}}
\index{writeContextBinary@{writeContextBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{writeContextBinary()}{writeContextBinary()}}
{\footnotesize\ttfamily void helib\+::write\+Context\+Binary (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_context}{Context}} \&}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a5d1ce128c2df30ef155f565c6435bccb}\label{namespacehelib_a5d1ce128c2df30ef155f565c6435bccb}} 
\index{helib@{helib}!writeEyeCatcher@{writeEyeCatcher}}
\index{writeEyeCatcher@{writeEyeCatcher}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{writeEyeCatcher()}{writeEyeCatcher()}}
{\footnotesize\ttfamily void helib\+::write\+Eye\+Catcher (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const char $\ast$}]{eye }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a3fe91feb5d65b0afc826f181557a56e4}\label{namespacehelib_a3fe91feb5d65b0afc826f181557a56e4}} 
\index{helib@{helib}!writePubKeyBinary@{writePubKeyBinary}}
\index{writePubKeyBinary@{writePubKeyBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{writePubKeyBinary()}{writePubKeyBinary()}}
{\footnotesize\ttfamily void helib\+::write\+Pub\+Key\+Binary (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_pub_key}{Pub\+Key}} \&}]{pk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a360f4b2c5989ceac05b2f37fe89239f2}\label{namespacehelib_a360f4b2c5989ceac05b2f37fe89239f2}} 
\index{helib@{helib}!writeSecKeyBinary@{writeSecKeyBinary}}
\index{writeSecKeyBinary@{writeSecKeyBinary}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{writeSecKeyBinary()}{writeSecKeyBinary()}}
{\footnotesize\ttfamily void helib\+::write\+Sec\+Key\+Binary (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{str,  }\item[{const \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} \&}]{sk }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacehelib_a85715fb3484281444706eba875bfbe72}\label{namespacehelib_a85715fb3484281444706eba875bfbe72}} 
\index{helib@{helib}!zeroValue@{zeroValue}}
\index{zeroValue@{zeroValue}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{zeroValue()}{zeroValue()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T helib\+::zero\+Value (\begin{DoxyParamCaption}\item[{const T \&}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given an object {\ttfamily x} return a zero object of the same type. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of object to return. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em x} & The object to use for returning a zero object of type {\ttfamily T}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A zero object of type {\ttfamily T}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_a25a05627840d03ffb2f39269ad6323c7}\label{namespacehelib_a25a05627840d03ffb2f39269ad6323c7}} 
\index{helib@{helib}!zeroValue$<$ Ctxt $>$@{zeroValue$<$ Ctxt $>$}}
\index{zeroValue$<$ Ctxt $>$@{zeroValue$<$ Ctxt $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{zeroValue$<$ Ctxt $>$()}{zeroValue< Ctxt >()}}
{\footnotesize\ttfamily template$<$$>$ \\
\mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \mbox{\hyperlink{namespacehelib_a85715fb3484281444706eba875bfbe72}{helib\+::zero\+Value}}$<$ \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} $>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}} \&}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}} return a zero object of the same type. 


\begin{DoxyParams}{Parameters}
{\em x} & The {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}} to use for returning a zero object of type {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A zero object of type {\ttfamily \mbox{\hyperlink{classhelib_1_1_ctxt}{Ctxt}}}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_af1fa7c571ab911c358c2a01fcbcf3f11}\label{namespacehelib_af1fa7c571ab911c358c2a01fcbcf3f11}} 
\index{helib@{helib}!zeroValue$<$ Ptxt$<$ BGV $>$ $>$@{zeroValue$<$ Ptxt$<$ BGV $>$ $>$}}
\index{zeroValue$<$ Ptxt$<$ BGV $>$ $>$@{zeroValue$<$ Ptxt$<$ BGV $>$ $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{zeroValue$<$ Ptxt$<$ BGV $>$ $>$()}{zeroValue< Ptxt< BGV > >()}}
{\footnotesize\ttfamily template$<$$>$ \\
\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}$>$ \mbox{\hyperlink{namespacehelib_a85715fb3484281444706eba875bfbe72}{helib\+::zero\+Value}}$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ $>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}} $>$ \&}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}$>$} return a zero object of the same type. 


\begin{DoxyParams}{Parameters}
{\em x} & The object to use for returning a zero object of type {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}$>$}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A zero object of type {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_b_g_v}{B\+GV}}$>$}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacehelib_aa549403e89c301d7e2e4fa39a07dda0b}\label{namespacehelib_aa549403e89c301d7e2e4fa39a07dda0b}} 
\index{helib@{helib}!zeroValue$<$ Ptxt$<$ CKKS $>$ $>$@{zeroValue$<$ Ptxt$<$ CKKS $>$ $>$}}
\index{zeroValue$<$ Ptxt$<$ CKKS $>$ $>$@{zeroValue$<$ Ptxt$<$ CKKS $>$ $>$}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{zeroValue$<$ Ptxt$<$ CKKS $>$ $>$()}{zeroValue< Ptxt< CKKS > >()}}
{\footnotesize\ttfamily template$<$$>$ \\
\mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}$>$ \mbox{\hyperlink{namespacehelib_a85715fb3484281444706eba875bfbe72}{helib\+::zero\+Value}}$<$ \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ $>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$ \mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}} $>$ \&}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Given a {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}$>$} return a zero object of the same type. 


\begin{DoxyParams}{Parameters}
{\em x} & The object to use for returning a zero object of type {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}$>$}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A zero object of type {\ttfamily \mbox{\hyperlink{classhelib_1_1_ptxt}{Ptxt}}$<$\mbox{\hyperlink{structhelib_1_1_c_k_k_s}{C\+K\+KS}}$>$}. 
\end{DoxyReturn}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespacehelib_a3ba322251033959f95b296f34745836e}\label{namespacehelib_a3ba322251033959f95b296f34745836e}} 
\index{helib@{helib}!activeContext@{activeContext}}
\index{activeContext@{activeContext}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{activeContext}{activeContext}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_context}{Context}} $\ast$ helib\+::active\+Context = nullptr}

\mbox{\Hypertarget{namespacehelib_a562cdbdb456ba0e706002518589d2b1f}\label{namespacehelib_a562cdbdb456ba0e706002518589d2b1f}} 
\index{helib@{helib}!CLOCK\_SCALE@{CLOCK\_SCALE}}
\index{CLOCK\_SCALE@{CLOCK\_SCALE}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{CLOCK\_SCALE}{CLOCK\_SCALE}}
{\footnotesize\ttfamily const unsigned long helib\+::\+C\+L\+O\+C\+K\+\_\+\+S\+C\+A\+LE = (unsigned long)C\+L\+O\+C\+K\+S\+\_\+\+P\+E\+R\+\_\+\+S\+EC}

\mbox{\Hypertarget{namespacehelib_a11275c94e69653c6ca1c5b3ea8f85dba}\label{namespacehelib_a11275c94e69653c6ca1c5b3ea8f85dba}} 
\index{helib@{helib}!dbg\_ptxt@{dbg\_ptxt}}
\index{dbg\_ptxt@{dbg\_ptxt}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{dbg\_ptxt}{dbg\_ptxt}}
{\footnotesize\ttfamily N\+T\+L\+::\+Z\+ZX helib\+::dbg\+\_\+ptxt}

\mbox{\Hypertarget{namespacehelib_a1f2eab09fe947de2ae6eb8328937f0bb}\label{namespacehelib_a1f2eab09fe947de2ae6eb8328937f0bb}} 
\index{helib@{helib}!dbgEa@{dbgEa}}
\index{dbgEa@{dbgEa}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{dbgEa}{dbgEa}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classhelib_1_1_encrypted_array}{Encrypted\+Array}} $>$ helib\+::dbg\+Ea = nullptr}

\mbox{\Hypertarget{namespacehelib_a0d7d15973181b665a33077ca529f9d47}\label{namespacehelib_a0d7d15973181b665a33077ca529f9d47}} 
\index{helib@{helib}!dbgKey@{dbgKey}}
\index{dbgKey@{dbgKey}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{dbgKey}{dbgKey}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_sec_key}{Sec\+Key}} $\ast$ helib\+::dbg\+Key = nullptr}

\mbox{\Hypertarget{namespacehelib_ac088f2fa765a2ab95c318d60df164b6d}\label{namespacehelib_ac088f2fa765a2ab95c318d60df164b6d}} 
\index{helib@{helib}!erfc\_inverse@{erfc\_inverse}}
\index{erfc\_inverse@{erfc\_inverse}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{erfc\_inverse}{erfc\_inverse}}
{\footnotesize\ttfamily const double helib\+::erfc\+\_\+inverse\mbox{[}$\,$\mbox{]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{= \{0,}
\DoxyCodeLine{                               0.6744897501960817432,}
\DoxyCodeLine{                               1.1503493803760081782,}
\DoxyCodeLine{                               1.5341205443525463117,}
\DoxyCodeLine{                               1.8627318674216514554,}
\DoxyCodeLine{                               2.1538746940614562129,}
\DoxyCodeLine{                               2.4175590162365050618,}
\DoxyCodeLine{                               2.6600674686174596585,}
\DoxyCodeLine{                               2.8856349124267571473,}
\DoxyCodeLine{                               3.0972690781987844623,}
\DoxyCodeLine{                               3.2971933456919633418,}
\DoxyCodeLine{                               3.4871041041144311068,}
\DoxyCodeLine{                               3.6683292851213230192,}
\DoxyCodeLine{                               3.8419306855019108708,}
\DoxyCodeLine{                               4.0087725941685849622,}
\DoxyCodeLine{                               4.1695693233491057549,}
\DoxyCodeLine{                               4.3249190408260462571,}
\DoxyCodeLine{                               4.4753284246542033544,}
\DoxyCodeLine{                               4.6212310014992471565,}
\DoxyCodeLine{                               4.7630010342678139569,}
\DoxyCodeLine{                               4.9009642079631930118\}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacehelib_a369c8e1d9a3a6012dba0e881be855ab6}\label{namespacehelib_a369c8e1d9a3a6012dba0e881be855ab6}} 
\index{helib@{helib}!fhe\_force\_chen\_han@{fhe\_force\_chen\_han}}
\index{fhe\_force\_chen\_han@{fhe\_force\_chen\_han}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fhe\_force\_chen\_han}{fhe\_force\_chen\_han}}
{\footnotesize\ttfamily long helib\+::fhe\+\_\+force\+\_\+chen\+\_\+han = 0}

\mbox{\Hypertarget{namespacehelib_a43b6a65490d657b3d2b631fb1fe423e8}\label{namespacehelib_a43b6a65490d657b3d2b631fb1fe423e8}} 
\index{helib@{helib}!fhe\_stats@{fhe\_stats}}
\index{fhe\_stats@{fhe\_stats}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fhe\_stats}{fhe\_stats}}
{\footnotesize\ttfamily bool helib\+::fhe\+\_\+stats = false}

\mbox{\Hypertarget{namespacehelib_a443844fce5e8d1b68b5bbc11d7827836}\label{namespacehelib_a443844fce5e8d1b68b5bbc11d7827836}} 
\index{helib@{helib}!fhe\_test\_force\_bsgs@{fhe\_test\_force\_bsgs}}
\index{fhe\_test\_force\_bsgs@{fhe\_test\_force\_bsgs}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fhe\_test\_force\_bsgs}{fhe\_test\_force\_bsgs}}
{\footnotesize\ttfamily int helib\+::fhe\+\_\+test\+\_\+force\+\_\+bsgs = 0}

\mbox{\Hypertarget{namespacehelib_a4064daef7469afa9d911c7ba658e9285}\label{namespacehelib_a4064daef7469afa9d911c7ba658e9285}} 
\index{helib@{helib}!fhe\_test\_force\_hoist@{fhe\_test\_force\_hoist}}
\index{fhe\_test\_force\_hoist@{fhe\_test\_force\_hoist}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fhe\_test\_force\_hoist}{fhe\_test\_force\_hoist}}
{\footnotesize\ttfamily int helib\+::fhe\+\_\+test\+\_\+force\+\_\+hoist = 0}

\mbox{\Hypertarget{namespacehelib_a15af59c8cd87bc4a475ed3e1ce577cc7}\label{namespacehelib_a15af59c8cd87bc4a475ed3e1ce577cc7}} 
\index{helib@{helib}!fhe\_watcher@{fhe\_watcher}}
\index{fhe\_watcher@{fhe\_watcher}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{fhe\_watcher}{fhe\_watcher}}
{\footnotesize\ttfamily int helib\+::fhe\+\_\+watcher = 0}

\mbox{\Hypertarget{namespacehelib_a43d675d13f2fdad48c20753cbf9a611d}\label{namespacehelib_a43d675d13f2fdad48c20753cbf9a611d}} 
\index{helib@{helib}!helog@{helog}}
\index{helog@{helog}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{helog}{helog}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhelib_1_1_logger}{Logger}} helib\+::helog}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{= []() -\/> Logger \{}
\DoxyCodeLine{  Logger defaultLog;}
\DoxyCodeLine{  \mbox{\hyperlink{namespacehelib_a43d675d13f2fdad48c20753cbf9a611d}{helog}}.\mbox{\hyperlink{classhelib_1_1_logger_a1a71654c15c6dfa5a699c834f671a827}{setLogToFile}}(\textcolor{stringliteral}{"{}helib.log"{}});}
\DoxyCodeLine{  \textcolor{keywordflow}{return} defaultLog;}
\DoxyCodeLine{\}()}

\end{DoxyCode}


Internal global logger. 

\mbox{\Hypertarget{namespacehelib_aa4e11abf6db9206e9dc7ac9397ce28fb}\label{namespacehelib_aa4e11abf6db9206e9dc7ac9397ce28fb}} 
\index{helib@{helib}!PI@{PI}}
\index{PI@{PI}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{PI}{PI}}
{\footnotesize\ttfamily const long double helib\+::\+PI}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{=}
\DoxyCodeLine{    3.1415926535897932384626433832795028841971693993751058209749445923078164L}

\end{DoxyCode}
\mbox{\Hypertarget{namespacehelib_a244137dad8f49e984df751ef5d044f4c}\label{namespacehelib_a244137dad8f49e984df751ef5d044f4c}} 
\index{helib@{helib}!printFlag@{printFlag}}
\index{printFlag@{printFlag}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{printFlag}{printFlag}}
{\footnotesize\ttfamily long helib\+::print\+Flag\hspace{0.3cm}{\ttfamily [extern]}}

\mbox{\Hypertarget{namespacehelib_a47f0fb8de69aa81c6224003a79011ed3}\label{namespacehelib_a47f0fb8de69aa81c6224003a79011ed3}} 
\index{helib@{helib}!replicateVerboseFlag@{replicateVerboseFlag}}
\index{replicateVerboseFlag@{replicateVerboseFlag}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{replicateVerboseFlag}{replicateVerboseFlag}}
{\footnotesize\ttfamily N\+T\+L\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+L\+O\+C\+AL bool helib\+::replicate\+Verbose\+Flag = false}

\mbox{\Hypertarget{namespacehelib_a6a63df2a7e377c38ac5d33853caff325}\label{namespacehelib_a6a63df2a7e377c38ac5d33853caff325}} 
\index{helib@{helib}!thinRecrypt\_initial\_level@{thinRecrypt\_initial\_level}}
\index{thinRecrypt\_initial\_level@{thinRecrypt\_initial\_level}!helib@{helib}}
\doxysubsubsection{\texorpdfstring{thinRecrypt\_initial\_level}{thinRecrypt\_initial\_level}}
{\footnotesize\ttfamily long helib\+::thin\+Recrypt\+\_\+initial\+\_\+level\hspace{0.3cm}{\ttfamily [extern]}}

